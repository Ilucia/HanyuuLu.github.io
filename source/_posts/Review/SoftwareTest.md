---
title: 软件测试小结
date: 2019-12-02 00:00:00
tags:
    - software test
    - review
categories:
    - review
---
[toc]
# 概述

## 软件测试产生背景
  * 软件危机*

    软件的可靠性没有保障、维护费用不断上升、进度无法预测、成本增长无法控制、程序员无限增加等，形成软件开发局面失控的状态。

  * 缺陷累计放大

  * 缺陷出现原因

    * 产品说明书（主要原因）
        * 随意、易变、沟通不足
    * 设计（次要原因）
        * 随意、易变、沟通不足
    * 编码
        * 软件复杂度、进度压力、低级错误
    * 其他
        * 理解错误、测试错误

    缺乏规范化工程约束→缺陷的不断累积与放大效应

    | 阶段     | 正确需求 | 需求缺陷 | 设计缺陷 | 编码缺陷 | 未发现缺陷 |
    | -------- | -------- | -------- | -------- | -------- | ---------- |
    | 需求阶段 | √        | √        | -        | -        | -          |
    | 设计阶段 | √        | √        | √        | -        | -          |
    | 编码阶段 | √        | √        | √        | √        | -          |
    | 测试阶段 | √        | √        | √        | √        | √          |

  * 有关测试观点的正确理解

      * 软件工程

        将系统化的、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件
        
## 软件测试基本概念
  * 测试定义

      * Bill Hetzelt  定义
          * 测试就是建立一种信心，认为程序能够按照预期设想运行
          * 核心思想：测试是试图验证软件是可工作的
      * Glenford J. Myers 定义
          * 测试是为发现错误而执行一个程序或系统的过程
          * 核心思想：测试是尽可能多地发现软件错误
          * 三个**重要观点**
              * 测试是为了证明程序有错，而不是证明程序无错误
              * 一个好的测试用例是在于他能发现至今未发现的错误
              * 一个成功的测试时发现了至今未发现的错误的测试
      * IEEE Std 729-1983
          * 使用人工或是自动手段来运行或测定某个系统的过程，其目的在于检验它是否满足规定的需求或是弄清预期结果与实际结果之间的差别
      * IEEE Std 610.12-1990
        	1. 在特定的条件下运行系统或构建，观察或记录结果，对系统的某些方面做出评价
         	2. 分析某个软件项已发现现存和要求的条件之差别并评价此软件项的特性

  * 测试与调试

  * 测试目的

    1. 确保软件质量

       找出软件错误和缺陷，降低软件发布后潜在错误和缺陷造成的损失；验证软件是否能满足用户需求，树立对软件的信心。

    2. 确保软件开发过程方向的正确性

       通过分析错误产生的原因帮助发现当前开发工作所采用的软件过程的缺陷，促进软件过程改进；为风险评估提供信息

  * 测试原理/原则

    1. 用户至上

       所有测试都应追溯到用户需求。最严重的错误是导致软件是导致软件无法满足的需求。测试的目标是在用户发现缺陷前找到它们。

    2. 测试是有计划的活动

       测试计划制定先于测试的执行；测试贯穿于全部软件生存周期。

    3. 缺陷出现的集群性

       80%的错误可能源于20%的模块。

    4. 测试应从“小规模”走向“大规模”

       最初测试单个程序模块，然后在集成的模块中找缺陷，最后在整个系统中找缺陷，最后在整个系统中找缺陷

    5. 穷尽测试（完全测试）不可能

       * 输入量太大
       * 输出结果太多
       * 执行路径太多
       * etc

    6. 有效的测试应由第三方独立进行

       有些测试应避免有开发人员进行

    7. 测试无法揭示所有缺陷

       测试可以报告说有缺陷存在，但没有缺陷的话却不能说明软件没有缺陷

    8. 测试的杀虫剂悖论

       潜在缺陷对已进行的测试具有免疫力

    9. 测试是有风险的行为

       ![image-20191216223328233](/Review/SoftwareTest/image-20191216223328233.png)

       10. 并非所有的缺陷都需要修复
           * 没有足够的时间
           * 不算真正的代码缺陷
           * 修复风险太大
           * 不值得修复
           * etc

  * 测试过程*

    1. 拟定软件的**测试计划**
    2. 编制软件测试大纲
    3. 设计和生成测试用例
       * 测试用例定义
         1. 一组输入即运行**前提条件**，和为某特定目标而生成的**预期结果**（测试用例的实质）
         2. 一个文档，详细说明**输入、期望输出**，和为一测试项所准备的一组执行条件（测试用例的一种存在方式）
       * 测试用例设计准则
         1. 代表性
            * 合理与不合理
            * 合法与非法
            * 边界和越界
            * 极限数据
            * 各种操作环境
            * etc
         2. 可判定性
         3. 可再现性
    4. 实施测试
    5. 分析测试结果（测试报告）
       1. 收集测试结果
       2. 生成测试报告

  * 测试用例（三要素）

      * 输入
      * 执行条件
      * 期望输出

  * 软件测试类型

      * v模型

          * 需求分析↘概要设计↘详细设计↘编码V单元测试↗集成测试↗系统测试↗验收测试

      * w模型

        ![image-20191216224128644](/Review/SoftwareTest/image-20191216224128644.png)

      * x模型

        ![image-20191216224610871](/Review/SoftwareTest/image-20191216224610871.png)

      * 前置测试模型

        ![image-20191216224238591](/Review/SoftwareTest/image-20191216224238591.png)

      * h模型

        ![image-20191216224254440](/Review/SoftwareTest/image-20191216224254440.png)

  * 软件测试w模型

## 软件测试现状和趋势

  * 软件测试的地位（工作量百分比）*

    | 阶段 | 需求分析 | 设计 | 编码 | 测试 | 运行和维护 |
    | ---- | -------- | ---- | ---- | ---- | ---------- |
    |      | 20%      | 15%  | 20%  | 45%  | -          |

    

# 白盒测试

* 静态白盒测试
  *  在不执行代码的条件下有条理地仔细审查软件设计、体系结构和代码，从而找出软件缺陷的过程，有时被称为结构化分析
    * 尽早发现软件缺陷
    * 为后继测试中设计测试用例提供思路
    
  * desk checking
  
  * Peer preview

  * walk through

  * Inspection

  * 动态白盒测试方法

    * 定义

      一种基于**源程序**或**代码**的测试方法。依据原程序或代码逻辑结构，生成测试用例以尽可能多地发现并修改源程序错误。

      白盒分为静态白盒测试和动态白盒测试
  
    * 实施者
  
    * 单元测试
      
        * 一般由开发人员进行
        
    * 集成测试
      
    * 测试人员和开发人员共同完成
      
    * 步骤
  
      * 动态
  
        1. 程序图
        2. 生成测试用例
        3. 执行测试
        4. 分析覆盖标准
        5. 判定测试结果
      
    * 静态
        * 桌面检查
        * 代码走查
        * 代码审查
        
    * 优点
  
        * 检测代码中的判断和路径
        * 解释隐藏在代码中的错误
        * 对代码的测试比较彻底
  
    * 缺点
  
        * 无法检测代码中的不可达路径
        * 不验证需求规格
  
  * 基于控制流覆盖的测试
    * 语句覆盖测试
      * 语句覆盖
        * 程序中每条**语句**都执行一次
          * 处理错误的代码片段
          * 小概率事件（恶作剧）
          * 不可达代码
          * 较为脆弱，某些严重问题
    * 条件测试
      * 判定覆盖（分支覆盖）
        * 每个**判断**取值`True`和`False`各一次
        * 优点
            * 简单，包含语句覆盖并避免了语句覆盖覆盖的问题
        * 缺点
            * 忽略了表达式内的条件，不能发现每个条件的错误
      * 条件覆盖
        * 每个**判断中的条件**的取值至少满足一次
        * 不能保证程序所有分支都被执行
      * 判定条件覆盖
      * 每个**条件和由条件组成的判断**的取值至少满足一次
        * 错误屏蔽
          * 指原子条件取值改变不会影响判定结果，因此该条件上的取值错误是不可见的。
        * 注意**短路**
    * 条件组合覆盖
        * 每个**条件的取值组合**至少出现一次
        * $2^n$（n为原子条件数），代价昂贵
        * 测试用例的约简
            * 利用短路效应寻找最小测试用例集
    * 路径测试
      * 路径覆盖
        * 优点
          * 相对彻底的测试
        * 缺点
          * 路径分支可能以指数级增加($2^n$)
          * 存在不可达路径
          * 并未测试各个分支中的条件
        * 考虑了各种判定结果的所有可能组合但是不能覆盖判定条件中结果的各种情况
        * 覆盖能力较强但是**不能**替代条件覆盖和条件组合覆盖标准
        * 覆盖程序中的**所有路径**
    
    ![image-20191217131957930](/Review/SoftwareTest/image-20191217131957930.png)
    
  * 基于控制流的测试
  
    *  基本路径测试
      *  流程图→流图→（环复杂度）→基本路径→测试用例
      
      *  **流图**用来描述程序中的逻辑控制流
        *  节点
          
          *  表示一个或多个语句
          
        *  边
          
          *  表示控制流
          
        *  域
          
          *  由边和节点限定的区间
          
        *  基本路径
        
            *  任何贯穿程序 、至少引入一组新的处理语句或一个新判断的程序通道
        
            *  环复杂度是所有语句被执行一次所需测试用例数的上限
        
                | 环复杂度 | 含义     |
                | -------- | -------- |
                | 1-10     | 良好     |
                | 11-20    | 中等     |
                | 21-50    | 复杂     |
                | >50      | 无法理解 |
        
      *  ![image-20191217132339566](/Review/SoftwareTest/image-20191217132339566.png)
      
      *  基本路径集寻找算法
      
          1.  确认从入口到出口的最短基本路径
          2.  从入口到第一个未被先后评估为真和假两种结果的条件语句
          3.  改变该条件语句的赋值
          4.  重复步骤2-5直至所有基本路径都被找到
      
    * 循环测试
  
        * 嵌套循环
        *  先测试最内层循环
                *  按照简单循环测试
            *  由里向外，测试上层循环
                *  此层以外的所有外层循环变量取最小值
                *  此层以内所有嵌套内层循环变量取典型值
            *  重复上一条规则直至所有各层循环测试完毕
            *  对全部各层循环同时取最小循环次数或者同时取最大循环次数
        *  串接循环
            *  若串接循环的各个循环相互独立
                *  分别用简单循环测试
            *  若两个循环不独立
                *  把第一个循环看作外循环，第二个循环看作内循环，用测试嵌套循环的办法来处理
        *  非结构循环
            *  结构化再处理
  
  * 数据流测试
  
    *   数据流测试
    
        *   基本定义
    
            *   P——程序
    
            *   G(P)——程序图（流图）
    
            *   V——变量集合
    
            *   PATH(P)——P的所有路径集合
    
            *   DEF(v,n)——在节点n定义了变量v(变量**赋值**语句)
    
                *   e.g. input x; x = 2;
    
            *   USE(v,n)——在节点n使用了变量v
    
                *   e.g. print x; a = 2 + x;
    
            *   P-use——USE(v,n)，谓词使用，即条件判断语句中
    
                *   e.g. if b > 6
    
            *   C-use——USE(v,n)，运算使用，位于运算中
    
                *   e.g. x = 3 + b
    
                    >*   O-use——输出使用
                    >*   L-use——定位使用（数组）
                    >*   I-use——迭代使用（循环）
    
            *   du-path——定义-使用路径
                
                *   给定PATH(P)中的某条路径，如果定义节点DEF(v,m)为该路径的起始节点，使用节点USE(v,n)为该路径的终止节点，则该路径是v的一条du-path
            *   dc-path——定义-清除路径
            
                *   如果变量v的某个定义-使用路径，除起始节点外没有其他定义节点，则该变量路径是变量v的定义-清除路径
    
        *   数据流覆盖测试
        
            1.  对于给定的程序，构造相应的程序图
        2.  找出**所有变量**的**du-path**（可以约简）
            3.  考察测试用例对这些路径的覆盖程度
    
        *   常用覆盖标准
        
            *   Rapps和Weyuker标准
                *   All-Paths
                    *   路径覆盖
                *   All-Edges
                    *   分支覆盖
                *   All-Nodes
                    *   语句覆盖
                *   All-Defs
                    *   每个定义节点都有一条dc-path
                *   All-P-Use
                    *   每个定义节点都有一条dc-path
                *   All-P-Uses/some-C-Uses
                *   All-C-Uses/Some-P-Uses
                *   All-Users
                    *   每个变量的定义节点都有一条dc-path到达该变量的使用节点
                *   All-du-path
            *   Ntafos标准
            *   Ural标准
            *   Laski和Korel标准
## 白盒测试工具

  * 测试工具分类*
      * 静态分析工具
      * 动态分析工具
  * 测试工具的作用*
      * 提高代码效率
      * 降低测试成本
## 控制流覆盖的测试
  1. 短路问题
  2. 使用尽可能少的测试用例
  3. 测试用例要体现控制流覆盖的特点
  4. 对各个控制流覆盖标准有明确认识
       * 语句
       * 判定
       * 条件
       * 判定条件
       * 条件组合
       * 路径
  > 控制流覆盖不使用程序流图
## 基本路径测试
 1. 正确画出流程图，出自组合条件的判定
 2. 使用多种方法计算圈（环）复杂度
 3. 正确得出基本路径（顺序）
 4. 不是所有基本路径都能写出测试用例
## 数据流测试
 1. 不考虑数据流覆盖的各种标准
 2. 能够找出定义节点和使用节点
 3. 列举出所有可能的DU路径
 4. 进行DU路径约简
# 黑盒测试
  ## 黑盒测试基本概念
  * 定义*
      * 一种基于规格说明，不要求考察代码，以用户视角进行的测试
  * 意义*
      * 黑盒测试有助于软件产品的总体功能验证
          * 检查明确需求和隐含需求
          * 采用有效输入和无效输入
          * 包含用户视角
  * 目的
      * 有时无法获取程序代码
      * 尽早进行黑盒测试可以尽早发现软件功能缺陷
      * 弥补遗漏的逻辑缺陷
      * 适用于测试的各个阶段
          * 单元测试
          * 集成测试
          * 系统测试
          * 回归测试
  * 实施者
      * 专门的软件测试部门：有经验的测试人员
  * 步骤*
    1.  规格说明书
    2.  生成测试用例
    3.  执行测试
    4.  判定测试结果
  * 进入退出条件
  ## 黑盒测试方法基础
  * 基于需求的测试（RTM）*

      * 目的

          * 确认软件需求规格说明书列出的需求

      * 前提

          * 需求规格已经经过仔细评审
          * 隐含需求明确化

      * 需求规格说明样本

          * 需求规格说明

        | 序号 | 需求标识 | 需求描述 | 优先级 |
        | ---- | -------- | -------- | ------ |
        |      |          |          |        |

        *   需求跟踪矩阵样本

        | 需求标识 | 需求描述 | 优先级 | 测试条件 | 用例标识 | 测试阶段 |
        | -------- | -------- | ------ | -------- | -------- | -------- |
        |          |          |        |          |          |          |

        * 需求跟踪矩阵(RTM)
            * 作用
                * 可跟踪每个需求的测试状态而不会遗漏任何需求
                * 优先执行优先级高的测试用例，尽早发现高优先级区域内缺陷
                * 可导出特定需求对应的测试用例清单
                * 评估测试工作量和测试进度的重要数据
        * 测试执行数据样本

        | 序号 | 需求标识 | 优先级 | 测试用例 | 用例总数 | 通过用例 | 未通过用例 | 通过率 | 缺陷数 |
        | ---- | -------- | ------ | -------- | -------- | -------- | ---------- | ------ | ------ |
        |      |          |        |          |          |          |            |        |        |

        

    *   需求跟踪矩阵

        | 需求标识 | 需求描述 | 优先级 | 测试条件 | 用例标识 | 测试阶段 |
        | -------- | -------- | ------ | -------- | -------- | -------- |
        |          |          |        |          |          |          |

    *   作用

        *   可跟踪每个需求的测试状态而不会遗漏任何需求
        *   优先执行优先级高的测试用例，尽早发现高优先级区域内缺陷
        *   可导出特定需求对应的测试用例清单
        *   评估测试工作量和测试进度的重要数据

  * 正面测试*

      * 测试用例通过一组预期输出验证产品需求
      * 证明软件对于每条规格说明和期望都能通过

  * 负面测试*

      * 展示当输入非预期输入时产品没有失败
      * 使用产品没有设计和预想到的场景，尝试使系统垮掉
      * 负面测试不能映射到需求
  ## 黑盒测试方法
  * 等价划分

      * 原理
          * 将程序的输入域划分为数据类，以便导出测试用例
          * 他试图定义一个测试用例以发现各类错误，从而减少测试用例数目，降低测试工作量
      * 等价类（划分）
          * 如果软件行为对一组值来说是相同的，则称这组值为等价类
          * 产生同一个预期输出的一组输入值叫一个划分
          * 有效等价类
              * 完全满足产品规格说明的输入数据构成的集合
          * 无效等价类
              * 不满足程序输入要求或者无效的输入数据构成的集合
          * 划分类型
            1.  布尔表达式
                1.  一个有效等价类True
                2.  一个无效等价类False
            2.  范围
                1.  一个有效等价类，范围内
                2.  两个无效等价类，大于小于
            3.  数据个数
                1.  一个有效等价类，正确个数
                2.  两个无效等价类，大于小于
            4.  集合的某个子集
                1.  一个有效等价类，正确集合
                2.  若干无效等价类
            5.  一组列表形式的数据
                1.  多个有效等价类，每个输入数据为一个等价类
                2.  1个无效等价类
            6.  要求符合几个规则
                1.  多个有效等价类
                2.  若干无效等价类
        * 步骤
            1.  划分准则
            2.  确定有效等价类和无效等价类
            3.  从等价类中选取样本数据
            4.  根据需求写预期结果
            5.  加入特殊值
            6.  执行测试

  * 边界值分析

      * 软件的两个主要缺陷源

          * 条件
          * 边界

      * 边界值分析

        *   原因

            *   使用比较操作符时未仔细分析
            *   多种循环和条件检查方法引起的困惑
            *   对边界附近需求的理解不够

        *   测试边界

            *   第一个-1/最后一个+1
            *   开始-1/完成+1
            *   最小值-1/最大值+1

        *   界定边界值

            *   n存在边界值的参数个数
            *   m边界值条件个数

        *   Paul Jorgensen公式

            *   4n+1 基本边界测试

                *   min

                *   min+1

                *   max-1

                *   max

                *   一个典型值

                    ![image-20191218144428829](/Review/SoftwareTest/image-20191218144428829.png)

            *   6n+1 健壮性边界测试

                *   min-1

                *   min

                *   min+1

                *   max-1

                *   max

                *   max+1

                *   一个典型值

                    ![image-20191218144502989](/Review/SoftwareTest/image-20191218144502989.png)

            *   3m 边界条件测试

                *   self-1
                *   self
                *   self+1

  * 因果分析法

      * 因果图
      * （需求规格说明书）→生成因果列表→（起因结果列表）→建立决策表→（决策表）→生成测试用例
      * 表示
          * 原因 $C_i$
          * 结果 $E_i$
      * 因果4种关系
          * ![image-20191218150755091](/Review/SoftwareTest/image-20191218150755091.png)
          * ![image-20191218150807306](/Review/SoftwareTest/image-20191218150807306.png)
          * ![image-20191218150816443](/Review/SoftwareTest/image-20191218150816443.png)
          * ![image-20191218150830915](/Review/SoftwareTest/image-20191218150830915.png)
      * 输入约束4种
          * ![image-20191218150845677](/Review/SoftwareTest/image-20191218150845677.png)
          * ![image-20191218150858078](/Review/SoftwareTest/image-20191218150858078.png)
      * 输出约束1种
          * ![image-20191218151004965](/Review/SoftwareTest/image-20191218151004965.png)
      * 决策表

    | -                | 1    | 2    | 3    | 4    | ...  |
    | ---------------- | ---- | ---- | ---- | ---- | ---- |
    | 条件C1           |      |      |      |      |      |
    | 条件C2           |      |      |      |      |      |
    | 条件Cn           |      |      |      |      |      |
    | 行动A1           |      |      |      |      |      |
    | 行动A2           |      |      |      |      |      |
    | 行动An           |      |      |      |      |      |
    | 测试用例（输出） |      |      |      |      |      |

    * Step
        1.  分析规格说明书，识别原因和结果
        2.  在因果图之间连接原因和结果
        3.  表明原因之间以及结果之间的约束条件
        4.  因果图转换为因果图列表进而生成决策表
        5.  决策表的规则转换为测试用例

* 决策表

    * 组成

        * 条件桩

            * 列出所有可能问题

        * 条件项

            * 解除条件所有可能取值

        * 动作桩

            * 列出可能采取的操作

        * 动作项

            * 在条件项的各种取值情况下应采取的动作

        * 决策规则，贯穿条件项和动作项的一列

            ![image-20191218152030382](/Review/SoftwareTest/image-20191218152030382.png)

        *   构造决策表
            1.  列出所有的条件桩和条件项
            2.  填入条件项
            3.  填入动作项，得到初始决策表
            4.  简化决策表，合并相似规则
        *   化简
            
        *   合并相似规则
  
* 基于模型的测试*
  
      * 原理
        * 软件执行过程可分解为若干对象和连接对象之间的关系
          * 测试序列可视为验证对象间所期望的关系是否满足
        
      * 适用领域
        * 有限状态建模
          * 工作流建模
        * 数据流建模
          * 时间建模
    * 模型化软件
      
  
* 正交数组测试

  * 利用真叫测试再加上特殊用例测试，基本上可以均匀分散地覆盖到各种情况，又能大大减少测试用例个数

  * 正交表

    * 构成

      * 因子：输入参数
      * 水平：输入取值
      * 因子数：正交表中列的个数
      * 水平数：单个因子的取值个数
      * 行数：正交表行数
      * 记法：$L{行数}(水平数^{因子数})$

    * 正交表的正交性

      * 整齐可比
        * 每个因子的每个水平出现的次数完全相同
      * 均匀分散
        * 任意两列的水平搭配是完全相同的

      ![image-20191220111527013](/Review/SoftwareTest/image-20191220111527013.png)

      *   e.g.

          *   $L4(2^3)$

              |      | 1    | 2    | 3    |
              | ---- | ---- | ---- | ---- |
              | 1    | 1    | 1    | 1    |
              | 2    | 1    | 2    | 2    |
              | 3    | 2    | 1    | 2    |
              | 4    | 2    | 2    | 1    |

  * Step

    1.  确定因子和水平
    2.  判断是否能使用正交数组（因子少于2则不适用）
    3.  选择合适的正交表
    4.  把变量值映射到表中
    5.  正交测试用例制作
    6.  补充测试用例

  * 正交表选择

    * 正交表因子个数≥实际因子数
    * 正交表每个因子书的水平个数≥实际每个因子数的水平个数
    * 正交表的行数
      * 选择最少的正交表
  * 把变量值映射到表中
    * 正交测试用例制作
    * 补充测试用例
    
    

* 蜕变测试

* 随机测试

  ## 黑盒测试工具
  * 测试工具原理
      * 以GUI自动化测试工具为例
          * 运行北侧软件的同时，捕获过程中的键鼠操作，生成脚本文件，这个脚本文件可以被修改和回放
  * 作用

## 等价划分和边界值分析

1. 等价类划分一定要考虑全面，分为有效等价类和 无效等价类，并统一编号
2. 写测试用例时，每个等价类至少有一个测试用例
3. 边界值分析可考虑边界值和条件值
4. 边界值要考虑需求的限制、数据类型的限制、系统的限制等多种限制条件

## 因果图和决策表

1. 能够列出原因和结果列表
2. 因果图的画法
3. 根据因果图得出因果列表，进一步得出决策表
4. 决策表约简

# 单元测试和集成测试

## 软件测试

* 基本概念*
  * 软件单元
      * 一个应用程序中的最小可测部分
  * 定义
      * 单元测试
          * 对最小的软件设计单元的验证工作
      * 模块测试
          * 对最小的软件设计模块的验证工作
  * 意义
      * 消除软件单元本身的不确定性
      * 其他测试阶段的必要的基础环节
  * 目标
      * 单元体现了预期的功能
      * 单元的运行能够覆盖预先设定的各种逻辑
      * 单元工作中：内部数据能够保持完整性
      * 可以接受正确数据，也能处理非法数据
      * 在数据边界上，单元能正常工作
      * 单元算法合理，性能良好
      * 扫描单元代码没有发现任何安全性问题
      * etc
  * 实施者
      * 软件开发人员
  * 关注点
      * 模块功能
      * 内部逻辑处理
      * 数据结构
      * 性能
      * 安全
* 单元测试流程
  * 技术和步骤
    * 先设计测试用例，然后执行测试
    * 进入条件
      * 编码开始：设计测试数据并执行测试
    * 退出条件
      * 完成测试计划
      * 发现并修正错误
      * 预算和开发时间
  * 模块或构件接口
    * 目标
      * 进出模块/构件的数据流正确
    * 关注点
      * 接口名称、参数个数、类型、顺序的匹配
      * 输出或返回值的及其类型是否正确
  * 局部数据结构
    * 目标
      * 数据在模块执行中都维持完整性和正确性
    * 关注点
      * 局部数据定义和使用过程的正确性
      * 局部数据结构对全局数据机构的影响
  * 边界条件
    * 目标
      * 保证模块在边界条件上能够正确执行
    * 关注点
      * 数据机构中的边界
      * 控制流中的边界
  * 独立路径
    * 目标
      * 保证模块中的每条独立（基本）路径都要走一遍，使得所有语句都被执行过一次
    * 关注点
      * 对路径的选择性测试（基本路径测试+循环测试）
  * 处理错误的路径
    * 保证错误处理的正确性，软件的健壮性
* 驱动器和程序桩
  * 驱动器
    * 对底层或子层模块进行测试时所编制的调用被测模块的程序，用以模拟被测模块的上级模块。
  * 程序桩
    * 对上层模块进行测试时，所编制的替代下层模块的程序，用以模拟被测模块工作过程中所调用的模块。
  * 高内聚低耦合可以让驱动器和测试桩编写更加简单并已于发现错误

## 集成测试

* 概念*
  * 把单独的软件模块结合在一起作为整体接受测试
* 接口*
  * 内部接口
  * 外部接口
  * 接口提供方法
    * API
    * SDK
  * 桩程序
* 实施者
  * 软件测试人员
  * 软件开发人员
* 瞬时集成测试
  * 当所有构建都通过单元测试，就把他们组合成一个最终系统，并观察它能够正常运转
  * 缺陷
    * 无休止的错误，修复困难
    * 一次性结合，难以找出错误原因
    * 容易和其他错误混淆
* 增量集成测试
  * 特点
    * 将程序分成小的部分进行构造和测试
  * 优点
    * 错误容易分离和修正
    * 接口容易彻底测试
  * 缺点
    * 会有额外开销
  * 自顶向下
    * 深度优先
    * 广度优先
    * 优点
      * 尽早发现高层控制和决策错误
      * 最多只需要一个驱动器
      * 每步只增加一个模块
    * 缺点
      * 对底层模块的行为验证比较晚
      * 需要编写额外程序模拟未测试的模块
      * 部分测试用例由于依赖其他层次的模块，在该模块未测试之前，这些测试用例的输入输出很难确定
  * 自底向上
    * 从原子模块构造并集成测试
    * 优点
      * 尽早确认底层行为
      * 无需编写程序桩
      * 对实现特定功能的树容易表示输入输出
    * 缺点
      * 推迟确认高层行为
      * 需编写驱动器
      * 组合子树时，有许多元素要集成
  * 混合式集成
    * 综合

## 测试插装

* 黑盒插装*
  * 随机数据生成器（随机测试）
  * 作用
    * 避免只测试所知道的将奏效的场景
* 白盒插装*
  * 语句覆盖插桩
  * 分支覆盖插桩
  * 条件覆盖插桩
  * 插桩
    * 生成特定状态，检验状态的可达性
    * 显示或读取内部数据的私有数据
    * 检测不变数据
    * 检测前提条件
    * 人为触发事件时间
    * 检测事件时间

# 系统测试、确认测试和回归测试

## 系统测试

* 概念
  * 定义
    * 对完整集成后的产品和解决方案的测试，用来评价系统对具体需求规格说明的**功能**和**非功能**的符合性的测试
  * 意义（特点）
    * 既是测试产品功能也是测试产品非功能的唯一测试阶段
  * 目的
    1. 发现可能难以直接与模块或接口关联的缺陷
    2. 发现产品设计、体系和代码的基础问题（产品级缺陷）
  * 实施者
    * 独立测试团队（引入独立视角，有助于发现遗漏缺陷）
  * 引入时机
    * 集成测试之后（基础的程序逻辑错误和缺陷已更正后）
  * 实施原因
    1. 在测试中引入独立视角
    2. 在测试中引入客户视角
    3. 在测试用模拟用户的使用环境
    4. 测试产品功能和非功能的问题
    5. 建立对产品的信心
    6. 分析和降低产品发布的风险
    7. 保证满足所有需求，产品具备交付确认测试条件
  
* 功能测试
  * 设计/体系结构测试
  
    * 原理
  
      * 对照设计和体系结构开发和测试用例，从而整理出产品级测试用例
      * 集成测试用例关注模块或组件间交互，而系统功能测试用例关注整个产品的行为
  
    * 方法
  
      * 体系结构静态测试
  
        * 体系结构分析
        * 对体系机构的特征进行建模、分析
          * e.g.
            * 对类定义的一致性分析
  
      * 体系结构的动态测试
  
        | 测试用例特征                               | 建议              |
        | ------------------------------------------ | ----------------- |
        | 测试用例关注代码逻辑、数据结构和产品单元   | 单元测试          |
        | 测试用例关注组件接口                       | 集成测试          |
        | 测试用例关注的是不能为用户所看到的产品实现 | 单元测试\集成测试 |
        | 测试用例综合了客户使用和产品实现           | 系统测试          |
  
  * 业务垂直测试
  
    * 原理
  
      * 针对不同业务纵深的产品，根据业务定制测试用例，验证业务运作和使用
  
    * 应用范围
  
      * 通用的工作流自动化系统在不同商业领域的应用
  
    * 方法
  
      * 模拟
  
        * 测试需求和业务流
  
      * 复制
  
        * 获取客户数据流和过程，针对特殊业务进行定制
  
          > 定制：改变系统的一般工作流，以适用于不同业务纵深
          >
          > 术语：尽量使用各个业务领域的专属名词
  
  * 部署测试
  
    * 验证系统能够满足客户的部署需求
    * 目的
      * 特定产品版本短期内是否能够成功使用
    * 离场部署
      * 在产品开发组织内运行，以确保客户部署需求的（模拟）部署测试
    * 现场部署（离场部署的扩展）
      * 现场部署是指在客户场地中的资源和环境都发布后，实施的一种部署方案
        1. 采集系统的采集系统真实数据，建立镜像测试环境，重新执行用户操作
        2. 引入新产品，进行新业务操作，同实对比事务处理情况，以确定新系统能否能够替代老系统
  
  * Alpha/Beta测试
  
    * Alpha测试
      * 用户在开发环境下进行的受控测试
      * 特点
        * 不由程序员或测试员完成，但开发者会在现场
    * 在Alpha测试达到一定程度后进行Beta测试
    * Beta测试
      * 用户在实际使用环境下进行测试，一种可以把待测产品交给客户收集反馈意见的机制
      * 特点
        * 开发者通常不在现场
      * 挑战
        * 客户数量
          * 客户充分了解产品
  
  * 符合性的认证、标准和测试
  
    * 产品需要通过主流硬件、操作系统、数据库和其他基础设施构建上进行的验证，并符合相关法规和行规
    * 主流基础设施
      * 操作系统
      * 硬件
      * 数据库
      * etc
    * 约定和法律要求
      * 质量行业标准
      * 法规
      * 技术领域标准
  
* 非功能测试
  
  * 非功能测试用于验证系统的质量因素
    * 理解产品行为、设计体系和体系结构
    * 针对不同配置和资源对产品进行测试
    * 手机和分析响应数据
    * 评判产品质量
  * 非功能测试的最大挑战：设置配置
  * 原因
    * 难以预测用户的使用环境
    * 对配置进行组合测试的代价太高
    * 建立测试环境成本高
    * 很难准确预测客户使用的数据
  * 配置环境
    * 模拟环境
    * 真实客户环境
  * 可伸缩性测试/容量测试
  * 可靠性测试
  * 压力测试
  * 互操作性测试/兼容性测试
  * 可使用性与易获得性测试
  * 国际化测试
  * 性能测试
  * 安全性测试

## 确认测试

* 概念*
  * 定义
    * 检查产品是满足在项目的需求阶段定义的确认规则，或者说是否具备在真实环境中使用的条件
  * 引入时机
    * 系统测试之后
  * 测试用例
    * 测试用例数量较少，目的不是为了发现缺陷
  * 测试环境
    * 近似实际场景下进行
* 实施者
  * 客户或客户代表
* 目的*
  * 验证和接受产品
* 产品确认
  * 对现有测试用例进行分类形成确认准则
* 规程确认
  * 根据交付规程进行定义
* 确认准则
  * 服务约定等级
* 执行
  * 开发组织
    * 辅助客户完成确认测试
  * 确认测试团队
    * 产品管理层+支持团队+咨询团队
      * 90%成员具有产品业务过程知识
      * 10%成员属于技术测试团队
  * 开发组织的测试团队应当与确认测试团队不断沟通，提供采集测试数据和分析测试结果的帮助

## 回归测试

* 概念*
  1. 回归测试是对之前已修改过、经过修改的程序进行的重新测试，以保证该修改没有引入新的错误或者由于更改而发现之前未发现的错误
  2. 回归测试要保证增强型或改正型修改使软件正常进行并且不影响已有的功能
* 意义
  * 保证软件维护时未更改的代码功能不会收到影响
  * 保证软件模块区域和持续维护过程与回归测试的协作关系，是回归测试成为一个每月/每周/每日的常规活动
  * 实现软件整个生命周期的测试
* 引入时机
  * 单元测试
  * 集成测试
  * 系统测试
  * 引入原则
    * 开发过程中发生修改或维护，就有必要进行回归测试
* 特点
  1. 测试计划
     1. 常规测试
        * 已有的带有测试用例的测试计划
     2. 回归测试
        * 更改的规格说明书、修改过的程序和需要更新的旧测试计划
  2. 测试范围
     1. 常规测试
        * 整个程序
     2. 回归测试
        * 被修改部分的正确性以及它与原有功能的整合
  3. 时间分配
     1. 常规测试
        * 测试时间实现有预算
     2. 回归测试
        1. 测试时间不包含在进度表中
  4. 开发信息
     1. 常规测试
        * 随时可获得开发信息
     2. 回归测试
        * 只需保留开发信息保证回归测试正确
  5. 完成时间
     1. 常规测试
        * 所需时间长
     2. 回归测试
        1. 只需测试软件的一部分，测试时间短
  6. 执行频率
     1. 常规测试
        * 高频率的活动
     2. 回归测试
        * 由系统被修改而触发的周期性活动、
* 过程
  1. 提出软件测试修改需求
  2. 进行软件修改
  3. 选择测试用例（选择正确的测试用例集）
  4. 执行测试
  5. 识别失败结果
  6. 识别错误
  7. 排除错误
* 策略
  * 全部重新测试
    * 不用进行测试用例选择
  * 有选择地重新测试
    * 灵活、适用于测试用例较多的情形
* 重新确认测试用例
* 组测试*
  * 多模块集成工作差错
* 波及效应
  *  保证软件修改后仍然保持一致性与完整性
  * 需求的波及效应
  * 设计的波及效应
  * 代码的波及效应
  * 测试用例的波及效应
  * 步骤
    1. 开始
    2. 实施初始修改
    3. 识别收到潜在影响的区域
    4. 需要进一步修改一保持一致性？
       * y: 
         * 决定如何修改
         * go to 1
       * n:
         * continue
    5. 结束

