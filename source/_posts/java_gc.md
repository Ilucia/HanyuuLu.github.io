---
title: Java GC 机制备忘
date: 2020-03-26 12:00:00
tags:
	- Java
	- GC
categories:
	- Review
---

# GC

>  垃圾回收(Garbage Collection)是Java虚拟机(JVM)垃圾回收器提供的一种用于在空闲时间不定时回收无任何对象引用的对象占据的内存空间的一种机制。
>
> 垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身。换言之，垃圾回收只会负责释放那些对象占有的内存。对象是个抽象的词，包括引用和其占据的内存空间。当对象没有任何引用时其占据的内存空间随即被收回备用，此时对象也就被销毁。

## 对象引用

1. 强引用

2. 软引用

   SoftReference:内存不够时被回收

3. 弱引用

   WeakReference:下一次GC时被回收

   > ReferenceQuene

4. 虚引用

   PhantomReference:目的是在被GC时获得通知

# 垃圾回收算法

>* 找到所有存活对象
>* 回收被无用对象占用的内存空间

## 判断对象是否是垃圾

### 引用计数 (Reference Counting Collector)

* 堆中的每个对象都有引用计数器
* 当对象被创建并被初始化赋值后，计数设置为1
* 每多一个引用计数，加一，引用失效（超过生命周期，被设置了一个新值），减一
* 回收所有引用计数为0的对象，并对其引用的所有对象计数减一
* 优点
  * 简单高效
  * 对程序不被长时间打断的实时环境比较有利
* 缺点
  * 难以检测循环引用
  * 增加程序执行开销
* JVM
  * 早期JVM使用引用计数
  * 目前大多数JVM使用对象引用遍历（根搜索算法）

### 根搜索算法 (Tracing Collector)

> * 根集 (Root Set)
>
>   ​	正在执行的Java程序可以访问的引用变量(不是对象)的集合（包括局部变量、参数和类变量）
>
>   ​	程序可以使用引用变量访问对象的属性和调用对象的方法

* 通过一系列名为“GC Roots”的对象作为起始点，寻找对应的引用节点
* 递归从这些引用节点向下寻找引用节点
* 生成的链称为引用链，当一个对象没有被任何引用链上的引用节点引用时，证明对象不可用

* Java和C#目前采用Tracing Collector方法

## 标记可达对象

![img](/java_gc/3789193-db98b5d3a266c24d.png)

* GC Root
  * 虚拟机栈中引用的对象（栈帧中的本地变量表）
  * 方法区中的常量引用的对象
  * 方法区中的类静态属性引用的对象
  * 本地方法栈中JNI (Native方法) 的引用对象
  * 活跃线程
* 标记步骤
  * 以GC Root对象开始，对内存中整个对象图进行遍历并标记所有访问到的对象为存活
  * 未被标记的对象将在后面被清除

> 1. 开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便JVM可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point），这会触发一次Stop The World(STW)暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。
>
> 2. 暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。因此，调高堆的大小并不会影响到标记阶段的时间长短。
>
> 3. 在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程
>    1. 如果对象在进行根搜索后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize()方法。当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。
>    2. 如果该对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize()方法。finalize()方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize()方法最多只会被系统自动调用一次），稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize()方法中成功拯救自己，只要在finalize()方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。
> 4. GC判断对象是否可达看的是强引用。

## 回收垃圾对象内存算法

### 标记-清除算法(Tracing Collector)

* 优点
  * 不需要进行对象移动
  * 仅仅对不存活的对象进行处理
* 缺点
  * 标记和清除过程的效率都不高，占用额外空间以用于标记空闲区域和大小
  * 会产生大量不连续的内存碎片

![img](/java_gc/3789193-acd959b5e0a6d46d.png)

![img](/java_gc/3789193-05ac8d99f632c6c7.png)

# Reference

* [浅谈Java的垃圾回收机制（GC）](https://www.jianshu.com/p/5261a62e4d29)