{"title":"OpenCV basic operations","date":"2018-10-02T00:00:00.000Z","link":"OpenCV/OpenCVBasicOperations","tags":["OpenCV"],"updated":"2022-04-27T15:24:01.559Z","content":"<h2 id=\"1accessing-and-modifying-pixel-values\"><a class=\"markdownIt-Anchor\" href=\"OpenCV/OpenCVBasicOperations#1accessing-and-modifying-pixel-values\"></a> 1.Accessing and Modifying pixel values<a href=\"OpenCV/OpenCVBasicOperations#1accessing-and-modifying-pixel-values\"></a></h2>\n<hr>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> numpy <span class=\"keyword\">as</span> np</span><br><span class=\"line\"><span class=\"comment\"># Load a color image.</span></span><br><span class=\"line\">img = cv2.imread(<span class=\"string\">'example.jpg'</span>)</span><br><span class=\"line\">px = img[<span class=\"number\">100</span>,<span class=\"number\">100</span>]</span><br><span class=\"line\">print(px)</span><br><span class=\"line\"><span class=\"comment\"># accessing only blue pixel</span></span><br><span class=\"line\"><span class=\"comment\"># BGR color system!</span></span><br><span class=\"line\">blue = img[<span class=\"number\">100</span>,<span class=\"number\">100</span>,<span class=\"number\">0</span>]</span><br><span class=\"line\">print(blue)</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>You can access a pixel value by its row and column coordinates. For BGR image, it returns an array of Blue, Green, Red values. For grayscale image, just corresponding intensity is returned.</li>\n<li>You can modify the pixel values the same way.</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">img[<span class=\"number\">100</span>,<span class=\"number\">100</span>]=[<span class=\"number\">255</span>,<span class=\"number\">255</span>,<span class=\"number\">255</span>]</span><br><span class=\"line\">print(img[<span class=\"number\">100</span>,<span class=\"number\">100</span>])</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>Numpy is a optimized library for fast array calculations. So simply accessing each and every pixel values and modifying it will be very slow and it is discouraged.</li>\n<li>Above mentioned method is normally used for selecting a region of array, say first 5 rows and last 3 columns like that. For individual pixel access, Numpy array methods, <figure class=\"highlight\"><figcaption><span>and ```array.itemset()``` is considered to be better. But it always returns a scalar. So if you want to access all **B,G,R values**, you need to call ```array.item()``` separately for all.</span></figcaption><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* example:</span><br><span class=\"line\"> ```py</span><br><span class=\"line\"># accessing RED value</span><br><span class=\"line\">img.item(10,10,2)</span><br><span class=\"line\"></span><br><span class=\"line\"># modifying RED value</span><br><span class=\"line\">img.itemset((10,10,2),100)</span><br><span class=\"line\">img.item(10,10,2)</span><br></pre></td></tr></table></div></figure></li>\n</ul>\n<h2 id=\"2-accessing-image-properties\"><a class=\"markdownIt-Anchor\" href=\"OpenCV/OpenCVBasicOperations#2-accessing-image-properties\"></a> 2. Accessing Image Properties<a href=\"OpenCV/OpenCVBasicOperations#2-accessing-image-properties\"></a></h2>\n<ul>\n<li>img.shape</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(img.shape)</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>Image properties include number of rows, columns and channels, type of image data, number of pixels etc.\\</li>\n<li>Shape of image is accessed by img.shape. It returns a tuple of number of rows, columns and channels (if image is color).\\</li>\n<li>If image is grayscale, tuple returned contains only number of rows and columns. So it is a good method to check if loaded image is grayscale or color image.</li>\n<li>img.size</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(img.size)</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>\n<p>Total number of pixels is accessed by <figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* img.dtype</span><br><span class=\"line\">``` py</span><br><span class=\"line\">print(img.dtype)</span><br></pre></td></tr></table></div></figure></p>\n</li>\n<li>\n<figure class=\"highlight\"><figcaption><span>is very important while debugging because a large number of errors in OpenCV-Python code is caused by invalid datatype.</span></figcaption><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 3. Image ROI</span><br><span class=\"line\">* Sometimes, you will have to play with certain region of images. For eye detection in images, first perform face detection over the image until the face is found, then search within the face region for eyes. This approach improves accuracy (because eyes are always on faces :D ) and performance (because we search for a small area).</span><br><span class=\"line\">* ROI is again obtained using Numpy indexing.</span><br><span class=\"line\">``` py</span><br><span class=\"line\">clip = img[280:340, 330:390]</span><br><span class=\"line\">img[273:333, 100:160] = clip</span><br></pre></td></tr></table></div></figure>\n</li>\n</ul>\n<h2 id=\"4splitting-and-merging-image-channels\"><a class=\"markdownIt-Anchor\" href=\"OpenCV/OpenCVBasicOperations#4splitting-and-merging-image-channels\"></a> 4.Splitting and Merging Image Channels<a href=\"OpenCV/OpenCVBasicOperations#4splitting-and-merging-image-channels\"></a></h2>\n<p>The B,G,R channels of an image can be split into their individual planes when needed. Then, the individual channels can be merged back together to form a BGR image again. This can be performed by:</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b,g,r = cv2.split(img)</span><br><span class=\"line\">img = cv2.merge((b,g,r))</span><br></pre></td></tr></table></div></figure>\n<p>Or</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b = img[:,:,<span class=\"number\">0</span>]</span><br></pre></td></tr></table></div></figure>\n<p>Suppose, you want to make all the red pixels to zero, you need not split like this and put it equal to zero. You can simply use Numpy indexing which is faster.</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># BRG color system</span></span><br><span class=\"line\">img[:,:,<span class=\"number\">2</span>] = <span class=\"number\">0</span></span><br></pre></td></tr></table></div></figure>\n<p>*<figure class=\"highlight\"><figcaption><span>is a costly operation (in terms of time), so only use it if necessary. Numpy indexing is much more efficient and should be used if possible.*</span></figcaption><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 5.Making Borders for Images (Padding)</span><br><span class=\"line\"></span><br><span class=\"line\">If you want to create a border around the image, something like a photo frame, you can use ```cv2.copyMakeBorder()``` function. But it has more applications for convolution operation, zero padding etc. This function takes following arguments:</span><br><span class=\"line\">* **src** - input image</span><br><span class=\"line\">* **top, bottom, left, right** - border width in number of pixels in corresponding directions</span><br><span class=\"line\">* **borderType - Flag defining what kind of border to be added. It can be following types:**</span><br><span class=\"line\">   * **cv2.BORDER_CONSTANT** - Adds a constant colored border. The value should be given as next argument.</span><br><span class=\"line\">   * **cv2.BORDER_REFLECT** - Border will be mirror reflection of the border elements, like this : fedcba|abcdefgh|hgfedcb</span><br><span class=\"line\">   * **cv2.BORDER_REFLECT_101** or **cv2.BORDER_DEFAULT** - Same as above, but with a slight change, like this : gfedcb|abcdefgh|gfedcba</span><br><span class=\"line\">   * **cv2.BORDER_REPLICATE** - Last element is replicated throughout, like this: aaaaaa|abcdefgh|hhhhhhh</span><br><span class=\"line\">   * **cv2.BORDER_WRAP** - Can’t explain, it will look like this : cdefgh|abcdefgh|abcdefg</span><br><span class=\"line\">* value - Color of border if border type is cv2.BORDER_CONSTANT</span><br><span class=\"line\"></span><br><span class=\"line\">Below is a sample code demonstrating all these border types for better understanding:</span><br><span class=\"line\">``` py</span><br><span class=\"line\">import cv2</span><br><span class=\"line\">import numpy as np</span><br><span class=\"line\">from matplotlib import pyplot as plt</span><br><span class=\"line\"></span><br><span class=\"line\">BLUE = [255,0,0]</span><br><span class=\"line\"></span><br><span class=\"line\">img1 = cv2.imread(&apos;opencv_logo.png&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">replicate = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_REPLICATE)</span><br><span class=\"line\">reflect = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_REFLECT)</span><br><span class=\"line\">reflect101 = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_REFLECT_101)</span><br><span class=\"line\">wrap = cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_WRAP)</span><br><span class=\"line\">constant= cv2.copyMakeBorder(img1,10,10,10,10,cv2.BORDER_CONSTANT,value=BLUE)</span><br><span class=\"line\"></span><br><span class=\"line\">plt.subplot(231),plt.imshow(img1,&apos;gray&apos;),plt.title(&apos;ORIGINAL&apos;)</span><br><span class=\"line\">plt.subplot(232),plt.imshow(replicate,&apos;gray&apos;),plt.title(&apos;REPLICATE&apos;)</span><br><span class=\"line\">plt.subplot(233),plt.imshow(reflect,&apos;gray&apos;),plt.title(&apos;REFLECT&apos;)</span><br><span class=\"line\">plt.subplot(234),plt.imshow(reflect101,&apos;gray&apos;),plt.title(&apos;REFLECT_101&apos;)</span><br><span class=\"line\">plt.subplot(235),plt.imshow(wrap,&apos;gray&apos;),plt.title(&apos;WRAP&apos;)</span><br><span class=\"line\">plt.subplot(236),plt.imshow(constant,&apos;gray&apos;),plt.title(&apos;CONSTANT&apos;)</span><br></pre></td></tr></table></div></figure></p>\n<p>See the result below. (Image is displayed with matplotlib. So RED and BLUE planes will be interchanged):<img src=\"https://opencv-python-tutroals.readthedocs.io/en/latest/_images/border.jpg\" alt=\"\"></p>\n\n<hr>\n<h2 id=\"example\"><a class=\"markdownIt-Anchor\" href=\"OpenCV/OpenCVBasicOperations#example\"></a> Example<a href=\"OpenCV/OpenCVBasicOperations#example\"></a></h2>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"></span><br><span class=\"line\">img = cv2.imread(<span class=\"string\">'example.jpg'</span>)</span><br><span class=\"line\">print(<span class=\"string\">'img[300,300]=%s'</span> % img[<span class=\"number\">300</span>,<span class=\"number\">300</span>])</span><br><span class=\"line\">print(<span class=\"string\">'blue pixel %s'</span> %img[<span class=\"number\">300</span>,<span class=\"number\">300</span>,<span class=\"number\">0</span>])</span><br><span class=\"line\">print(<span class=\"string\">'green pixel %s'</span> %img[<span class=\"number\">300</span>,<span class=\"number\">300</span>,<span class=\"number\">1</span>])</span><br><span class=\"line\">print(<span class=\"string\">'red pixel %s'</span> %img[<span class=\"number\">300</span>,<span class=\"number\">300</span>,<span class=\"number\">2</span>])</span><br><span class=\"line\">print(img[<span class=\"number\">300</span>,<span class=\"number\">300</span>,<span class=\"number\">3</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">cv2.imshow(<span class=\"string\">'img'</span>, img)</span><br><span class=\"line\">k = cv2.waitKey(<span class=\"number\">0</span>)  <span class=\"comment\"># &amp; 0xff</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> k == <span class=\"number\">27</span>:  <span class=\"comment\"># ESC</span></span><br><span class=\"line\">\tcv2.destroyAllWindows()</span><br><span class=\"line\"><span class=\"keyword\">elif</span> k == ord(<span class=\"string\">'s'</span>):</span><br><span class=\"line\">\tcv2.imwrite(<span class=\"string\">'Save.jpg'</span>, img)</span><br></pre></td></tr></table></div></figure>","prev":{"title":"清除windows更新缓存","link":"Others/windowsUpdateCacheClear"},"next":{"title":"OpenCV function reference","link":"OpenCV/OpenCVFunctionRef"},"plink":"ilucia.github.io/OpenCV/OpenCVBasicOperations/","toc":[{"title":"<a class=\"markdownIt-Anchor\"></a> 1.Accessing and Modifying pixel values","id":"1accessing-and-modifying-pixel-values","index":"1"},{"title":"<a class=\"markdownIt-Anchor\"></a> 2. Accessing Image Properties","id":"2-accessing-image-properties","index":"2"},{"title":"<a class=\"markdownIt-Anchor\"></a> 4.Splitting and Merging Image Channels","id":"4splitting-and-merging-image-channels","index":"3"},{"title":"<a class=\"markdownIt-Anchor\"></a> Example","id":"example","index":"4"}],"copyright":{"author":"Ilucia Niu","license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\">知识共享署名 4.0 国际许可协议</a>","published":"2018年10月2日","updated":"2022年4月27日"}}