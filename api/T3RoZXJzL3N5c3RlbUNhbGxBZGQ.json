{"title":"systemCall添加自定义项目","date":"2019-03-18T18:14:00.000Z","link":"Others/systemCallAdd","updated":"2022-04-27T15:24:01.579Z","content":"<blockquote>\n<p>p.s:因为这个md解析器有些调皮……所以可能偷偷改了一些样式导致阅读障碍…… <br>\n如果遇到了请<a href=\"mailto:Furude_Hanyuu@outlook.com\" target=\"_blank\" rel=\"noopener\">帮助我</a>改正这些错误，谢谢。</p>\n</blockquote>\n<h2 id=\"一基本信息\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#一基本信息\"></a> 一，基本信息<a href=\"Others/systemCallAdd#一基本信息\"></a></h2>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>实验题目</th>\n<th>向 Linux 内核增加一个系统调用</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>完成人姓名</td>\n<td>Hanyuu Furude</td>\n</tr>\n<tr>\n<td>学号</td>\n<td>你猜( ﹁ ﹁ ) ~→</td>\n</tr>\n<tr>\n<td>报告日期</td>\n<td>2019/03/18</td>\n</tr>\n</tbody>\n</table></div></div>\n<h2 id=\"二实验目的\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#二实验目的\"></a> 二，实验目的<a href=\"Others/systemCallAdd#二实验目的\"></a></h2>\n<p>通过实验，熟悉 Linux 操作系统的使用，掌握构建与启动 Linux 内核的方法；<br>\n掌握用户程序如何利用系统调用与操作系统内核实现通信的方法，加深对系统调<br>\n用机制的理解；进一步掌握如何向操作系统内核增加新的系统调用的方法，以扩 展操作系统的功能。</p>\n<h2 id=\"三实验内容\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#三实验内容\"></a> 三，实验内容<a href=\"Others/systemCallAdd#三实验内容\"></a></h2>\n<ol>\n<li>\n<p>Linux 环境下的 C 或 C++编译和调试工具的使用。</p>\n</li>\n<li>\n<p>向 Linux 内核增加新的系统调用，系统调用名称和功能自行定义，但必须 实现如下输出功能：“My Student No. is ×××，and My Name is ×××”。</p>\n</li>\n<li>\n<p>Linux 新内核的编译、安装和配置。 4. 编写应用程序以测试新的系统调用并输出测试结果。</p>\n</li>\n</ol>\n<h2 id=\"四实验步骤\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#四实验步骤\"></a> 四，实验步骤<a href=\"Others/systemCallAdd#四实验步骤\"></a></h2>\n<h3 id=\"思路\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#思路\"></a> 思路<a href=\"Others/systemCallAdd#思路\"></a></h3>\n<p>在计算中，系统调用是计算机程序从其执行的操作系统内核请求服务的编程方式。这可能包括与硬件相关的服务（例如，访问硬盘驱动器）、新进程的创建和执行以及与集成内核服务（如进程调度）的通信。系统调用提供了进程和操作系统之间的基本接口。</p>\n<p>除了一些嵌入式系统之外，大多数现代处理器的体系结构都涉及到一个安全模型。例如，环模型规定了软件可以在多个特权级别下执行：一个程序通常被限制在它自己的地址空间，这样它就不能访问或修改其他正在运行的程序或操作系统本身，并且通常被阻止直接操作硬件设备（如帧缓冲区或网络）设备）。</p>\n<p>通常，系统提供一个库或API，位于正常程序和操作系统之间。在类Unix系统上，该API通常是C库（libc）实现（如glibc）的一部分，glibc为系统调用提供包装函数，通常与它们调用的系统调用命名相同。在Windows NT上，该API是nt dll.dll库中本机API的一部分；这是常规Windows API的实现所使用的未经记录的API，并且直接由Windows上的某些系统程序使用。库的包装函数公开了使用系统调用的普通函数调用约定（程序集级别的子例程调用），并使系统调用更模块化。这里，包装器的主要功能是将要传递给系统调用的所有参数放在适当的处理器寄存器中（也可能放在调用堆栈上），并为内核设置一个唯一的系统调用号。这样，在操作系统和应用程序之间存在的库就增加了可移植性。</p>\n<h2 id=\"步骤\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#步骤\"></a> 步骤<a href=\"Others/systemCallAdd#步骤\"></a></h2>\n<h3 id=\"系统版本\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#系统版本\"></a> 系统版本<a href=\"Others/systemCallAdd#系统版本\"></a></h3>\n<p>deepin-15.9-amd64</p>\n<h3 id=\"原内核版本\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#原内核版本\"></a> 原内核版本<a href=\"Others/systemCallAdd#原内核版本\"></a></h3>\n<p>4.15.0-29deepin-generic</p>\n<p><img src=\"/Others/systemCallAdd/1552918656107.png\" alt=\"1552918656107\" class=\"article-img\"></p>\n<h3 id=\"后内核版本\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#后内核版本\"></a> 后内核版本<a href=\"Others/systemCallAdd#后内核版本\"></a></h3>\n<p>4.19.29</p>\n<p><img src=\"/Others/systemCallAdd/1552919437700.png\" alt=\"1552919437700\" class=\"article-img\"></p>\n<h3 id=\"具体步骤\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#具体步骤\"></a> 具体步骤<a href=\"Others/systemCallAdd#具体步骤\"></a></h3>\n<ol>\n<li><a href=\"https://www.kernel.org/\" target=\"_blank\" rel=\"noopener\">下载</a>Linux<a href=\"https://cdn.kernel.org/pub/linux/kernel/v4.x/linux-4.19.29.tar.xz\" target=\"_blank\" rel=\"noopener\">内核4.19.29</a></li>\n</ol>\n<p><img src=\"/Others/systemCallAdd/1552919597135.png\" alt=\"1552919597135\" class=\"article-img\"></p>\n<p><img src=\"/Others/systemCallAdd/1552919694354.png\" alt=\"1552919694354\" class=\"article-img\"></p>\n<ol start=\"2\">\n<li>解压</li>\n</ol>\n<blockquote>\n<p>xz -d linux-4.19.29.tar.xz<br>\ntar -xf linux-4.19.29.tar</p>\n</blockquote>\n<p><img src=\"/Others/systemCallAdd/1552919828459.png\" alt=\"1552919828459\" class=\"article-img\"></p>\n<ol>\n<li>\n<p>将源代码移动到/usr/src文件夹下</p>\n</li>\n<li>\n<p>安装一些后面要用到的依赖</p>\n</li>\n</ol>\n<p>笔者在安装时未记录缺少的依赖，应当根据需要安装（安装时提示缺少什么就安装什么）</p>\n<blockquote>\n<p>sudo apt install ncurses-static.x86_64<br>\nsudo apt install openssl-static.x86_64<br>\nsudo apt install libelf-dev</p>\n</blockquote>\n<p><img src=\"/Others/systemCallAdd/1552920032262.png\" alt=\"1552920032262\" class=\"article-img\"></p>\n<ol>\n<li>进入系统调用入口表（记录了System Call的一些基本信息）</li>\n</ol>\n<blockquote>\n<p>vim ./arch/x86/entry/systemCallAdds/systemCallAdd_64.tbl</p>\n</blockquote>\n<p>​\t添加自定义的系统调用</p>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>调用号</th>\n<th>abi</th>\n<th>调用名称</th>\n<th>入口（函数名）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>548</td>\n<td>common</td>\n<td>hanyuu</td>\n<td>sys_hanyuu</td>\n</tr>\n</tbody>\n</table></div></div>\n<p><img src=\"/Others/systemCallAdd/1552925585079.png\" alt=\"1552925585079\" class=\"article-img\"></p>\n<ol>\n<li>添加系统调用声明</li>\n</ol>\n<blockquote>\n<p>vim ./include/linux/systemCallAdds.h</p>\n</blockquote>\n<p>若函数无参数则填写void</p>\n<p><img src=\"/Others/systemCallAdd/1552925987245.png\" alt=\"1552925987245\" class=\"article-img\"></p>\n<ol start=\"7\">\n<li>实现系统调用</li>\n</ol>\n<p>./kernel/sys.c</p>\n<blockquote>\n<p>内核态下应当使用printk()</p>\n<p>用户态下使用printf()</p>\n</blockquote>\n<p><img src=\"/Others/systemCallAdd/1552926385840.png\" alt=\"1552926385840\" class=\"article-img\"></p>\n<ol start=\"8\">\n<li>编译内核</li>\n</ol>\n<p>预处理</p>\n<blockquote>\n<p>sudo make menuconfig</p>\n</blockquote>\n<p>无需裁剪内核或者更改直接两次按ESC退出即可</p>\n<p><img src=\"/Others/systemCallAdd/1552926640804.png\" alt=\"1552926640804\" class=\"article-img\"></p>\n<ol>\n<li>编译内核</li>\n</ol>\n<blockquote>\n<p>j[n]指示同时允许n个任务参与编译，请根据配置调整，笔者此处配置为</p>\n<ul>\n<li>CPU: Intel 8500 (6C6T all for Hyper-V)</li>\n<li>Memory: 40G (15G for Deepin in Hyper-V)</li>\n<li>Disk: Samsung 850 EVO (60G virtual disk)</li>\n</ul>\n<p>在Hyper-V虚拟机中该配置表现较为良好</p>\n</blockquote>\n<blockquote>\n<p>sudo make -j64<br>\n截图为完成过后重新演示截图，此处j32，效率稍低</p>\n</blockquote>\n<p><img src=\"/Others/systemCallAdd/1552927338919.png\" alt=\"1552927338919\" class=\"article-img\"></p>\n<blockquote>\n<p>漫长的编译时光……还是挺吃配置的……</p>\n</blockquote>\n<p><img src=\"/Others/systemCallAdd/1552927663105.png\" alt=\"1552927663105\" class=\"article-img\"></p>\n<blockquote>\n<p>sudo make modules_install</p>\n</blockquote>\n<p><img src=\"/Others/systemCallAdd/1552927440962.png\" alt=\"1552927440962\" class=\"article-img\"></p>\n<blockquote>\n<p>make install<br>\n安装编译好的内核</p>\n</blockquote>\n<p>a. 编译完成后，重启</p>\n<blockquote>\n<p>sudo reboot</p>\n</blockquote>\n<p>b. 编写程序调用定义好的System Call</p>\n<blockquote>\n<p>printk()处于内核态不会直接在屏幕上打印，但是他的输出可以在/proc/kmsg目录下查看</p>\n</blockquote>\n<p><img src=\"/Others/systemCallAdd/1552928540875.png\" alt=\"1552928540875\" class=\"article-img\"></p>\n<p>使用dmesg也可以查看系统调用。</p>\n<p>​<img src=\"/Others/systemCallAdd/1552920832262.png\" alt=\"1552920832262\"></p>\n<h2 id=\"五主要数据结构及其说明\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#五主要数据结构及其说明\"></a> 五，主要数据结构及其说明<a href=\"Others/systemCallAdd#五主要数据结构及其说明\"></a></h2>\n<p>Linux 内核包含已知的所有系统调用的列表, 即所谓的 <strong>系统调用表(System call)</strong>。 每个系统调用都分配一个唯一的数字和一个内核内部函数, 负责实际完成所需的任务。若要执行系统调用, 所需呼叫的数量存储在 CPU 的EAX 寄存器中, 然后触发软件中断 128。根据 FastCall 调用约定, 系统调用上的参数将传入 CPU 寄存器中。</p>\n<p>软件异常 在用户模式下中断程序执行, 并强制在内核模式下执行异常处理程序。这将确保上下文从无特权的环更改为环0。被称为异常处理程序是内核中的一个函数, 它读出 EAX 寄存器, 然后, 如果它包含有效的系统调用号码, 则从系统调用表中相应的内核函数与后续寄存器调用参数。在查看参数后, 从 “用户” 模式请求的任务最终由内核完成。如果此功能返回, 异常处理程序也将成功完成, 正常的程序流将继续在无特权模式下。</p>\n<blockquote>\n<p>mov $6, %eax ; close() ist Systemaufruf 6<br>\nmov $15, %ebx ; Dateideskriptor als erstes Argument<br>\nint $0x80  ; Softwareinterrupt</p>\n</blockquote>\n<h2 id=\"六程序运行时的初值和结果\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#六程序运行时的初值和结果\"></a> 六，程序运行时的初值和结果<a href=\"Others/systemCallAdd#六程序运行时的初值和结果\"></a></h2>\n<p>无初值，结果为printk()函数中的内容，截图见<a href=\"Others/systemCallAdd#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4\">上文</a>。</p>\n<h2 id=\"七实验体会\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#七实验体会\"></a> 七，实验体会<a href=\"Others/systemCallAdd#七实验体会\"></a></h2>\n<p>System call 作为沟通上下层的连接件，其实现没有想象中的那么难也不算简单，只要敢于尝试就会有所收获。</p>\n<h2 id=\"八源程序并附上注释\"><a class=\"markdownIt-Anchor\" href=\"Others/systemCallAdd#八源程序并附上注释\"></a> 八，源程序并附上注释<a href=\"Others/systemCallAdd#八源程序并附上注释\"></a></h2>\n<ul>\n<li>./arch/x86/entry/systemCallAdds/systemCallAdd_64.tbl</li>\n</ul>\n<blockquote>\n<p>548\tcommon hanyuu sys_hanyuu //添加系统调用入口表</p>\n</blockquote>\n<ul>\n<li>include/linux/systemCallAdds.h</li>\n</ul>\n<blockquote>\n<p>amslink sys_hanyuu(void);\t//自定义系统调用声明</p>\n</blockquote>\n<ul>\n<li>kernel/sys.c</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">* Hanyuu's system call</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\">asmlinkage <span class=\"keyword\">long</span> <span class=\"title\">sys_hanyuu</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>\t<span class=\"comment\">//自定义系统调用实现</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">printk(<span class=\"string\">\"\\n[[hanyuu]] System call start\\n\"</span>);</span><br><span class=\"line\">printk(<span class=\"string\">\"my student number is [N/A] and my name ls Hanyuu Furude.\"</span>);</span><br><span class=\"line\">printk(<span class=\"string\">\"\\n[[hanyuu]] System call end\\n\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hanyuu.c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试程序</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unisted.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">systemcall(<span class=\"number\">548</span>);\t<span class=\"comment\">//调用自定义系统调用</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>","prev":{"title":"软件体系架构","link":"Review/SoftwareArchitecture"},"next":{"title":"vim Reference","link":"Others/vim"},"plink":"ilucia.github.io/Others/systemCallAdd/","toc":[{"title":"<a class=\"markdownIt-Anchor\"></a> 一，基本信息","id":"一基本信息","index":"1"},{"title":"<a class=\"markdownIt-Anchor\"></a> 二，实验目的","id":"二实验目的","index":"2"},{"title":"<a class=\"markdownIt-Anchor\"></a> 三，实验内容","id":"三实验内容","index":"3"},{"title":"<a class=\"markdownIt-Anchor\"></a> 四，实验步骤","id":"四实验步骤","index":"4","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> 思路","id":"思路","index":"4.1"}]},{"title":"<a class=\"markdownIt-Anchor\"></a> 步骤","id":"步骤","index":"5","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> 系统版本","id":"系统版本","index":"5.1"},{"title":"<a class=\"markdownIt-Anchor\"></a> 原内核版本","id":"原内核版本","index":"5.2"},{"title":"<a class=\"markdownIt-Anchor\"></a> 后内核版本","id":"后内核版本","index":"5.3"},{"title":"<a class=\"markdownIt-Anchor\"></a> 具体步骤","id":"具体步骤","index":"5.4"}]},{"title":"<a class=\"markdownIt-Anchor\"></a> 五，主要数据结构及其说明","id":"五主要数据结构及其说明","index":"6"},{"title":"<a class=\"markdownIt-Anchor\"></a> 六，程序运行时的初值和结果","id":"六程序运行时的初值和结果","index":"7"},{"title":"<a class=\"markdownIt-Anchor\"></a> 七，实验体会","id":"七实验体会","index":"8"},{"title":"<a class=\"markdownIt-Anchor\"></a> 八，源程序并附上注释","id":"八源程序并附上注释","index":"9"}],"copyright":{"author":"Ilucia Niu","license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\">知识共享署名 4.0 国际许可协议</a>","published":"2019年3月18日","updated":"2022年4月27日"}}