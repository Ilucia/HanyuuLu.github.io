{"title":"java1.8/函数式编程","date":"2022-04-27T15:24:01.723Z","link":"java1.8/函数式编程","updated":"2022-04-27T15:24:01.723Z","content":"<h2 id=\"概述\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#概述\"></a> 概述<a href=\"java1.8/函数式编程#概述\"></a></h2>\n<h3 id=\"函数式编程简介\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#函数式编程简介\"></a> 函数式编程简介<a href=\"java1.8/函数式编程#函数式编程简介\"></a></h3>\n<p>我们最常用的面向对象编程（Java）属于<strong>命令式编程</strong>（Imperative Programming）这种编程范式。常见的编程范式还有<strong>逻辑式编程</strong>（Logic Programming），<strong>函数式编程</strong>（Functional Programming）</p>\n<p>函数式编程把计算过程当做是数学函数的求值，而避免更改状态和可变数据</p>\n<p>什么是函数式编程？简单的回答：一切都是数学函数。函数式编程语言里也可以有对象，但通常这些对象都是恒定不变的 —— 要么是函数参数，要什么是函数返回值。函数式编程语言里没有 for/next 循环，因为这些逻辑意味着有状态的改变。相替代的是，这种循环逻辑在函数式编程语言里是通过递归、把函数当成参数传递的方式实现的</p>\n<h3 id=\"lambda-表达式简介\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda-表达式简介\"></a> Lambda 表达式简介<a href=\"java1.8/函数式编程#lambda-表达式简介\"></a></h3>\n<p>Java 8的最大变化是引入了Lambda（Lambda 是希腊字母 λ 的英文名称）表达式——一种紧凑的、传递行为的方式。</p>\n<p>先看个例子：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addActionListener(<span class=\"keyword\">new</span> ActionListener() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent event)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"button clicked\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<p>这段代码使用了匿名类。<code>ActionListener</code> 是一个接口，这里 new 了一个类实现了 <code>ActionListener</code> 接口，然后重写了 <code>actionPerformed</code> 方法。<code>actionPerformed</code> 方法接收 <code>ActionEvent</code> 类型参数，返回空。</p>\n<p>这段代码我们其实只关心中间打印的语句，其他都是多余的。所以使用 Lambda 表达式，我们就可以简写为：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">button.addActionListener(event -&gt; System.out.println(<span class=\"string\">\"button clicked\"</span>));</span><br></pre></td></tr></table></div></figure>\n<h2 id=\"lambda-表达式\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda-表达式\"></a> Lambda 表达式<a href=\"java1.8/函数式编程#lambda-表达式\"></a></h2>\n<h3 id=\"lambda-表达式的形式\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda-表达式的形式\"></a> Lambda 表达式的形式<a href=\"java1.8/函数式编程#lambda-表达式的形式\"></a></h3>\n<p>Java 中 Lambda 表达式一共有五种基本形式，具体如下：</p>\n<h5 id=\"1\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#1\"></a> 1<a href=\"java1.8/函数式编程#1\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable noArguments = () -&gt; System.out.println(<span class=\"string\">\"Hello World\"</span>);</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>不包含参数,使用空括号 () 表示没有参数</li>\n<li>该 Lambda 表达式 实现了 Runnable 接口,该接口也只有一个 run 方法,没有参数,且返回类型为 void</li>\n</ul>\n<h5 id=\"2\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#2\"></a> 2<a href=\"java1.8/函数式编程#2\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ActionListener oneArgument = event -&gt; System.out.println(<span class=\"string\">\"button clicked\"</span>);</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>包含且只包含一个参数,可省略参数的括号</li>\n</ul>\n<h5 id=\"3\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#3\"></a> 3<a href=\"java1.8/函数式编程#3\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Runnable multiStatement = () -&gt; &#123;</span><br><span class=\"line\">\tSystem.out.print(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">\tSystem.out.println(<span class=\"string\">\" World\"</span>);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>Lambda 表达式的主体不仅可以是一个表达式,而且也可以是一段代码块,使用大括号 ({})将代码块括起来</li>\n<li>该代码块和普通方法遵循的规则别无二致,可以用返 回或抛出异常来退出。只有一行代码的 Lambda 表达式也可使用大括号,用以明确 Lambda表达式从何处开始、到哪里结束</li>\n</ul>\n<h5 id=\"4\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#4\"></a> 4<a href=\"java1.8/函数式编程#4\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>表示包含多个参数的方法</li>\n<li>代码阅读方法\n<ul>\n<li>这行代码并不是将两个数字相加,而是创建了一个函数,用来计算 两个数字相加的结果</li>\n<li>变量 add 的类型是 BinaryOperator,它不是两个数字的和, 而是将两个数字相加的那行代码</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"5\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#5\"></a> 5<a href=\"java1.8/函数式编程#5\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>\n<p>到目前为止,所有 Lambda 表达式中的参数类型都是由编译器推断得出的</p>\n</li>\n<li>\n<p>可以显式声明参数类型,此时就需要使用小括号将参数括起来,多个参数的情况也是如此</p>\n</li>\n<li>\n<p>Lambda 表达式都可以扩写为原始的“匿名类”形式</p>\n<ul>\n<li>Lambda 表达式很复杂不容易理解的时候，不妨把它扩写为“匿名类”形式来看</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"闭包\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#闭包\"></a> 闭包<a href=\"java1.8/函数式编程#闭包\"></a></h3>\n<ul>\n<li>匿名内部类所在方法里的变量，必须声明为 <code>final</code></li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> String name = getUserName();</span><br><span class=\"line\">button.addActionListener(<span class=\"keyword\">new</span> ActionListener() &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent event)</span> </span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(<span class=\"string\">\"hi \"</span> + name);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>Java 8放松了这一限制，可以不必再把变量声明为 <code>final</code>，但其实该变量实际上仍然是 <code>final</code> 的</li>\n<li>虽然无需将变量声明为 final，但在 Lambda 表达式中，也无法用作非终态变量\n<ul>\n<li>如果坚持用作非终态变量（即改变变量的值），编译器就会报错</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"函数接口\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#函数接口\"></a> 函数接口<a href=\"java1.8/函数式编程#函数接口\"></a></h3>\n<p>上面例子里提到了 <code>ActionListener</code> 接口，我们看一下它的代码：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ActionListener</span> <span class=\"keyword\">extends</span> <span class=\"title\">EventListener</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Invoked when an action occurs.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">actionPerformed</span><span class=\"params\">(ActionEvent e)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li><code>ActionListener</code> 只有一个抽象方法：<code>actionPerformed</code>，被用来表示行为:接受一个参数，返回空</li>\n<li>由于 <code>actionPerformed</code> 定义在一个接口里，因此 <code>abstract</code> 关键字不是必需的</li>\n<li>该接口也继承自一个不具有任何方法的父接口：<code>EventListener</code>\n<ul>\n<li>我们把这种接口就叫做函数接口</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"jdk-8-常用核心函数接口\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#jdk-8-常用核心函数接口\"></a> JDK 8 常用核心函数接口<a href=\"java1.8/函数式编程#jdk-8-常用核心函数接口\"></a></h4>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">接口</th>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">返回类型</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">Predicate<t></t></td>\n<td style=\"text-align:left\">T</td>\n<td style=\"text-align:left\">boolean</td>\n<td style=\"text-align:left\">用于判别一个对象。比如求一个人是否为男性</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Consumer<t></t></td>\n<td style=\"text-align:left\">T</td>\n<td style=\"text-align:left\">void</td>\n<td style=\"text-align:left\">用于接收一个对象进行处理但没有返回，比如接收一个人并打印他的名字</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Function&lt;T, R&gt;</td>\n<td style=\"text-align:left\">T</td>\n<td style=\"text-align:left\">R</td>\n<td style=\"text-align:left\">转换一个对象为不同类型的对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Supplier<t></t></td>\n<td style=\"text-align:left\">None</td>\n<td style=\"text-align:left\">T</td>\n<td style=\"text-align:left\">提供一个对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">UnaryOperator<t></t></td>\n<td style=\"text-align:left\">T</td>\n<td style=\"text-align:left\">T</td>\n<td style=\"text-align:left\">接收对象并返回同类型的对象</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">BinaryOperator<t></t></td>\n<td style=\"text-align:left\">(T, T)</td>\n<td style=\"text-align:left\">T</td>\n<td style=\"text-align:left\">接收两个同类型的对象，并返回一个原类型对象</td>\n</tr>\n</tbody>\n</table></div></div>\n<ul>\n<li><code>Cosumer</code> 与 <code>Supplier</code> 对应，一个是消费者，一个是提供者</li>\n<li><code>Predicate</code> 用于判断对象是否符合某个条件，经常被用来过滤对象</li>\n<li><code>Function</code> 是将一个对象转换为另一个对象，比如说要装箱或者拆箱某个对象</li>\n<li><code>UnaryOperator</code> 接收和返回同类型对象，一般用于对对象修改属性。<code>BinaryOperator</code> 则可以理解为合并对象</li>\n</ul>\n<h2 id=\"集合处理\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#集合处理\"></a> 集合处理<a href=\"java1.8/函数式编程#集合处理\"></a></h2>\n<h3 id=\"lambda表达式\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda表达式\"></a> lambda表达式<a href=\"java1.8/函数式编程#lambda表达式\"></a></h3>\n<h4 id=\"例-线程\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#例-线程\"></a> 例 线程<a href=\"java1.8/函数式编程#例-线程\"></a></h4>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Java7</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> Thread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">        System.out.println(i);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;).start();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Java8</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> Thread(() -&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100</span>; i++) &#123;</span><br><span class=\"line\">      System.out.println(i);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;).start();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"使用场景\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#使用场景\"></a> 使用场景<a href=\"java1.8/函数式编程#使用场景\"></a></h4>\n<h5 id=\"简化匿名类的编码\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#简化匿名类的编码\"></a> 简化匿名类的编码<a href=\"java1.8/函数式编程#简化匿名类的编码\"></a></h5>\n<h5 id=\"减少不必要的方法创建\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#减少不必要的方法创建\"></a> 减少不必要的方法创建<a href=\"java1.8/函数式编程#减少不必要的方法创建\"></a></h5>\n<ul>\n<li>某个方法只会在某处使用且内部逻辑也很简单，在Java8之前我们通常都会创建一个方法，但是事实上我们经常会发现这样写着写着，一个类中的方法可能会变得非常庞杂，严重影响阅读体验，进而影响编码效率。但是如果使用lambda表达式，那么这个问题就可以很容易就解决</li>\n<li>例：多次打印时间</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionMain</span> </span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        TimeDemo timeDemo = <span class=\"keyword\">new</span> TimeDemo();</span><br><span class=\"line\">        timeDemo.createTime = System.currentTimeMillis();</span><br><span class=\"line\">        timeDemo.updateTime = System.currentTimeMillis() + <span class=\"number\">10000</span>;</span><br><span class=\"line\">        outputTimeDemo(timeDemo);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">outputTimeDemo</span><span class=\"params\">(TimeDemo timeDemo)</span> </span>&#123;</span><br><span class=\"line\">        Function timestampToDate = timestamp -&gt; &#123;</span><br><span class=\"line\">            DateFormat df = <span class=\"keyword\">new</span> SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> df.format(<span class=\"keyword\">new</span> Date(timestamp));</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">     System.out.println(timestampToDate.apply(timeDemo.createTime));       System.out.println(timestampToDate.apply(timeDemo.updateTime));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">String <span class=\"title\">apply</span><span class=\"params\">(<span class=\"keyword\">long</span> timestamp)</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TimeDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> createTime;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> updateTime;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>在这段代码的outputTimeDemo中我们可以看到，对于时间戳转换的内容，我们并没有额外创建一个方法，而是类似于创建了一个变量来表达</li>\n<li>不过，这个时候出现了另一个问题，虽然我们少创建了一个方法，但是我们却多创建了一个接口Function，总有种因小失大的感觉，不过这个问题，我们在后面的java.util.function包部分可以找到答案</li>\n</ul>\n<h5 id=\"事件处理回调\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#事件处理回调\"></a> 事件处理(回调)<a href=\"java1.8/函数式编程#事件处理回调\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    execute(<span class=\"string\">\"hello world\"</span>, () -&gt; System.out.println(<span class=\"string\">\"callback\"</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(String s, Callback callback)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(s);</span><br><span class=\"line\">    callback.callback();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callback</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">callback</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<ul>\n<li>Callback多了一个注解@FunctionalInterface，这个注解主要用于编译期检查，如果我们的接口不符合函数式接口的要求，那编译的时候就会报错</li>\n</ul>\n<h4 id=\"javautilfunction包\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#javautilfunction包\"></a> java.util.function包<a href=\"java1.8/函数式编程#javautilfunction包\"></a></h4>\n<ul>\n<li>在之前的例子中，我们发现使用lambda表达式的时候，经常需要定义一些接口用来辅助我们的编码，这样就会使得本应轻量级的lambda表达式又变得重量级</li>\n<li>其实Java8本身已经为我们提供了一些常见的函数式接口，就在java.util.function包下面</li>\n</ul>\n<div class=\"article-bounded\"><div class=\"article-table\"><table>\n<thead>\n<tr>\n<th>接口</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Function&lt;T,R&gt;</td>\n<td>接受一个输入参数，返回一个结果</td>\n</tr>\n<tr>\n<td>Supplier</td>\n<td>无参数，返回一个结果</td>\n</tr>\n<tr>\n<td>Consumer</td>\n<td>接受一个输入参数，并且不返回任何结果</td>\n</tr>\n<tr>\n<td>BiFunction&lt;T,U,R&gt;</td>\n<td>接受两个输入参数的方法，并且返回一个结果</td>\n</tr>\n<tr>\n<td>BiConsumer&lt;T,U&gt;</td>\n<td>接受两个输入参数的操作，并且不返回任何结果</td>\n</tr>\n</tbody>\n</table></div></div>\n<ul>\n<li>此处列出最基本的几个，其他的都是在这些的基础上做了一些简单的封装，例如IntFunction就是对Function&lt;T,R&gt;的封装\n<ul>\n<li>如果有更复杂的情况，那就得自己定义接口了</li>\n</ul>\n</li>\n<li>在java.util.function下没有无参数无返回结果的接口\n<ul>\n<li>自己定义一个接口或者直接使用Runnable接口</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class=\"number\">1</span>;</span><br><span class=\"line\">    System.out.println(f.apply(<span class=\"number\">1</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">    BiFunction&lt;Integer, Integer, Integer&gt; g = (x, y) -&gt; x + y;</span><br><span class=\"line\">    System.out.println(g.apply(<span class=\"number\">1</span>, <span class=\"number\">2</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"lambda表达式和匿名类的区别\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda表达式和匿名类的区别\"></a> lambda表达式和匿名类的区别<a href=\"java1.8/函数式编程#lambda表达式和匿名类的区别\"></a></h3>\n<h4 id=\"this指向不同\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#this指向不同\"></a> this指向不同<a href=\"java1.8/函数式编程#this指向不同\"></a></h4>\n<ul>\n<li>lambda表达式中使用this指向的是外部的类，而匿名类中使用this则指向的是匿名类本身</li>\n</ul>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FunctionMain</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String test = <span class=\"string\">\"test-main\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> FunctionMain().output();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">output</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Function f = () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"1:-----------------\"</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">            System.out.println(<span class=\"keyword\">this</span>.test);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        f.outputThis();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Function() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">outputThis</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"2:-----------------\"</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">                System.out.println(<span class=\"keyword\">this</span>.test);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;.outputThis();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Function</span> </span>&#123;</span><br><span class=\"line\">        String test = <span class=\"string\">\"test-function\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">outputThis</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p><img src=\"https://img-blog.csdnimg.cn/20190613150049342.png\" alt=\"在这里插入图片描述\" class=\"article-img\"></p>\n<ul>\n<li>使用lambda表达式的同时去访问原类中的变量、方法的是做不到的</li>\n</ul>\n<h4 id=\"底层实现不同\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#底层实现不同\"></a> 底层实现不同<a href=\"java1.8/函数式编程#底层实现不同\"></a></h4>\n<h5 id=\"编译\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#编译\"></a> 编译<a href=\"java1.8/函数式编程#编译\"></a></h5>\n<ul>\n<li>匿名类会生成额外的class文件，lambda不会\n<ul>\n<li>ClassMain$1.class</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"字节码\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#字节码\"></a> 字节码<a href=\"java1.8/函数式编程#字节码\"></a></h5>\n<ul>\n<li>匿名类通过new一个类来实现</li>\n<li>lambda表达式被编译成一个lambda$main$0的静态方法，并通过invokedynamic的方式调用</li>\n</ul>\n<h5 id=\"替代条件\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#替代条件\"></a> 替代条件<a href=\"java1.8/函数式编程#替代条件\"></a></h5>\n<ul>\n<li>lambda表达式想要替代匿名类，需要匿名类实现的接口为函数式接口，即只有一个抽象方法</li>\n</ul>\n<h3 id=\"lambda的延迟执行\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda的延迟执行\"></a> Lambda的延迟执行<a href=\"java1.8/函数式编程#lambda的延迟执行\"></a></h3>\n<p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以 作为解决方案，提升性能。</p>\n<h4 id=\"性能浪费的日志案例\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#性能浪费的日志案例\"></a> 性能浪费的日志案例<a href=\"java1.8/函数式编程#性能浪费的日志案例\"></a></h4>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。</span><br></pre></td></tr></table></div></figure>\n<p>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo01Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">\"World \"</span>;</span><br><span class=\"line\">        String msgC = <span class=\"string\">\"Java\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        log(<span class=\"number\">1</span>, msgA + msgB + msgC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> level, String mgs)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(mgs);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这段代码存在问题：无论级别 level 是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行 字符串的拼接，而是将字符串的若干部分作</span><br><span class=\"line\">为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。例如: LOGGER.debug(&quot;变量&#123;&#125;的取值为&#123;&#125;。&quot;, &quot;os&quot;, &quot;macOS&quot;) ，</span><br><span class=\"line\">其中的大括号 &#123;&#125; 为占位 符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置;否则不会进行字 符串拼接。这也是</span><br><span class=\"line\">一种可行解决方案，但Lambda可以做到更好。</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"体验lambda的更优写法\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#体验lambda的更优写法\"></a> 体验Lambda的更优写法<a href=\"java1.8/函数式编程#体验lambda的更优写法\"></a></h4>\n<p>使用Lambda必然需要一个函数式接口：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@FunctionalInterface</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">MessageBuilder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 信息生成器</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 生成的信息</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> String <span class=\"title\">builderMessage</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>然后对 log 方法进行改造：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo02Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">\"World \"</span>;</span><br><span class=\"line\">        String msgC = <span class=\"string\">\"Java\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        log(<span class=\"number\">1</span>, () -&gt; msgA + msgB + msgC);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> level, MessageBuilder mb)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(mb.builderMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>改造前后的对比：</p>\n<p><a href=\"https://img2018.cnblogs.com/i-beta/1681961/202002/1681961-20200209012055355-450845081.png\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img2018.cnblogs.com/i-beta/1681961/202002/1681961-20200209012055355-450845081.png\" alt=\"img\"></a></p>\n<p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接;否则三个字符串将不会进行拼接。</p>\n<h4 id=\"证明lambda的延迟\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#证明lambda的延迟\"></a> 证明Lambda的延迟<a href=\"java1.8/函数式编程#证明lambda的延迟\"></a></h4>\n<p>下面的代码可以通过结果进行验证：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo03Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">\"World \"</span>;</span><br><span class=\"line\">        String msgC = <span class=\"string\">\"Java\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        log(<span class=\"number\">2</span>, () -&gt; &#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"Lambada 执行！\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> msgA + msgB + msgC;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> level, MessageBuilder mb)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(mb.builderMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>这里只是在调用 log 方法的时候，将传入的Lambda稍作修改，</p>\n<p>当传入的 level = 1 的时候，控制台输出：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Lambada 执行！</span><br><span class=\"line\">Hello World Java</span><br></pre></td></tr></table></div></figure>\n<p>当传入的 level != 1 的时候，控制台没有输出。</p>\n<p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调</span><br><span class=\"line\">用其所在方法是在条件判断之后才执行的。</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo04Logger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String msgA = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">        String msgB = <span class=\"string\">\"World \"</span>;</span><br><span class=\"line\">        String msgC = <span class=\"string\">\"Java\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        log(<span class=\"number\">1</span>, <span class=\"keyword\">new</span> MessageBuilder() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">builderMessage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"Lambada 执行！\"</span>);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> msgA + msgB + msgC;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">log</span><span class=\"params\">(<span class=\"keyword\">int</span> level, MessageBuilder mb)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (level == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            System.out.println(mb.builderMessage());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h3 id=\"使用lambda作为参数和返回值\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#使用lambda作为参数和返回值\"></a> 使用Lambda作为参数和返回值<a href=\"java1.8/函数式编程#使用lambda作为参数和返回值\"></a></h3>\n<p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。</p>\n<h4 id=\"lambda作为参数\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda作为参数\"></a> Lambda作为参数<a href=\"java1.8/函数式编程#lambda作为参数\"></a></h4>\n<p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p>\n<h5 id=\"匿名内部类作为参数创建新的线程并执行\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#匿名内部类作为参数创建新的线程并执行\"></a> 匿名内部类作为参数，创建新的线程并执行<a href=\"java1.8/函数式编程#匿名内部类作为参数创建新的线程并执行\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo01Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        startThread(<span class=\"keyword\">new</span> Runnable() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                System.out.println(<span class=\"string\">\"线程任务执行!\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建一个新的线程，赋予任务，然后开启线程</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> runnable 传入Thread类的接口，实现创建新线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startThread</span><span class=\"params\">(Runnable runnable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>运行程序，控制台输出：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程任务执行!</span><br></pre></td></tr></table></div></figure>\n<h5 id=\"lambda作为参数创建新的线程并执行\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda作为参数创建新的线程并执行\"></a> Lambda作为参数，创建新的线程并执行<a href=\"java1.8/函数式编程#lambda作为参数创建新的线程并执行\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Demo02Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        startThread(</span><br><span class=\"line\">                () -&gt; System.out.println(<span class=\"string\">\"线程任务执行!\"</span>)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 创建一个新的线程，赋予任务，然后开启线程</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> runnable 传入Thread类的接口，实现创建新线程</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">startThread</span><span class=\"params\">(Runnable runnable)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(runnable).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>运行程序，控制台输出：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线程任务执行!</span><br></pre></td></tr></table></div></figure>\n<h4 id=\"lambda作为返回值\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda作为返回值\"></a> Lambda作为返回值<a href=\"java1.8/函数式编程#lambda作为返回值\"></a></h4>\n<p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p>\n<h5 id=\"lambda作为返回值字符串的长短比较\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#lambda作为返回值字符串的长短比较\"></a> Lambda作为返回值，字符串的长短比较<a href=\"java1.8/函数式编程#lambda作为返回值字符串的长短比较\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoComparator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = &#123; <span class=\"string\">\"abc\"</span>, <span class=\"string\">\"ab\"</span>, <span class=\"string\">\"a\"</span> &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用比较器比较之前：\"</span> + Arrays.toString(array));</span><br><span class=\"line\">        Arrays.sort(array, newComparator());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用比较器比较之后：\"</span> + Arrays.toString(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 字符串a、b的长短比较，自己定义比较器规则，生序排序，字符串长的排在后面。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 布尔值，</span></span><br><span class=\"line\"><span class=\"comment\">     *         a.length() - b.length() &lt; 0 返回 false，</span></span><br><span class=\"line\"><span class=\"comment\">     *         a.length() - b.length() &gt; 0 返回 true，</span></span><br><span class=\"line\"><span class=\"comment\">     *         a.length() = b.length() 返回 0</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Comparator&lt;String&gt; <span class=\"title\">newComparator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (a, b) -&gt; a.length() - b.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<h5 id=\"匿名内部类作为返回值字符串的长短比较\"><a class=\"markdownIt-Anchor\" href=\"java1.8/函数式编程#匿名内部类作为返回值字符串的长短比较\"></a> 匿名内部类作为返回值，字符串的长短比较<a href=\"java1.8/函数式编程#匿名内部类作为返回值字符串的长短比较\"></a></h5>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Comparator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoComparator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        String[] array = &#123; <span class=\"string\">\"abc\"</span>, <span class=\"string\">\"ab\"</span>, <span class=\"string\">\"a\"</span> &#125;;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用比较器比较之前：\"</span> + Arrays.toString(array));</span><br><span class=\"line\">        Arrays.sort(array, newComparator());</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用比较器比较之后：\"</span> + Arrays.toString(array));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Comparator&lt;String&gt; <span class=\"title\">newComparator1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class=\"line\">            <span class=\"meta\">@Override</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(String o1, String o2)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> o1.length() - o2.length();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></div></figure>\n<p>运行程序，控制台输出一样：</p>\n<figure class=\"highlight\"><div><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用比较器比较之前：[abc, ab, a]</span><br><span class=\"line\">使用比较器比较之后：[a, ab, abc]</span><br></pre></td></tr></table></div></figure>","prev":{"title":"java1.8/集合_容器","link":"java1.8/集合_容器"},"next":{"title":"java1.8/多线程","link":"java1.8/多线程"},"plink":"ilucia.github.io/java1.8/函数式编程/","toc":[{"title":"<a class=\"markdownIt-Anchor\"></a> 概述","id":"概述","index":"1","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> 函数式编程简介","id":"函数式编程简介","index":"1.1"},{"title":"<a class=\"markdownIt-Anchor\"></a> Lambda 表达式简介","id":"lambda-表达式简介","index":"1.2"}]},{"title":"<a class=\"markdownIt-Anchor\"></a> Lambda 表达式","id":"lambda-表达式","index":"2","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> Lambda 表达式的形式","id":"lambda-表达式的形式","index":"2.1"},{"title":"<a class=\"markdownIt-Anchor\"></a> 闭包","id":"闭包","index":"2.2"},{"title":"<a class=\"markdownIt-Anchor\"></a> 函数接口","id":"函数接口","index":"2.3","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> JDK 8 常用核心函数接口","id":"jdk-8-常用核心函数接口","index":"2.3.1"}]}]},{"title":"<a class=\"markdownIt-Anchor\"></a> 集合处理","id":"集合处理","index":"3","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> lambda表达式","id":"lambda表达式","index":"3.1","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> 例 线程","id":"例-线程","index":"3.1.1"},{"title":"<a class=\"markdownIt-Anchor\"></a> 使用场景","id":"使用场景","index":"3.1.2"},{"title":"<a class=\"markdownIt-Anchor\"></a> java.util.function包","id":"javautilfunction包","index":"3.1.3"}]},{"title":"<a class=\"markdownIt-Anchor\"></a> lambda表达式和匿名类的区别","id":"lambda表达式和匿名类的区别","index":"3.2","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> this指向不同","id":"this指向不同","index":"3.2.1"},{"title":"<a class=\"markdownIt-Anchor\"></a> 底层实现不同","id":"底层实现不同","index":"3.2.2"}]},{"title":"<a class=\"markdownIt-Anchor\"></a> Lambda的延迟执行","id":"lambda的延迟执行","index":"3.3","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> 性能浪费的日志案例","id":"性能浪费的日志案例","index":"3.3.1"},{"title":"<a class=\"markdownIt-Anchor\"></a> 体验Lambda的更优写法","id":"体验lambda的更优写法","index":"3.3.2"},{"title":"<a class=\"markdownIt-Anchor\"></a> 证明Lambda的延迟","id":"证明lambda的延迟","index":"3.3.3"}]},{"title":"<a class=\"markdownIt-Anchor\"></a> 使用Lambda作为参数和返回值","id":"使用lambda作为参数和返回值","index":"3.4","children":[{"title":"<a class=\"markdownIt-Anchor\"></a> Lambda作为参数","id":"lambda作为参数","index":"3.4.1"},{"title":"<a class=\"markdownIt-Anchor\"></a> Lambda作为返回值","id":"lambda作为返回值","index":"3.4.2"}]}]}],"copyright":{"author":"Ilucia Niu","license":"<a rel=\"license\" href=\"http://creativecommons.org/licenses/by/4.0/\">知识共享署名 4.0 国际许可协议</a>","published":"2022年4月27日","updated":"2022年4月27日"}}