<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ilucia&#39;s page</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="ilucia.github.io/"/>
  <updated>2022-04-27T15:24:01.775Z</updated>
  <id>ilucia.github.io/</id>
  
  <author>
    <name>Ilucia Niu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多线程</title>
    <link href="ilucia.github.io/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>ilucia.github.io/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-04-27T15:24:01.775Z</published>
    <updated>2022-04-27T15:24:01.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用线程"><a class="markdownIt-Anchor" href="多线程#使用线程"></a> 使用线程<a href="多线程#使用线程"></a></h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h2 id="实现-runnable-接口"><a class="markdownIt-Anchor" href="多线程#实现-runnable-接口"></a> 实现 Runnable 接口<a href="多线程#实现-runnable-接口"></a></h2><p>需要实现接口中的 run() 方法。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="实现-callable-接口"><a class="markdownIt-Anchor" href="多线程#实现-callable-接口"></a> 实现 Callable 接口<a href="多线程#实现-callable-接口"></a></h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="继承-thread-类"><a class="markdownIt-Anchor" href="多线程#继承-thread-类"></a> 继承 Thread 类<a href="多线程#继承-thread-类"></a></h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="实现接口-vs-继承-thread"><a class="markdownIt-Anchor" href="多线程#实现接口-vs-继承-thread"></a> 实现接口 VS 继承 Thread<a href="多线程#实现接口-vs-继承-thread"></a></h2><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h1 id="基础线程机制"><a class="markdownIt-Anchor" href="多线程#基础线程机制"></a> 基础线程机制<a href="多线程#基础线程机制"></a></h1><h2 id="executor"><a class="markdownIt-Anchor" href="多线程#executor"></a> Executor<a href="多线程#executor"></a></h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="daemon"><a class="markdownIt-Anchor" href="多线程#daemon"></a> Daemon<a href="多线程#daemon"></a></h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="sleep"><a class="markdownIt-Anchor" href="多线程#sleep"></a> sleep()<a href="多线程#sleep"></a></h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="yield"><a class="markdownIt-Anchor" href="多线程#yield"></a> yield()<a href="多线程#yield"></a></h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="中断"><a class="markdownIt-Anchor" href="多线程#中断"></a> 中断<a href="多线程#中断"></a></h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h2 id="interruptedexception"><a class="markdownIt-Anchor" href="多线程#interruptedexception"></a> InterruptedException<a href="多线程#interruptedexception"></a></h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599</span>.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></div></figure><h2 id="interrupted"><a class="markdownIt-Anchor" href="多线程#interrupted"></a> interrupted()<a href="多线程#interrupted"></a></h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">Thread end</span><br></pre></td></tr></table></div></figure><h2 id="executor-的中断操作"><a class="markdownIt-Anchor" href="多线程#executor-的中断操作"></a> Executor 的中断操作<a href="多线程#executor-的中断操作"></a></h2><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$<span class="number">0</span>(ExecutorInterruptExample.java:<span class="number">9</span>)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$<span class="number">1</span>/<span class="number">1160460865</span>.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></div></figure><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></div></figure><h1 id="互斥同步"><a class="markdownIt-Anchor" href="多线程#互斥同步"></a> 互斥同步<a href="多线程#互斥同步"></a></h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized"><a class="markdownIt-Anchor" href="多线程#synchronized"></a> synchronized<a href="多线程#synchronized"></a></h2><p><strong>1. 同步一个代码块</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></div></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></div></figure><p><strong>2. 同步一个方法</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>它和同步代码块一样，作用于同一个对象。</p><p><strong>3. 同步一个类</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></div></figure><p><strong>4. 同步一个静态方法</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>作用于整个类。</p><h2 id="reentrantlock"><a class="markdownIt-Anchor" href="多线程#reentrantlock"></a> ReentrantLock<a href="多线程#reentrantlock"></a></h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">​```java</span><br><span class="line"></span><br><span class="line">## 比较</span><br><span class="line"></span><br><span class="line">**<span class="number">1</span>. 锁的实现**</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>. 性能**</span><br><span class="line"></span><br><span class="line">新版本 Java 对 <span class="keyword">synchronized</span> 进行了很多优化，例如自旋锁等，<span class="keyword">synchronized</span> 与 ReentrantLock 大致相同。</span><br><span class="line"></span><br><span class="line">**<span class="number">3</span>. 等待可中断**</span><br><span class="line"></span><br><span class="line">当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</span><br><span class="line"></span><br><span class="line">ReentrantLock 可中断，而 <span class="keyword">synchronized</span> 不行。</span><br><span class="line"></span><br><span class="line">**<span class="number">4</span>. 公平锁**</span><br><span class="line"></span><br><span class="line">公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</span><br><span class="line"></span><br><span class="line">**<span class="number">5</span>. 锁绑定多个条件**</span><br><span class="line"></span><br><span class="line">一个 ReentrantLock 可以同时绑定多个 Condition 对象。</span><br><span class="line"></span><br><span class="line">## 使用选择</span><br><span class="line"></span><br><span class="line">除非需要使用 ReentrantLock 的高级功能，否则优先使用 <span class="keyword">synchronized</span>。这是因为 <span class="keyword">synchronized</span> 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 <span class="keyword">synchronized</span> 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</span><br><span class="line"></span><br><span class="line"># 五、线程之间的协作</span><br><span class="line"></span><br><span class="line">当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</span><br><span class="line"></span><br><span class="line">## join()</span><br><span class="line"></span><br><span class="line">在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</span><br><span class="line"></span><br><span class="line">对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></div></figure><h2 id="wait-notify-notifyall"><a class="markdownIt-Anchor" href="多线程#wait-notify-notifyall"></a> wait() notify() notifyAll()<a href="多线程#wait-notify-notifyall"></a></h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></div></figure><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2 id="await-signal-signalall"><a class="markdownIt-Anchor" href="多线程#await-signal-signalall"></a> await() signal() signalAll()<a href="多线程#await-signal-signalall"></a></h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></div></figure><h1 id="线程状态"><a class="markdownIt-Anchor" href="多线程#线程状态"></a> 线程状态<a href="多线程#线程状态"></a></h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p><h2 id="新建new"><a class="markdownIt-Anchor" href="多线程#新建new"></a> 新建（NEW）<a href="多线程#新建new"></a></h2><p>创建后尚未启动。</p><h2 id="可运行runable"><a class="markdownIt-Anchor" href="多线程#可运行runable"></a> 可运行（RUNABLE）<a href="多线程#可运行runable"></a></h2><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p><h2 id="阻塞blocked"><a class="markdownIt-Anchor" href="多线程#阻塞blocked"></a> 阻塞（BLOCKED）<a href="多线程#阻塞blocked"></a></h2><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</p><h2 id="无限期等待waiting"><a class="markdownIt-Anchor" href="多线程#无限期等待waiting"></a> 无限期等待（WAITING）<a href="多线程#无限期等待waiting"></a></h2><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></div></div><h2 id="限期等待timed_waiting"><a class="markdownIt-Anchor" href="多线程#限期等待timed_waiting"></a> 限期等待（TIMED_WAITING）<a href="多线程#限期等待timed_waiting"></a></h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></div></div><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h2 id="死亡terminated"><a class="markdownIt-Anchor" href="多线程#死亡terminated"></a> 死亡（TERMINATED）<a href="多线程#死亡terminated"></a></h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h1 id="juc-aqs"><a class="markdownIt-Anchor" href="多线程#juc-aqs"></a> J.U.C - AQS<a href="多线程#juc-aqs"></a></h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="countdownlatch"><a class="markdownIt-Anchor" href="多线程#countdownlatch"></a> CountDownLatch<a href="多线程#countdownlatch"></a></h2><p>用来控制一个或者多个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><p><img src="/Users/ng/Documents/java1.8/pictures/CountDownLatch.png" alt="CountDownLatch" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></div></figure><h2 id="cyclicbarrier"><a class="markdownIt-Anchor" href="多线程#cyclicbarrier"></a> CyclicBarrier<a href="多线程#cyclicbarrier"></a></h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><img src="/Users/ng/Documents/java1.8/pictures/CyclicBarrier.png" alt="CyclicBarrier" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></div></figure><h2 id="semaphore"><a class="markdownIt-Anchor" href="多线程#semaphore"></a> Semaphore<a href="多线程#semaphore"></a></h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></div></figure><h1 id="juc-其它组件"><a class="markdownIt-Anchor" href="多线程#juc-其它组件"></a> J.U.C - 其它组件<a href="多线程#juc-其它组件"></a></h1><h2 id="futuretask"><a class="markdownIt-Anchor" href="多线程#futuretask"></a> FutureTask<a href="多线程#futuretask"></a></h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other task is running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></div></figure><h2 id="blockingqueue"><a class="markdownIt-Anchor" href="多线程#blockingqueue"></a> BlockingQueue<a href="多线程#blockingqueue"></a></h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li><strong>优先级队列</strong> ：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></div></figure><h2 id="forkjoin"><a class="markdownIt-Anchor" href="多线程#forkjoin"></a> ForkJoin<a href="多线程#forkjoin"></a></h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></div></figure><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><p><img src="/Users/ng/Documents/java1.8/pictures/ForkJoinPool.png" alt="ForkJoinPool" class="article-img"></p><h1 id="线程不安全示例"><a class="markdownIt-Anchor" href="多线程#线程不安全示例"></a> 线程不安全示例<a href="多线程#线程不安全示例"></a></h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">997</span></span><br></pre></td></tr></table></div></figure><h1 id="java-内存模型"><a class="markdownIt-Anchor" href="多线程#java-内存模型"></a> Java 内存模型<a href="多线程#java-内存模型"></a></h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h2 id="主内存与工作内存"><a class="markdownIt-Anchor" href="多线程#主内存与工作内存"></a> 主内存与工作内存<a href="多线程#主内存与工作内存"></a></h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt="主内存和工作内存" class="article-img"></p><h2 id="内存间交互操作"><a class="markdownIt-Anchor" href="多线程#内存间交互操作"></a> 内存间交互操作<a href="多线程#内存间交互操作"></a></h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="内存间交互操作" class="article-img"></p><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h2 id="内存模型三大特性"><a class="markdownIt-Anchor" href="多线程#内存模型三大特性"></a> 内存模型三大特性<a href="多线程#内存模型三大特性"></a></h2><h3 id="1-原子性"><a class="markdownIt-Anchor" href="多线程#1-原子性"></a> 1. 原子性<a href="多线程#1-原子性"></a></h3><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><p><img src="/Users/ng/Documents/java1.8/pictures/int%E5%8E%9F%E5%AD%90%E6%80%A7.jpeg" alt="int原子性" class="article-img"></p><p>AtomicInteger 能保证多个线程修改的原子性。</p><p><img src="/Users/ng/Documents/java1.8/pictures/AtomicInteger.jpeg" alt="AtomicInteger" class="article-img"></p><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicExample example = <span class="keyword">new</span> AtomicExample(); <span class="comment">// 只修改这条语句</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></div></figure><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicSynchronizedExample example = <span class="keyword">new</span> AtomicSynchronizedExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></div></figure><h3 id="2-可见性"><a class="markdownIt-Anchor" href="多线程#2-可见性"></a> 2. 可见性<a href="多线程#2-可见性"></a></h3><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><h3 id="3-有序性"><a class="markdownIt-Anchor" href="多线程#3-有序性"></a> 3. 有序性<a href="多线程#3-有序性"></a></h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h2 id="先行发生原则"><a class="markdownIt-Anchor" href="多线程#先行发生原则"></a> 先行发生原则<a href="多线程#先行发生原则"></a></h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h3 id="1-单一线程原则"><a class="markdownIt-Anchor" href="多线程#1-单一线程原则"></a> 1. 单一线程原则<a href="多线程#1-单一线程原则"></a></h3><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><h3 id="2-管程锁定规则"><a class="markdownIt-Anchor" href="多线程#2-管程锁定规则"></a> 2. 管程锁定规则<a href="多线程#2-管程锁定规则"></a></h3><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><h3 id="3-volatile-变量规则"><a class="markdownIt-Anchor" href="多线程#3-volatile-变量规则"></a> 3. volatile 变量规则<a href="多线程#3-volatile-变量规则"></a></h3><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><h3 id="4-线程启动规则"><a class="markdownIt-Anchor" href="多线程#4-线程启动规则"></a> 4. 线程启动规则<a href="多线程#4-线程启动规则"></a></h3><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><h3 id="5-线程加入规则"><a class="markdownIt-Anchor" href="多线程#5-线程加入规则"></a> 5. 线程加入规则<a href="多线程#5-线程加入规则"></a></h3><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><p><img src="/Users/ng/Documents/java1.8/pictures/join%E6%96%B9%E6%B3%95.png" alt="join方法" class="article-img"></p><h3 id="6-线程中断规则"><a class="markdownIt-Anchor" href="多线程#6-线程中断规则"></a> 6. 线程中断规则<a href="多线程#6-线程中断规则"></a></h3><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h3 id="7-对象终结规则"><a class="markdownIt-Anchor" href="多线程#7-对象终结规则"></a> 7. 对象终结规则<a href="多线程#7-对象终结规则"></a></h3><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><h3 id="8-传递性"><a class="markdownIt-Anchor" href="多线程#8-传递性"></a> 8. 传递性<a href="多线程#8-传递性"></a></h3><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h1 id="线程安全"><a class="markdownIt-Anchor" href="多线程#线程安全"></a> 线程安全<a href="多线程#线程安全"></a></h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><h2 id="不可变"><a class="markdownIt-Anchor" href="多线程#不可变"></a> 不可变<a href="多线程#不可变"></a></h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="number">1457</span>)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:<span class="number">9</span>)</span><br></pre></td></tr></table></div></figure><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="互斥同步-2"><a class="markdownIt-Anchor" href="多线程#互斥同步-2"></a> 互斥同步<a href="多线程#互斥同步-2"></a></h2><p>synchronized 和 ReentrantLock。</p><h2 id="非阻塞同步"><a class="markdownIt-Anchor" href="多线程#非阻塞同步"></a> 非阻塞同步<a href="多线程#非阻塞同步"></a></h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><h3 id="cas"><a class="markdownIt-Anchor" href="多线程#cas"></a> CAS<a href="多线程#cas"></a></h3><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h3 id="atomicinteger"><a class="markdownIt-Anchor" href="多线程#atomicinteger"></a> AtomicInteger<a href="多线程#atomicinteger"></a></h3><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="aba"><a class="markdownIt-Anchor" href="多线程#aba"></a> ABA<a href="多线程#aba"></a></h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h2 id="无同步方案"><a class="markdownIt-Anchor" href="多线程#无同步方案"></a> 无同步方案<a href="多线程#无同步方案"></a></h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h3 id="栈封闭"><a class="markdownIt-Anchor" href="多线程#栈封闭"></a> 栈封闭<a href="多线程#栈封闭"></a></h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></div></figure><h3 id="线程本地存储thread-local-storage"><a class="markdownIt-Anchor" href="多线程#线程本地存储thread-local-storage"></a> 线程本地存储（Thread Local Storage）<a href="多线程#线程本地存储thread-local-storage"></a></h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></div></figure><p>为了理解 ThreadLocal，先看以下代码：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>它所对应的底层结构图为：</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.png" alt="线程本地存储" class="article-img"></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></div></figure><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>get() 方法类似。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h3 id="可重入代码reentrant-code"><a class="markdownIt-Anchor" href="多线程#可重入代码reentrant-code"></a> 可重入代码（Reentrant Code）<a href="多线程#可重入代码reentrant-code"></a></h3><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h1 id="锁优化"><a class="markdownIt-Anchor" href="多线程#锁优化"></a> 锁优化<a href="多线程#锁优化"></a></h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h2 id="自旋锁"><a class="markdownIt-Anchor" href="多线程#自旋锁"></a> 自旋锁<a href="多线程#自旋锁"></a></h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a class="markdownIt-Anchor" href="多线程#锁消除"></a> 锁消除<a href="多线程#锁消除"></a></h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h2 id="锁粗化"><a class="markdownIt-Anchor" href="多线程#锁粗化"></a> 锁粗化<a href="多线程#锁粗化"></a></h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h2 id="轻量级锁"><a class="markdownIt-Anchor" href="多线程#轻量级锁"></a> 轻量级锁<a href="多线程#轻量级锁"></a></h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p><img src="/Users/ng/Documents/java1.8/pictures/MarkWord.png" alt="" class="article-img"></p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p><img src="/Users/ng/Documents/java1.8/pictures/LockRecord.png" alt="LockRecord" class="article-img"></p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="轻量级锁" class="article-img"></p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h2 id="偏向锁"><a class="markdownIt-Anchor" href="多线程#偏向锁"></a> 偏向锁<a href="多线程#偏向锁"></a></h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E5%81%8F%E5%90%91%E9%94%81.jpeg" alt="偏向锁" class="article-img"></p><h1 id="多线程开发良好的实践"><a class="markdownIt-Anchor" href="多线程#多线程开发良好的实践"></a> 多线程开发良好的实践<a href="多线程#多线程开发良好的实践"></a></h1><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;多线程#使用线程&quot;&gt;&lt;/a&gt; 使用线程&lt;a href=&quot;多线程#使用线程&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;有三种使用线程的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现 Runnable 接口；
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring&amp;mybatis/Dubbo</title>
    <link href="ilucia.github.io/spring&amp;mybatis/Dubbo/"/>
    <id>ilucia.github.io/spring&amp;mybatis/Dubbo/</id>
    <published>2022-04-27T15:24:01.747Z</published>
    <updated>2022-04-27T15:24:01.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dubbo"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#dubbo"></a> Dubbo<a href="spring&mybatis/Dubbo#dubbo"></a></h1><h3 id="作用"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#作用"></a> <strong>作用</strong><a href="spring&mybatis/Dubbo#作用"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/Dubbo%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86.jpeg" alt="" class="article-img"></p><h3 id="架构"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#架构"></a> <strong>架构</strong><a href="spring&mybatis/Dubbo#架构"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/dubbo-architecture.jpg" alt="" class="article-img"></p><h4 id="节点角色说明"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#节点角色说明"></a> 节点角色说明<a href="spring&mybatis/Dubbo#节点角色说明"></a></h4><div class="article-bounded"><div class="article-table"><table><thead><tr><th>节点</th><th>角色说明</th></tr></thead><tbody><tr><td>Provider</td><td>暴露服务的服务提供方</td></tr><tr><td>Consumer</td><td>调用远程服务的服务消费方</td></tr><tr><td>Registry</td><td>服务注册与发现的注册中心</td></tr><tr><td>Monitor</td><td>统计服务的调用次数和调用时间的监控中心</td></tr><tr><td>Container</td><td>服务运行容器</td></tr></tbody></table></div></div><p>看了这几个概念后似乎发现，其实 Dubbo 的架构也是很简单的（其实现细节是复杂的），为什么这么说呢，有没有发现，其实很像<strong>生产者-消费者</strong>模型。只是在这种模型上，加上了<strong>注册中心和监控中心</strong>，用于管理提供方提供的<strong>url</strong>，以及管理整个过程。</p><p>那么，整个发布-订阅的过程就非常的简单了。</p><ul><li>启动容器，加载，<strong>运行服务提供者</strong>。</li><li>服务提供者在启动时，在注册中心<strong>发布注册</strong>自己提供的<strong>服务</strong>。</li><li>服务消费者在启动时，在注册中心<strong>订阅</strong>自己所需的<strong>服务</strong>。</li></ul><p>如果考虑<strong>失败或变更</strong>的情况，就需要考虑下面的过程。</p><ul><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="dubbo项目构建"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#dubbo项目构建"></a> Dubbo项目构建<a href="spring&mybatis/Dubbo#dubbo项目构建"></a></h2><h3 id="基础"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#基础"></a> <strong>基础</strong><a href="spring&mybatis/Dubbo#基础"></a></h3><h4 id="服务端"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#服务端"></a> 服务端<a href="spring&mybatis/Dubbo#服务端"></a></h4><p>首先，我们先把服务端的接口写好，因为其实 dubbo 的作用简单来说就是给消费端提供接口。</p><h5 id="接口定义"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#接口定义"></a> 接口定义<a href="spring&mybatis/Dubbo#接口定义"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml方式服务提供者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProviderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">SayHello</span><span class="params">(String word)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个接口非常简单，只是包含一个 SayHello 的方法。</p><p>接着，定义它的实现类。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml方式服务提供者实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProviderService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHello</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这样我们就把我们的接口写好了，那么我们应该怎么将我们的服务暴露出去呢？</p><h4 id="导入-maven-依赖"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#导入-maven-依赖"></a> 导入 maven 依赖<a href="spring&mybatis/Dubbo#导入-maven-依赖"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ouyangsihai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.32.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>这里使用的 dubbo 的版本是 <code>2.6.6</code> ，需要注意的是，如果你只导入 dubbo 的包的时候是<strong>会报错</strong>的，<strong>找不到 netty 和 curator 的依赖</strong>，所以，在这里我们需要把这两个的依赖加上，就不会报错了。</p><p>另外，这里我们使用 zookeeper 作为注册中心。</p><p>到目前为止，dubbo 需要的环境就已经可以了，下面，我们就把上面刚刚定义的接口暴露出去。</p><h5 id="暴露接口xml-配置方法"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#暴露接口xml-配置方法"></a> 暴露接口（xml 配置方法）<a href="spring&mybatis/Dubbo#暴露接口xml-配置方法"></a></h5><p>首先，我们在我们项目的 resource 目录下<strong>创建 META-INF.spring 包</strong>，然后再创建 <strong>provider.xml</strong> 文件，名字可以任取哦，如下图。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LTJjNDdmODRjOTYwZmQwMWYucG5n" alt="img" class="article-img"></p><p>​</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"provider"</span> <span class="attr">owner</span>=<span class="string">"sihai"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.enable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.accept.foreign.ip"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"55555"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address="N/A"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"N/A"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前服务发布所依赖的协议；webserovice、Thrift、Hessain、http--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">"providerService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Bean bean定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"providerService"</span> <span class="attr">class</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>① 上面的文件其实就是类似 spring 的配置文件，而且，dubbo 底层就是 spring。<br>② <strong>节点：dubbo:application</strong><br>就是整个项目在分布式架构中的唯一名称，可以在 <code>name</code> 属性中配置，另外还可以配置 <code>owner</code> 字段，表示属于谁。<br>下面的参数是可以不配置的，这里配置是因为出现了端口的冲突，所以配置。<br>③ <strong>节点：dubbo:monitor</strong><br>监控中心配置， 用于配置连接监控中心相关信息，可以不配置，不是必须的参数。<br>④ <strong>节点：dubbo:registry</strong><br>配置注册中心的信息，比如，这里我们可以配置 zookeeper 作为我们的注册中心。<code>address</code> 是注册中心的地址，这里我们配置的是 <code>N/A</code> 表示由 dubbo 自动分配地址。或者说是一种直连的方式，不通过注册中心。<br>⑤ <strong>节点：dubbo:protocol</strong><br>服务发布的时候 dubbo 依赖什么协议，可以配置 dubbo、webserovice、Thrift、Hessain、http等协议。<br>⑥ <strong>节点：dubbo:service</strong><br>这个节点就是我们的重点了，当我们服务发布的时候，我们就是通过这个配置将我们的服务发布出去的。<code>interface</code> 是接口的包路径，<code>ref</code> 是第 ⑦ 点配置的接口的 bean。<br>⑦ 最后，我们需要像配置 spring 的接口一样，配置接口的 bean。</p><p>到这一步，关于服务端的配置就完成了，下面我们通过 <code>main 方法</code>将接口发布出去。</p><h5 id="发布接口"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#发布接口"></a> 发布接口<a href="spring&mybatis/Dubbo#发布接口"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ServiceConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.container.Main;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml方式启动</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//加载xml配置文件启动</span></span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"META-INF/spring/provider.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>发布接口非常简单，因为 dubbo 底层就是依赖 spring 的，所以，我们只需要通过 <code>ClassPathXmlApplicationContext</code> 拿到我们刚刚配置好的 xml ，然后调用 <code>context.start()</code> 方法就启动了。</p><p>看到下面的截图，就算是启动成功了，接口也就发布出去了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWJjZWQ1NTdkNWVjMjNjMjEucG5n" alt="img"></p><p>你以为到这里就结束了了，并不是的，我们拿到 <strong>dubbo 暴露出去的 url</strong>分析分析。</p><h5 id="dubbo-暴露的-url"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#dubbo-暴露的-url"></a> <strong>dubbo 暴露的 url</strong><a href="spring&mybatis/Dubbo#dubbo-暴露的-url"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService?anyhost=true&amp;application=provider&amp;bean.name=com.sihai.dubbo.provider.service.ProviderService&amp;bind.ip=192.168.234.1&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.sihai.dubbo.provider.service.ProviderService&amp;methods=SayHello&amp;owner=sihai&amp;pid=8412&amp;qos.accept.foreign.ip=false&amp;qos.enable=true&amp;qos.port=55555&amp;side=provider&amp;timestamp=1562077289380</span><br></pre></td></tr></table></div></figure><h5 id="分析"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#分析"></a> <strong>分析</strong><a href="spring&mybatis/Dubbo#分析"></a></h5><p>① 首先，在形式上我们发现，其实这么牛逼的 dubbo 也是用<strong>类似于 http 的协议</strong>发布自己的服务的，只是这里我们用的是 <strong>dubbo 协议</strong>。<br>② <code>dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService</code><br>上面这段链接就是 <code>?</code> 之前的链接，构成：<strong>协议://ip:端口/接口</strong>。发现是不是也没有什么神秘的。<br>③ <code>anyhost=true&amp;application=provider&amp;bean.name=com.sihai.dubbo.provider.service.ProviderService&amp;bind.ip=192.168.234.1&amp;bind.port=20880&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.sihai.dubbo.provider.service.ProviderService&amp;methods=SayHello&amp;owner=sihai&amp;pid=8412&amp;qos.accept.foreign.ip=false&amp;qos.enable=true&amp;qos.port=55555&amp;side=provider&amp;timestamp=1562077289380</code><br><code>?</code> 之后的字符串，分析后你发现，这些都是刚刚在 <code>provider.xml</code> 中配置的字段，然后通过 <code>&amp;</code> 拼接而成的，闻到了 <code>http</code> 的香味了吗？</p><p>终于，dubbo 服务端入门了。下面我们看看拿到了 url 后，怎么消费呢？</p><h4 id="消费端"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#消费端"></a> 消费端<a href="spring&mybatis/Dubbo#消费端"></a></h4><p>上面提到，我们在服务端提供的只是点对点的方式提供服务，并没有使用注册中心，所以，下面的配置也是会有一些不一样的。</p><h5 id="消费端环境配置"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#消费端环境配置"></a> 消费端环境配置<a href="spring&mybatis/Dubbo#消费端环境配置"></a></h5><p>首先，我们在消费端的 resource 下建立配置文件 <code>consumer.xml</code>。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LTQ4ODcxZjFiYzkxNGJhODMucG5n" alt="img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer"</span> <span class="attr">owner</span>=<span class="string">"sihai"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"N/A"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address="zookeeper://localhost:2181" check="false"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生成一个远程服务的调用代理--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"providerService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">url</span>=<span class="string">"dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:reference id="providerService"</span></span><br><span class="line"><span class="comment">                     interface="com.sihai.dubbo.provider.service.ProviderService"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p><strong>分析</strong></p><p>① 发现这里的 <code>dubbo:application</code> 和 <code>dubbo:registry</code> 是一致的。<br>② <code>dubbo:reference</code> ：我们这里采用<strong>点对点</strong>的方式，所以，需要配置在服务端暴露的 url 。</p><h5 id="maven-依赖"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#maven-依赖"></a> maven 依赖<a href="spring&mybatis/Dubbo#maven-依赖"></a></h5><p>和服务端一样</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ouyangsihai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-consumer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ouyangsihai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dubbo --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.zookeeper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zookeeper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.101tec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zkclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.32.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h5 id="调用服务"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#调用服务"></a> 调用服务<a href="spring&mybatis/Dubbo#调用服务"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ReferenceConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xml的方式调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ClassPathXmlApplicationContext context=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"consumer.xml"</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        ProviderService providerService = (ProviderService) context.getBean(<span class="string">"providerService"</span>);</span><br><span class="line">        String str = providerService.SayHello(<span class="string">"hello"</span>);</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里和服务端的发布如出一辙。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWE1ZjdhNjgxMjNmNjFlZWQucG5n" alt="img"><br>如此，我们就成功调用接口了。</p><h3 id="加入-zookeeper-作为注册中心"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#加入-zookeeper-作为注册中心"></a> 加入 zookeeper 作为注册中心<a href="spring&mybatis/Dubbo#加入-zookeeper-作为注册中心"></a></h3><p>在前面的案例中，我们没有使用任何的注册中心，而是用一种直连的方式进行的。但是，实际上很多时候，我们都是使用 dubbo + zookeeper 的方式，使用 zookeeper 作为注册中心，这里，我们就介绍一下 zookeeper 作为注册中心的使用方法。</p><p>这里，我们在前面的入门实例中进行改造。</p><h4 id="服务端-2"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#服务端-2"></a> 服务端<a href="spring&mybatis/Dubbo#服务端-2"></a></h4><p>在服务端中，我们只需要修改 provider.xml 即可。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"provider"</span> <span class="attr">owner</span>=<span class="string">"sihai"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.enable"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.accept.foreign.ip"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dubbo:parameter</span> <span class="attr">key</span>=<span class="string">"qos.port"</span> <span class="attr">value</span>=<span class="string">"55555"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dubbo:application</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">"registry"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address="N/A"/&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://localhost:2181"</span> <span class="attr">check</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前服务发布所依赖的协议；webserovice、Thrift、Hessain、http--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">"providerService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--Bean bean定义--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"providerService"</span> <span class="attr">class</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderServiceImpl"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>重点关注这句话</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://localhost:2181"</span> /&gt;</span></span><br></pre></td></tr></table></div></figure><p>在 address 中，使用我们的 zookeeper 的地址。</p><p>如果是 <strong>zookeeper 集群</strong>的话，使用下面的方式。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"192.168.11.129:2181,192.168.11.137:2181,192.168.11.138:2181"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>服务端的配置就好了，其他的跟 <strong>入门案例</strong> 一样。</p><h4 id="消费端-2"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#消费端-2"></a> 消费端<a href="spring&mybatis/Dubbo#消费端-2"></a></h4><p>跟服务端一样，在消费端，我们也只需要修改 <code>consumer.xml</code> 即可。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://code.alibabatech.com/schema/dubbo        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--当前项目在整个分布式架构里面的唯一名称，计算依赖关系的标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"consumer"</span> <span class="attr">owner</span>=<span class="string">"sihai"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--dubbo这个服务所要暴露的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点的方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:registry address="N/A" /&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://localhost:2181"</span> <span class="attr">check</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--生成一个远程服务的调用代理--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--点对点方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;dubbo:reference id="providerService"</span></span><br><span class="line"><span class="comment">                     interface="com.sihai.dubbo.provider.service.ProviderService"</span></span><br><span class="line"><span class="comment">                     url="dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService"/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"providerService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>① 注册中心配置跟服务端一样。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://localhost:2181"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>② dubbo:reference<br>由于我们这里使用 zookeeper 作为注册中心，所以，跟点对点的方式是不一样的，这里不再需要 dubbo 服务端提供的 url 了，只需要直接引用服务端提供的接口即可。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference id=&quot;providerService&quot;</span><br><span class="line">                     interface=&quot;com.sihai.dubbo.provider.service.ProviderService&quot;/&gt;</span><br></pre></td></tr></table></div></figure><p>好了，消费端也配置好了，这样就可以使用<strong>修改的入门案例</strong>，重新启动运行了。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWQ3OTAxMjAwMTMxYTdkM2YucG5n" alt="img" class="article-img"></p><p>同样成功了。</p><p>这时候的区别在于，<strong>将 dubbo 发布的 url 注册到了 zookeeper，消费端从 zookeeper 消费，zookeeper 相当于一个中介，给消费者提供服务。</strong></p><h3 id="注解配置方式"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#注解配置方式"></a> 注解配置方式<a href="spring&mybatis/Dubbo#注解配置方式"></a></h3><p>注解配置方式还是需要了解一下的，现在微服务都倾向于这种方式，这也是以后发展的趋势，0 配置应该是这几年的趋势。</p><p>那么如何对 dubbo 使用注解的方式呢？我们先看服务端。</p><h4 id="服务端-3"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#服务端-3"></a> 服务端<a href="spring&mybatis/Dubbo#服务端-3"></a></h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWEwNTM0YWNkMWMwNGU1NTAucG5n" alt="img" class="article-img"></p><h5 id="第一步定义接口及实现类在上面的截图中的-annotation-包下"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#第一步定义接口及实现类在上面的截图中的-annotation-包下"></a> <strong>第一步：定义接口及实现类</strong>，在上面的截图中的 annotation 包下<a href="spring&mybatis/Dubbo#第一步定义接口及实现类在上面的截图中的-annotation-包下"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider.service.annotation;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProviderServiceAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">SayHelloAnnotation</span><span class="params">(String word)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider.service.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span>(timeout = <span class="number">5000</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderServiceImplAnnotation</span> <span class="keyword">implements</span> <span class="title">ProviderServiceAnnotation</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">SayHelloAnnotation</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> word;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>@Service</strong></p><p><code>@Service</code> 用来配置 Dubbo 的服务提供方。</p><h5 id="第二步组装服务提供方"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#第二步组装服务提供方"></a> <strong>第二步：组装服务提供方。</strong><a href="spring&mybatis/Dubbo#第二步组装服务提供方"></a></h5><p>通过 Spring 中 <code>Java Config</code> 的技术（<code>@Configuration</code>）和 annotation 扫描（<code>@EnableDubbo</code>）来发现、组装、并向外提供 Dubbo 的服务。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProtocolConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ProviderConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.sihai.dubbo.provider.service.annotation"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #1 服务提供者信息配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProviderConfig <span class="title">providerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProviderConfig providerConfig = <span class="keyword">new</span> ProviderConfig();</span><br><span class="line">        providerConfig.setTimeout(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">return</span> providerConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #2 分布式应用信息配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-provider"</span>);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #3 注册中心信息配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">"localhost"</span>);</span><br><span class="line">        registryConfig.setPort(<span class="number">2181</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// #4 使用协议配置，这里使用 dubbo</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolConfig <span class="title">protocolConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProtocolConfig protocolConfig = <span class="keyword">new</span> ProtocolConfig();</span><br><span class="line">        protocolConfig.setName(<span class="string">"dubbo"</span>);</span><br><span class="line">        protocolConfig.setPort(<span class="number">20880</span>);</span><br><span class="line">        <span class="keyword">return</span> protocolConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>分析</strong></p><ul><li>通过 @EnableDubbo 指定在<code>com.sihai.dubbo.provider.service.annotation</code> 下扫描所有标注有 <code>@Service</code> 的类</li><li>通过 <code>@Configuration</code> 将 <code>DubboConfiguration</code> 中所有的 <code>@Bean</code> 通过 <code>Java Config</code> 的方式组装出来并注入给 Dubbo 服务，也就是标注有 <code>@Service</code> 的类。这其中就包括了：<ul><li>ProviderConfig：服务提供方配置</li><li>ApplicationConfig：应用配置</li><li>RegistryConfig：注册中心配置</li><li>ProtocolConfig：协议配置</li></ul></li></ul><h5 id="第三步启动服务"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#第三步启动服务"></a> <strong>第三步：启动服务</strong><a href="spring&mybatis/Dubbo#第三步启动服务"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.DubboComponentScan;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.configuration.DubboConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> sun.applet.Main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解启动方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppAnnotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(DubboConfiguration.class); </span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>发现输出下面信息就表示 success 了。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LTE0MmNlZTM0YTcxN2MwMmQucG5n" alt="img"></p><h4 id="消费端-3"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#消费端-3"></a> 消费端<a href="spring&mybatis/Dubbo#消费端-3"></a></h4><p>同样我们下看看消费端的工程，有一个感性认识。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LTQyM2ZjYmFjZWY1NThiZWEucG5n" alt="图片.png"></p><h5 id="第一步引用服务"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#第一步引用服务"></a> <strong>第一步：引用服务</strong><a href="spring&mybatis/Dubbo#第一步引用服务"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer.Annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.annotation.Reference;</span><br><span class="line"><span class="keyword">import</span> com.sihai.dubbo.provider.service.annotation.ProviderServiceAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解方式的service</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"annotatedConsumer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerAnnotationService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Reference</span></span><br><span class="line">    <span class="keyword">private</span> ProviderServiceAnnotation providerServiceAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> providerServiceAnnotation.SayHelloAnnotation(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在 <code>ConsumerAnnotationService</code> 类中，通过 <code>@Reference</code> 引用服务端提供的类，然后通过方法调用这个类的方式，给消费端提供接口。<br>**注意：**如果这里找不到 <code>ProviderServiceAnnotation</code> 类，请在服务端先把服务端工程用 <code>Maven intall</code> 一下，然后将服务端的依赖放到消费端的 <code>pom</code> 中。如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ouyangsihai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo-provider<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h5 id="第二步组装服务消费者"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#第二步组装服务消费者"></a> <strong>第二步：组装服务消费者</strong><a href="spring&mybatis/Dubbo#第二步组装服务消费者"></a></h5><p>这一步和服务端是类似的，这里就不在重复了。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sihai.dubbo.consumer.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ApplicationConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.ConsumerConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.RegistryConfig;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.config.spring.context.annotation.EnableDubbo;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注解配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.sihai.dubbo.consumer.Annotation"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"com.sihai.dubbo.consumer.Annotation"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 应用配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationConfig <span class="title">applicationConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationConfig applicationConfig = <span class="keyword">new</span> ApplicationConfig();</span><br><span class="line">        applicationConfig.setName(<span class="string">"dubbo-annotation-consumer"</span>);</span><br><span class="line">        Map&lt;String, String&gt; stringStringMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        stringStringMap.put(<span class="string">"qos.enable"</span>,<span class="string">"true"</span>);</span><br><span class="line">        stringStringMap.put(<span class="string">"qos.accept.foreign.ip"</span>,<span class="string">"false"</span>);</span><br><span class="line">        stringStringMap.put(<span class="string">"qos.port"</span>,<span class="string">"33333"</span>);</span><br><span class="line">        applicationConfig.setParameters(stringStringMap);</span><br><span class="line">        <span class="keyword">return</span> applicationConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 服务消费者配置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConsumerConfig <span class="title">consumerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ConsumerConfig consumerConfig = <span class="keyword">new</span> ConsumerConfig();</span><br><span class="line">        consumerConfig.setTimeout(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> consumerConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 配置注册中心</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RegistryConfig <span class="title">registryConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RegistryConfig registryConfig = <span class="keyword">new</span> RegistryConfig();</span><br><span class="line">        registryConfig.setProtocol(<span class="string">"zookeeper"</span>);</span><br><span class="line">        registryConfig.setAddress(<span class="string">"localhost"</span>);</span><br><span class="line">        registryConfig.setPort(<span class="number">2181</span>);</span><br><span class="line">        <span class="keyword">return</span> registryConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="第三步发起远程调用"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#第三步发起远程调用"></a> <strong>第三步：发起远程调用</strong><a href="spring&mybatis/Dubbo#第三步发起远程调用"></a></h5><p>在 <code>main</code> 方法中通过启动一个 <code>Spring Context</code>，从其中查找到组装好的 Dubbo 的服务消费者，并发起一次远程调用。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package com.sihai.dubbo.consumer;</span><br><span class="line"></span><br><span class="line">import com.sihai.dubbo.consumer.Annotation.ConsumerAnnotationService;</span><br><span class="line">import com.sihai.dubbo.consumer.configuration.ConsumerConfiguration;</span><br><span class="line">import com.sihai.dubbo.provider.service.ProviderService;</span><br><span class="line">import org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 注解方式启动</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class AppAnnotation</span><br><span class="line">&#123;</span><br><span class="line">    public static void main( String[] args ) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(ConsumerConfiguration.class); </span><br><span class="line">        context.start(); // 启动</span><br><span class="line">        ConsumerAnnotationService consumerAnnotationService = context.getBean(ConsumerAnnotationService.class); </span><br><span class="line">        String hello = consumerAnnotationService.doSayHello(&quot;annotation&quot;); // 调用方法</span><br><span class="line">        System.out.println(&quot;result: &quot; + hello); // 输出结果</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="结果"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#结果"></a> <strong>结果</strong><a href="spring&mybatis/Dubbo#结果"></a></h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWI4NWRmZjhhMmVmZTUxNzkucG5n" alt="img" class="article-img"></p><h2 id="常用场景"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#常用场景"></a> 常用场景<a href="spring&mybatis/Dubbo#常用场景"></a></h2><p>在下面的讲解中，都会是以 <code>xml</code> 配置的方式来讲解的，这也是 dubbo 官方比较推荐的方式。以下的操作都是在服务端的 <code>xml</code> 配置文件和消费端的配置文件来讲解的。</p><h3 id="启动时检查"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#启动时检查"></a> 启动时检查<a href="spring&mybatis/Dubbo#启动时检查"></a></h3><p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题，默认 `check=“true”。</p><p>但是，有的时候，我们并不是都需要启动时就检查的，比如测试的时候，我们是需要更快速的启动，所以，这种场景的时候，我们是需要关闭这个功能的。</p><p>下面，我们看看如何使用这个功能。</p><p>在服务端注册的时候（客户端注册时同样适用）；</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;localhost:2181,localhost:2182,localhost:2183&quot; check=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></div></figure><p>在客户端引用服务端服务的时候；</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">id</span>=<span class="string">"providerService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>就是这么简单，就是这么强！</p><h3 id="集群容错"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#集群容错"></a> 集群容错<a href="spring&mybatis/Dubbo#集群容错"></a></h3><p>dubbo 也是支持集群容错的，同时也有很多可选的方案，其中，默认的方案是 <code>failover</code>，也就是重试机制。</p><p>首先，我们先把所有的容错机制都整理一遍，然后再看看使用。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>集群模式</th><th>说明</th><th>使用方法</th></tr></thead><tbody><tr><td>Failover Cluster</td><td>失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=“2” 来设置重试次数(不含第一次)。</td><td>cluster=“xxx” xxx：集群模式名称 ，例如cluster=“failover”</td></tr><tr><td>Failfast Cluster</td><td>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</td><td></td></tr><tr><td>Failsafe Cluster</td><td>失败安全，出现异常时，直接忽略。</td><td></td></tr><tr><td>Failback Cluster</td><td>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</td><td></td></tr><tr><td>Forking Cluster</td><td>并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=“2” 来设置最大并行数。</td><td></td></tr><tr><td>Broadcast Cluster</td><td>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</td><td></td></tr></tbody></table></div></div><h5 id="使用实例"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#使用实例"></a> <strong>使用实例</strong><a href="spring&mybatis/Dubbo#使用实例"></a></h5><p>在发布服务或者引用服务的时候设置</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">"providerService"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">id</span>=<span class="string">"providerService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><h3 id="负载均衡"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#负载均衡"></a> 负载均衡<a href="spring&mybatis/Dubbo#负载均衡"></a></h3><p>负载均衡想必是一个再熟悉不过的概念了，所以，dubbo 支持也是再正常不过了，这里也总结一下 dubbo 支持的负载均衡的一些方案及使用方法。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>负载均衡模式</th><th>说明</th><th>使用方法</th></tr></thead><tbody><tr><td>Random LoadBalance</td><td>随机 按权重设置随机概率</td><td>&lt;dubbo:service loadbalance=“xxx”/&gt; xxx：负载均衡方法</td></tr><tr><td>RoundRobin LoadBalance</td><td>轮询 按公约后的权重设置轮询比率。</td><td></td></tr><tr><td>LeastActive LoadBalance</td><td>最少活跃调用数 相同活跃数的随机，活跃数指调用前后计数差。</td><td></td></tr><tr><td>ConsistentHash LoadBalance</td><td>一致性 Hash 相同参数的请求总是发到同一提供者。 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</td><td></td></tr></tbody></table></div></div><h3 id="直连提供者"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#直连提供者"></a> 直连提供者<a href="spring&mybatis/Dubbo#直连提供者"></a></h3><p>在开发及测试环境下，经常需要绕过注册中心，只测试指定服务提供者，所以，这种情况下，我们只需要直接连接服务端的地即可，其实，这种方法在前面的讲解已经使用到了，第一种讲解的方式就是这种方式，因为这种方式简单。</p><h5 id="使用"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#使用"></a> <strong>使用</strong><a href="spring&mybatis/Dubbo#使用"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"providerService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">url</span>=<span class="string">"dubbo://192.168.234.1:20880/com.sihai.dubbo.provider.service.ProviderService"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>说明：可以看到，只要在消费端在 <code>dubbo:reference</code> 节点使用 <code>url</code> 给出服务端的方法即可。</p><h3 id="只订阅"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#只订阅"></a> 只订阅<a href="spring&mybatis/Dubbo#只订阅"></a></h3><p>只订阅就是只能够订阅服务端的服务，而不能够注册。</p><p>引用官方的使用场景如下：</p><blockquote><p>为方便开发测试，经常会在线下共用一个所有服务可用的注册中心，这时，如果一个正在开发中的服务提供者注册，可能会影响消费者不能正常运行。<br>可以让服务提供者开发方，只订阅服务(开发的服务可能依赖其它服务)，而不注册正在开发的服务，通过直连测试正在开发的服务。</p></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">register</span>=<span class="string">"false"</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">address</span>=<span class="string">"localhost:2181,localhost:2182,localhost:2183"</span> <span class="attr">check</span>=<span class="string">"false"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="1-使用只订阅方式"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#1-使用只订阅方式"></a> <strong>① 使用只订阅方式</strong><a href="spring&mybatis/Dubbo#1-使用只订阅方式"></a></h4><p>当在服务提供端使用 <code>register=&quot;false&quot;</code> 的时候，我们使用下面的方式获取服务端的服务；</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:reference cluster=&quot;failover&quot; retries=&quot;2&quot; check=&quot;false&quot; id=&quot;providerService&quot;</span><br><span class="line">                     interface=&quot;com.sihai.dubbo.provider.service.ProviderService&quot;/&gt;</span><br></pre></td></tr></table></div></figure><p><strong>启动信息</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LWMwOTZiOTQ5MjNhZGMyMzEucG5n" alt="图片.png"><br>发现，这时候并不是向<code>注册中心 zookeeper</code> 注册，而只是做了<code>发布服务和启动netty</code>。</p><h4 id="2-不使用只订阅方式"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#2-不使用只订阅方式"></a> <strong>② 不使用只订阅方式</strong><a href="spring&mybatis/Dubbo#2-不使用只订阅方式"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry protocol=&quot;zookeeper&quot; address=&quot;localhost:2181,localhost:2182,localhost:2183&quot; check=&quot;false&quot;/&gt;</span><br></pre></td></tr></table></div></figure><p><strong>启动信息</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LTgxY2ViNjM4OWJhODdiOWEucG5n" alt="img"></p><p>可以发现，这里就向注册中心 zookeeper 注册了。</p><h3 id="只注册"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#只注册"></a> 只注册<a href="spring&mybatis/Dubbo#只注册"></a></h3><p>只注册正好跟前面的只订阅相反，这个时候可以向注册中心注册，但是，消费端却不能够读到服务。</p><h4 id="应用场景"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#应用场景"></a> <strong>应用场景</strong><a href="spring&mybatis/Dubbo#应用场景"></a></h4><blockquote><p>如果有两个镜像环境，两个注册中心，有一个服务只在其中一个注册中心有部署，另一个注册中心还没来得及部署，而两个注册中心的其它应用都需要依赖此服务。这个时候，可以让服务提供者方只注册服务到另一注册中心，而不从另一注册中心订阅服务。</p></blockquote><h4 id="使用说明"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#使用说明"></a> <strong>使用说明</strong><a href="spring&mybatis/Dubbo#使用说明"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry subscribe=&quot;false&quot; address=&quot;localhost:2181&quot;&gt;&lt;/dubbo:registry&gt;</span><br></pre></td></tr></table></div></figure><p>在服务端的 <code>dubbo:registry</code> 节点下使用 <code>subscribe=&quot;false&quot;</code> 来声明这个服务是只注册的服务。</p><p>这个时候消费端调用的时候是不能调用的。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODI0MDE2LThhYjI1MDIxZDY3N2Q5YjkucG5n" alt="img"></p><h3 id="多协议机制"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#多协议机制"></a> 多协议机制<a href="spring&mybatis/Dubbo#多协议机制"></a></h3><p>在前面我们使用的协议都是 dubbo 协议，但是 dubbo 除了支持这种协议外还支持其他的协议，比如，rmi、hessian等，另外，而且还可以用多种协议同时暴露一种服务。</p><h4 id="使用方法"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#使用方法"></a> <strong>使用方法</strong><a href="spring&mybatis/Dubbo#使用方法"></a></h4><p>一对一，一对多</p><h5 id="1-一种接口使用一种协议"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#1-一种接口使用一种协议"></a> <strong>① 一种接口使用一种协议</strong><a href="spring&mybatis/Dubbo#1-一种接口使用一种协议"></a></h5><p>先声明多种协议</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--当前服务发布所依赖的协议；webserovice、Thrift、Hessain、http--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"rmi"</span> <span class="attr">port</span>=<span class="string">"1099"</span> /&gt;</span></span><br></pre></td></tr></table></div></figure><p>然后在发布接口的时候使用具体协议</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">"providerService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">"providerService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>在输出日志中，就可以找到rmi发布的接口。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmi://192.168.234.1:1099/com.sihai.dubbo.provider.service.ProviderService?anyhost=true&amp;application=provider&amp;bean.name=com.sihai.dubbo.provider.service.ProviderService&amp;cluster=failover&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.sihai.dubbo.provider.service.ProviderService&amp;methods=SayHello&amp;owner=sihai&amp;pid=796&amp;retries=2&amp;side=provider&amp;timestamp=1564281053185, dubbo version: 2.6.6, current host: 192.168.234.1</span><br></pre></td></tr></table></div></figure><h5 id="2-一种接口使用多种协议"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#2-一种接口使用多种协议"></a> <strong>② 一种接口使用多种协议</strong><a href="spring&mybatis/Dubbo#2-一种接口使用多种协议"></a></h5><p>声明协议和上面的方式一样，在发布接口的时候有一点不一样。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service cluster=&quot;failover&quot; retries=&quot;2&quot;</span><br><span class="line">                   interface=&quot;com.sihai.dubbo.provider.service.ProviderService&quot;</span><br><span class="line">                   ref=&quot;providerService&quot; protocol=&quot;rmi,dubbo&quot;/&gt;</span><br></pre></td></tr></table></div></figure><p>**说明：**protocol属性，可以用<code>,</code>隔开，使用多种协议。</p><h3 id="多注册中心"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#多注册中心"></a> 多注册中心<a href="spring&mybatis/Dubbo#多注册中心"></a></h3><p>Dubbo 支持同一服务向多注册中心同时注册，或者不同服务分别注册到不同的注册中心上去，甚至可以同时引用注册在不同注册中心上的同名服务。</p><h4 id="服务端多注册中心发布服务"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#服务端多注册中心发布服务"></a> 服务端多注册中心发布服务<a href="spring&mybatis/Dubbo#服务端多注册中心发布服务"></a></h4><p>一个服务可以在不同的注册中心注册，当一个注册中心出现问题时，可以用其他的注册中心。</p><h5 id="注册"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#注册"></a> <strong>注册</strong><a href="spring&mybatis/Dubbo#注册"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--多注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">id</span>=<span class="string">"reg1"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">address</span>=<span class="string">"localhost:2181"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">id</span>=<span class="string">"reg2"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">address</span>=<span class="string">"localhost:2182"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">id</span>=<span class="string">"reg3"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">address</span>=<span class="string">"localhost:2183"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><h5 id="发布服务"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#发布服务"></a> <strong>发布服务</strong><a href="spring&mybatis/Dubbo#发布服务"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">"providerService"</span> <span class="attr">registry</span>=<span class="string">"reg1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">"providerService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span> <span class="attr">registry</span>=<span class="string">"reg2"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>**说明：**使用<code>registry=&quot;reg2&quot;</code>指定该接口使用的注册中心，同时也可以使用多个，用<code>，</code>隔开，例如，<code>registry=&quot;reg1,,reg2&quot;</code>。</p><h4 id="消费端多注册中心引用服务"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#消费端多注册中心引用服务"></a> 消费端多注册中心引用服务<a href="spring&mybatis/Dubbo#消费端多注册中心引用服务"></a></h4><p>首先，先向不同注册中心注册;</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--多注册中心--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">id</span>=<span class="string">"reg1"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">address</span>=<span class="string">"localhost:2181"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">id</span>=<span class="string">"reg2"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">address</span>=<span class="string">"localhost:2182"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">protocol</span>=<span class="string">"zookeeper"</span> <span class="attr">id</span>=<span class="string">"reg3"</span> <span class="attr">timeout</span>=<span class="string">"10000"</span> <span class="attr">address</span>=<span class="string">"localhost:2183"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>其次，不同的消费端服务引用使用不同的注册中心；</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">!--不同的服务使用不同的注册中心--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">id</span>=<span class="string">"providerService"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span> <span class="attr">registry</span>=<span class="string">"reg1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">id</span>=<span class="string">"providerService2"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span> <span class="attr">registry</span>=<span class="string">"reg2"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>**说明：**上面分别使用注册中心1和注册中心2。</p><h3 id="多版本"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#多版本"></a> 多版本<a href="spring&mybatis/Dubbo#多版本"></a></h3><p>不同的服务是有版本不同的，版本可以更新并且升级，同时，不同的版本之间是不可以调用的。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">ref</span>=<span class="string">"providerService"</span> <span class="attr">registry</span>=<span class="string">"reg1"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">cluster</span>=<span class="string">"failover"</span> <span class="attr">retries</span>=<span class="string">"2"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">interface</span>=<span class="string">"com.sihai.dubbo.provider.service.ProviderService"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">ref</span>=<span class="string">"providerService"</span> <span class="attr">protocol</span>=<span class="string">"rmi"</span> <span class="attr">registry</span>=<span class="string">"reg2"</span> <span class="attr">version</span>=<span class="string">"1.0.0"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><p>加入了版本控制。</p><h3 id="日志管理"><a class="markdownIt-Anchor" href="spring&mybatis/Dubbo#日志管理"></a> 日志管理<a href="spring&mybatis/Dubbo#日志管理"></a></h3><p>dubbo 也可以将日志信息记录或者保存到文件中的。</p><p>① 使用accesslog输出到log4j</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:protocol accesslog=&quot;true&quot; name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line">    &lt;dubbo:protocol accesslog=&quot;true&quot; name=&quot;rmi&quot; port=&quot;1099&quot; /&gt;</span><br></pre></td></tr></table></div></figure><p>② 输出到文件</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:protocol accesslog=&quot;http://localhost/log.txt&quot; name=&quot;dubbo&quot; port=&quot;20880&quot;/&gt;</span><br><span class="line">    &lt;dubbo:protocol accesslog=&quot;http://localhost/log2.txt&quot; name=&quot;rmi&quot; port=&quot;1099&quot; /&gt;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dubbo&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;spring&amp;mybatis/Dubbo#dubbo&quot;&gt;&lt;/a&gt; Dubbo&lt;a href=&quot;spring&amp;mybatis/Dubbo#dubbo&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h3 i
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring&amp;mybatis/Java Web</title>
    <link href="ilucia.github.io/spring&amp;mybatis/Java%20Web/"/>
    <id>ilucia.github.io/spring&amp;mybatis/Java%20Web/</id>
    <published>2022-04-27T15:24:01.747Z</published>
    <updated>2022-04-27T15:24:01.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="servlet"><a class="markdownIt-Anchor" href="spring&mybatis/Java Web#servlet"></a> Servlet<a href="spring&mybatis/Java Web#servlet"></a></h2><ul><li><p>Servlet其实就是一个<strong>遵循Servlet开发的java类</strong></p></li><li><p>Servlet是<strong>由服务器调用的，运行在服务器端</strong></p></li><li><p>Servlet带给我们最大的作用就是<strong>能够处理浏览器带来的HTTP请求，并返回一个响应给浏览器，从而实现浏览器和服务器的交互</strong></p></li></ul><h3 id="java-web目录结构"><a class="markdownIt-Anchor" href="spring&mybatis/Java Web#java-web目录结构"></a> Java Web目录结构<a href="spring&mybatis/Java Web#java-web目录结构"></a></h3><p>![Java Web目录结构](/Users/ng/Documents/spring&amp;mybatis/pictures/Java Web目录结构.png)</p><ul><li>bbs目录代表一个web应用</li><li>bbs目录下的html,jsp文件可以直接被浏览器访问</li><li>WEB-INF目录下的资源是不能直接被浏览器访问的</li><li>web.xml文件是web程序的主要配置文件</li><li>所有的classes文件都放在classes目录下</li><li>jar文件放在lib目录下</li></ul><h3 id="编写servlet程序"><a class="markdownIt-Anchor" href="spring&mybatis/Java Web#编写servlet程序"></a> 编写Servlet程序<a href="spring&mybatis/Java Web#编写servlet程序"></a></h3><ol><li>创建一个自定义类，实现Servlet接口</li><li>我们发现有5个方法需要重写，有init【初始化】，destroy【销毁】,service【服务】,ServletConfig【Servlet配置】,getServletInfo【Servlet信息</li><li>调用ServletResponse对象的方法向浏览器输出HelloWorld</li><li>配置xml文件，光写了Servlet是不行的，Tomcat还要知道浏览器怎么访问这个Servlet</li></ol><h4 id="servlet生命周期"><a class="markdownIt-Anchor" href="spring&mybatis/Java Web#servlet生命周期"></a> Servlet生命周期<a href="spring&mybatis/Java Web#servlet生命周期"></a></h4><ol><li><strong>加载Servlet。当Tomcat第一次访问Servlet的时候，Tomcat会负责创建Servlet的实例</strong></li><li><strong>初始化。当Servlet被实例化后，Tomcat会调用init()方法初始化这个对象</strong></li><li><strong>处理服务。当浏览器访问Servlet的时候，Servlet 会调用service()方法处理请求</strong></li><li><strong>销毁。当Tomcat关闭时或者检测到Servlet要从Tomcat删除的时候会自动调用destroy()方法，让该实例释放掉所占的资源。一个Servlet如果长时间不被使用的话，也会被Tomcat自动销毁</strong></li><li><strong>卸载。当Servlet调用完destroy()方法后，等待垃圾回收。如果有需要再次使用这个Servlet，会重新调用init()方法进行初始化操作</strong></li><li>简单总结：只要访问Servlet，service()就会被调用。init()只有第一次访问Servlet的时候才会被调用。destroy()只有在Tomcat关闭的时候才会被调用</li></ol><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/Servlet%E8%B0%83%E7%94%A8%E5%9B%BE.png" alt="Servlet调用图" class="article-img"></p><h4 id="继承httpservlet编写servlet程序"><a class="markdownIt-Anchor" href="spring&mybatis/Java Web#继承httpservlet编写servlet程序"></a> 继承HttpServlet编写Servlet程序<a href="spring&mybatis/Java Web#继承httpservlet编写servlet程序"></a></h4><ul><li>实现Servlet接口，要实现5个方法</li><li>而HttpServlet类已经实现了Servlet接口的所有方法，编写Servlet时，只需要继承HttpServlet，重写你需要的方法即可，并且它在原有Servlet接口上添加了一些与HTTP协议处理方法，它比Servlet接口的功能更为强大</li><li>idea创建Servlet的时候已经重写好了doGet()和doPost()方法</li></ul><h4 id="http协议"><a class="markdownIt-Anchor" href="spring&mybatis/Java Web#http协议"></a> HTTP协议<a href="spring&mybatis/Java Web#http协议"></a></h4><ul><li><strong>HTTP协议是客户端和服务器交互的一种通迅的格式</strong></li><li>当在浏览器中点击这个链接的时候，<strong>浏览器会向服务器发送一段文本</strong>，**告诉服务器请求打开的是哪一个网页。服务器收到请求后，就返回一段文本给浏览器，浏览器会将该文本解析，然后显示出来。**这段「文本」就是遵循HTTP协议规范的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;servlet&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;spring&amp;mybatis/Java Web#servlet&quot;&gt;&lt;/a&gt; Servlet&lt;a href=&quot;spring&amp;mybatis/Java Web#servlet&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring&amp;mybatis/Mybatis - MybatisPlus</title>
    <link href="ilucia.github.io/spring&amp;mybatis/Mybatis%20-%20MybatisPlus/"/>
    <id>ilucia.github.io/spring&amp;mybatis/Mybatis%20-%20MybatisPlus/</id>
    <published>2022-04-27T15:24:01.747Z</published>
    <updated>2022-04-27T15:24:01.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mybatis"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#mybatis"></a> Mybatis<a href="spring&mybatis/Mybatis - MybatisPlus#mybatis"></a></h2><h3 id="步骤"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#步骤"></a> 步骤<a href="spring&mybatis/Mybatis - MybatisPlus#步骤"></a></h3><h5 id="创建表"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#创建表"></a> 创建表<a href="spring&mybatis/Mybatis - MybatisPlus#创建表"></a></h5><h5 id="创建实体"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#创建实体"></a> 创建实体<a href="spring&mybatis/Mybatis - MybatisPlus#创建实体"></a></h5><h5 id="创建配置文件"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#创建配置文件"></a> 创建配置文件<a href="spring&mybatis/Mybatis - MybatisPlus#创建配置文件"></a></h5><ul><li><strong>创建mybatis的配置⽂件，配置数据库的信息</strong></li><li><strong>数据库我们可以配置多个，但是默认的只能⽤⼀个</strong></li></ul><h5 id="创建映射文件"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#创建映射文件"></a> 创建映射文件<a href="spring&mybatis/Mybatis - MybatisPlus#创建映射文件"></a></h5><ul><li>SQL语句在映射文件中</li></ul><h5 id="crud"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#crud"></a> CRUD<a href="spring&mybatis/Mybatis - MybatisPlus#crud"></a></h5><ul><li><p>create read update delete</p></li><li><p>insert/update/delete标签只是⼀个模板，在做操作时，其实是以SQL语句为核⼼的</p><ul><li>即在做增删改时，insert/update/delete标签可通⽤，</li></ul></li><li><p>但做查询时只能⽤select标签</p></li><li><p>我们提倡什么操作就⽤什么标签</p></li></ul><h4 id="创建工具类测试"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#创建工具类测试"></a> 创建工具类测试<a href="spring&mybatis/Mybatis - MybatisPlus#创建工具类测试"></a></h4><ul><li>Mybatis中的事务是默认开启的，因此我们在完成操作以后，需要我们⼿动去提交事务</li></ul><h3 id="扩展功能"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#扩展功能"></a> 扩展功能<a href="spring&mybatis/Mybatis - MybatisPlus#扩展功能"></a></h3><h4 id="创建dao"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#创建dao"></a> 创建DAO<a href="spring&mybatis/Mybatis - MybatisPlus#创建dao"></a></h4><h4 id="分页"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#分页"></a> 分页<a href="spring&mybatis/Mybatis - MybatisPlus#分页"></a></h4><h4 id="动态sql"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#动态sql"></a> 动态SQL<a href="spring&mybatis/Mybatis - MybatisPlus#动态sql"></a></h4><h5 id="动态查询"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#动态查询"></a> 动态查询<a href="spring&mybatis/Mybatis - MybatisPlus#动态查询"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--多条件查询【动态SQL】--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--会⾃动组合成⼀个正常的WHERE字句--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name值会从map中寻找--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByCondition"</span> <span class="attr">resultMap</span>=<span class="string">"studentMap"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">  select * from users</span><br><span class="line">  <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"uname!=null"</span>&gt;</span></span><br><span class="line">    and uname=#&#123;uname&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"uage!=null"</span>&gt;</span></span><br><span class="line">  and uage <span class="tag">&lt; #&#123;<span class="attr">uage</span>&#125;</span></span><br><span class="line">  &lt;/if&gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>查询名字为name，年龄小于age的人<ul><li>为null则代表该字段无条件</li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;User&gt; <span class="title">findByCondition</span><span class="params">(String name,Integer age)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//得到连接对象</span></span><br><span class="line">    SqlSession sqlSession = MybatisUtil.getSqlSession();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//映射⽂件的命名空间.SQL⽚段的ID，就可以调⽤对应的映射⽂件中的SQL</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 由于我们的参数超过了两个，⽽⽅法中只有⼀个Object参数收集</span></span><br><span class="line"><span class="comment">         * 因此我们可以使⽤Map集合来装载我们的参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        map.put(<span class="string">"uname"</span>, name);</span><br><span class="line">        map.put(<span class="string">"uage"</span>, age);</span><br><span class="line">        <span class="keyword">return</span> sqlSession.selectList(<span class="string">"findByCondition"</span>, map);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        sqlSession.rollback();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        MybatisUtil.closeSqlSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="choose-when-otherwise"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#choose-when-otherwise"></a> choose, when, otherwise<a href="spring&mybatis/Mybatis - MybatisPlus#choose-when-otherwise"></a></h2><p>有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><p>还是上面的例子，但是这次变为提供了&quot;title&quot;就按&quot;title&quot;查找，提供了&quot;author&quot;就按&quot;author&quot;查找，若两者都没有提供，就返回所有符合条件的BLOG（实际情况可能是由管理员按一定策略选出BLOG列表，而不是返回大量无意义的随机结果）。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG WHERE state = ‘ACTIVE’</span><br><span class="line">  <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">      AND title like #&#123;title&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">      AND author_name like #&#123;author.name&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">      AND featured = 1</span><br><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h2 id="trim-where-set"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#trim-where-set"></a> trim, where, set<a href="spring&mybatis/Mybatis - MybatisPlus#trim-where-set"></a></h2><p>前面几个例子已经合宜地解决了一个臭名昭著的动态 SQL 问题。现在考虑回到&quot;if&quot;示例，这次我们将&quot;ACTIVE = 1&quot;也设置成动态的条件，看看会发生什么。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findActiveBlogLike"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">resultType</span>=<span class="string">"Blog"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  WHERE </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"state != null"</span>&gt;</span></span><br><span class="line">    state = #&#123;state&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"title != null"</span>&gt;</span></span><br><span class="line">    AND title like #&#123;title&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"author != null and author.name != null"</span>&gt;</span></span><br><span class="line">    AND author_name like #&#123;author.name&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>如果这些条件没有一个能匹配上将会怎样？最终这条 SQL 会变成这样：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br></pre></td></tr></table></div></figure><p>这会导致查询失败。如果仅仅第二个条件匹配又会怎样？这条 SQL 最终会是这样:</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> BLOG</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">AND</span> title <span class="keyword">like</span> <span class="string">'someTitle'</span></span><br></pre></td></tr></table></div></figure><p>这个查询也会失败。这个问题不能简单的用条件句式来解决，如果你也曾经被迫这样写过，那么你很可能从此以后都不想再这样去写了。</p><p>MyBatis 有一个简单的处理，这在90%的情况下都会有用。而在不能使用的地方，你可以自定义处理方式来令其正常工作。一处简单的修改就能得到想要的效果：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;findActiveBlogLike&quot;</span><br><span class="line">     resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  SELECT * FROM BLOG </span><br><span class="line">  &lt;where&gt; </span><br><span class="line">    &lt;if test=&quot;state != null&quot;&gt;</span><br><span class="line">         state = #&#123;state&#125;</span><br><span class="line">    &lt;/if&gt; </span><br><span class="line">    &lt;if test=&quot;title != null&quot;&gt;</span><br><span class="line">        AND title like #&#123;title&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">    &lt;if test=&quot;author != null and author.name != null&quot;&gt;</span><br><span class="line">        AND author_name like #&#123;author.name&#125;</span><br><span class="line">    &lt;/if&gt;</span><br><span class="line">  &lt;/where&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></div></figure><p>where 元素知道只有在一个以上的if条件有值的情况下才去插入&quot;WHERE&quot;子句。而且，若最后的内容是&quot;AND&quot;或&quot;OR&quot;开头的，where 元素也知道如何将他们去除。</p><p>如果 where 元素没有按正常套路出牌，我们还是可以通过自定义 trim 元素来定制我们想要的功能。比如，和 where 元素等价的自定义 trim 元素为：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&gt;</span><br><span class="line">  ... </span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></div></figure><p>prefixOverrides 属性会忽略通过管道分隔的文本序列（注意此例中的空格也是必要的）。它带来的结果就是所有在 prefixOverrides 属性中指定的内容将被移除，并且插入 prefix 属性中指定的内容。</p><p>类似的用于动态更新语句的解决方案叫做 set。set 元素可以被用于动态包含需要更新的列，而舍去其他的。比如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateAuthorIfNecessary"</span>&gt;</span></span><br><span class="line">  update Author</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"username != null"</span>&gt;</span>username=#&#123;username&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"password != null"</span>&gt;</span>password=#&#123;password&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email != null"</span>&gt;</span>email=#&#123;email&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bio != null"</span>&gt;</span>bio=#&#123;bio&#125;<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">  where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>这里，set 元素会动态前置 SET 关键字，同时也会消除无关的逗号，因为用了条件语句之后很可能就会在生成的赋值语句的后面留下这些逗号。</p><p>若你对等价的自定义 trim 元素的样子感兴趣，那这就应该是它的真面目：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;/trim&gt;</span><br></pre></td></tr></table></div></figure><p>注意这里我们忽略的是后缀中的值，而又一次附加了前缀中的值。</p><h2 id="foreach"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#foreach"></a> foreach<a href="spring&mybatis/Mybatis - MybatisPlus#foreach"></a></h2><p>动态 SQL 的另外一个常用的必要操作是需要对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectPostIn&quot; resultType=&quot;domain.blog.Post&quot;&gt;</span><br><span class="line">  SELECT *</span><br><span class="line">  FROM POST P</span><br><span class="line">  WHERE ID in</span><br><span class="line">  &lt;foreach item=&quot;item&quot; index=&quot;index&quot; collection=&quot;list&quot;</span><br><span class="line">      open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;&gt;</span><br><span class="line">        #&#123;item&#125;</span><br><span class="line">  &lt;/foreach&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></div></figure><p>foreach 元素的功能是非常强大的，它允许你指定一个集合，声明可以用在元素体内的集合项和索引变量。它也允许你指定开闭匹配的字符串以及在迭代中间放置分隔符。这个元素是很智能的，因此它不会偶然地附加多余的分隔符。</p><p>注意 你可以将一个 List 实例或者数组作为参数对象传给 MyBatis，当你这么做的时候，MyBatis 会自动将它包装在一个 Map 中并以名称为键。List 实例将会以&quot;list&quot;作为键，而数组实例的键将是&quot;array&quot;。</p><p>到此我们已经完成了涉及 XML 配置文件和 XML 映射文件的讨论。下一部分将详细探讨 Java API，这样才能从已创建的映射中获取最大利益。</p><h2 id="bind"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#bind"></a> bind<a href="spring&mybatis/Mybatis - MybatisPlus#bind"></a></h2><p><code>bind</code> 元素可以从 OGNL 表达式中创建一个变量并将其绑定到上下文。比如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;select id=&quot;selectBlogsLike&quot; resultType=&quot;Blog&quot;&gt;</span><br><span class="line">  &lt;bind name=&quot;pattern&quot; value=&quot;&apos;%&apos; + _parameter.getTitle() + &apos;%&apos;&quot; /&gt;</span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line">  WHERE title LIKE #&#123;pattern&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></div></figure><h2 id="multi-db-vendor-support"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#multi-db-vendor-support"></a> Multi-db vendor support<a href="spring&mybatis/Mybatis - MybatisPlus#multi-db-vendor-support"></a></h2><p>一个配置了&quot;_databaseId&quot;变量的 databaseIdProvider 对于动态代码来说是可用的，这样就可以根据不同的数据库厂商构建特定的语句。比如下面的例子：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId == 'oracle'"</span>&gt;</span></span><br><span class="line">      select seq_users.nextval from dual</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"_databaseId == 'db2'"</span>&gt;</span></span><br><span class="line">      select nextval for seq_users from sysibm.sysdummy1"</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">  insert into users values (#&#123;id&#125;, #&#123;name&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h2 id="动态-sql-中可插拔的脚本语言"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#动态-sql-中可插拔的脚本语言"></a> 动态 SQL 中可插拔的脚本语言<a href="spring&mybatis/Mybatis - MybatisPlus#动态-sql-中可插拔的脚本语言"></a></h2><p>MyBatis 从 3.2 开始支持可插拔的脚本语言，因此你可以在插入一种语言的驱动（language driver）之后来写基于这种语言的动态 SQL 查询。</p><p>可以通过实现下面接口的方式来插入一种语言：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LanguageDriver</span> </span>&#123;</span><br><span class="line">  <span class="function">ParameterHandler <span class="title">createParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span></span>;</span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, XNode script, Class parameterType)</span></span>;</span><br><span class="line">  <span class="function">SqlSource <span class="title">createSqlSource</span><span class="params">(Configuration configuration, String script, Class parameterType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>一旦有了自定义的语言驱动，你就可以在 mybatis-config.xml 文件中将它设置为默认语言：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"org.sample.MyLanguageDriver"</span> <span class="attr">alias</span>=<span class="string">"myLanguage"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultScriptingLanguage"</span> <span class="attr">value</span>=<span class="string">"myLanguage"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>除了设置默认语言，你也可以针对特殊的语句指定特定语言，这可以通过如下的 <code>lang</code> 属性来完成：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectBlog"</span> <span class="attr">lang</span>=<span class="string">"myLanguage"</span>&gt;</span></span><br><span class="line">  SELECT * FROM BLOG</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>或者在你正在使用的映射中加上注解 <code>@Lang</code> 来完成：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Lang</span>(MyLanguageDriver.class)</span><br><span class="line">  <span class="meta">@Select</span>(<span class="string">"SELECT * FROM BLOG"</span>)</span><br><span class="line">  <span class="function">List <span class="title">selectBlog</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意 可以将 Apache Velocity 作为动态语言来使用，更多细节请参考 MyBatis-Velocity 项目。</p><p>你前面看到的所有 xml 标签都是默认 MyBatis 语言提供的，它是由别名为 <code>xml</code> 语言驱动器 <code>org.apache.ibatis.scripting.xmltags.XmlLanguageDriver</code> 驱动的。</p><h3 id="注解"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#注解"></a> 注解<a href="spring&mybatis/Mybatis - MybatisPlus#注解"></a></h3><div class="article-bounded"><div class="article-table"><table><thead><tr><th>注解</th><th style="text-align:center">目标</th><th>相对应的 XML</th><th>描述</th></tr></thead><tbody><tr><td><code>@CacheNamespace</code></td><td style="text-align:center"><code>类</code></td><td>``</td><td>为给定的命名空间 (比如类) 配置缓存。 属性:implemetation,eviction, flushInterval,size 和 readWrite。</td></tr><tr><td><code>@CacheNamespaceRef</code></td><td style="text-align:center"><code>类</code></td><td>``</td><td>参照另外一个命名空间的缓存来使用。 属性:value,应该是一个名空间的字 符串值(也就是类的完全限定名) 。</td></tr><tr><td><code>@ConstructorArgs</code></td><td style="text-align:center"><code>Method</code></td><td>``</td><td>收集一组结果传递给一个劫夺对象的 构造方法。属性:value,是形式参数 的数组。</td></tr><tr><td><code>@Arg</code></td><td style="text-align:center"><code>方法</code></td><td></td><td>单 独 的 构 造 方 法 参 数 , 是 ConstructorArgs 集合的一部分。属性: id,column,javaType,typeHandler。 id 属性是布尔值, 来标识用于比较的属 性,和XML 元素相似。</td></tr><tr><td><code>@TypeDiscriminator</code></td><td style="text-align:center"><code>方法</code></td><td>``</td><td>一组实例值被用来决定结果映射的表 现。 属性: column, javaType, jdbcType, typeHandler,cases。cases 属性就是实 例的数组。</td></tr><tr><td><code>@Case</code></td><td style="text-align:center"><code>方法</code></td><td>``</td><td>单独实例的值和它对应的映射。属性: value,type,results。Results 属性是结 果数组,因此这个注解和实际的 ResultMap 很相似,由下面的 Results 注解指定。</td></tr><tr><td><code>@Results</code></td><td style="text-align:center"><code>方法</code></td><td>``</td><td>结果映射的列表, 包含了一个特别结果 列如何被映射到属性或字段的详情。 属 性:value,是 Result 注解的数组。</td></tr><tr><td><code>@Result</code></td><td style="text-align:center"><code>方法</code></td><td></td><td>在列和属性或字段之间的单独结果映 射。属 性:id,column, property, javaType ,jdbcType ,type Handler, one,many。id 属性是一个布尔值,表 示了应该被用于比较(和在 XML 映射 中的相似)的属性。one 属性是单 独 的 联 系, 和 相 似 , 而 many 属 性 是 对 集 合 而 言 的 , 和 相似。 它们这样命名是为了 避免名称冲突。</td></tr><tr><td><code>@One</code></td><td style="text-align:center"><code>方法</code></td><td>``</td><td>复杂类型的单独属性值映射。属性: select,已映射语句(也就是映射器方 法)的完全限定名,它可以加载合适类 型的实例。注意:联合映射在注解 API 中是不支持的。这是因为 Java 注解的 限制,不允许循环引用。<code>fetchType</code>, which supersedes the global configuration parameter<code>lazyLoadingEnabled</code> for this mapping.</td></tr><tr><td><code>@Many</code></td><td style="text-align:center"><code>方法</code></td><td>``</td><td>A mapping to a collection property of a complex type. Attributes:<code>select</code>, which is the fully qualified name of a mapped statement (i.e. mapper method) that can load a collection of instances of the appropriate types,<code>fetchType</code>, which supersedes the global configuration parameter<code>lazyLoadingEnabled</code> for this mapping. NOTE You will notice that join mapping is not supported via the Annotations API. This is due to the limitation in Java Annotations that does not allow for circular references.</td></tr><tr><td><code>@MapKey</code></td><td style="text-align:center"><code>方法</code></td><td></td><td>复 杂 类 型 的 集合 属 性 映射 。 属 性 : select,是映射语句(也就是映射器方 法)的完全限定名,它可以加载合适类 型的一组实例。注意:联合映射在 Java 注解中是不支持的。这是因为 Java 注 解的限制,不允许循环引用。</td></tr><tr><td><code>@Options</code></td><td style="text-align:center"><code>方法</code></td><td>映射语句的属性</td><td>这个注解提供访问交换和配置选项的 宽广范围, 它们通常在映射语句上作为 属性出现。 而不是将每条语句注解变复 杂,Options 注解提供连贯清晰的方式 来访问它们。属性:useCache=true , flushCache=false , resultSetType=FORWARD_ONLY , statementType=PREPARED , fetchSize=-1 , , timeout=-1 useGeneratedKeys=false , keyProperty=“id”。 理解 Java 注解是很 重要的,因为没有办法来指定&quot;null&quot; 作为值。因此,一旦你使用了 Options 注解,语句就受所有默认值的支配。要 注意什么样的默认值来避免不期望的 行为。</td></tr><tr><td>* <code>@Insert</code>,<code>@Update</code>, <code>@Delete</code>, <code>@Select</code></td><td style="text-align:center"><code>方法</code></td><td><code>&lt;insert&gt;</code>,<code>&lt;update&gt;</code>,<code>&lt;delete&gt;</code>,<code>&lt;select&gt;</code></td><td>这些注解中的每一个代表了执行的真 实 SQL。 它们每一个都使用字符串数组 (或单独的字符串)。如果传递的是字 符串数组, 它们由每个分隔它们的单独 空间串联起来。这就当用 Java 代码构 建 SQL 时避免了“丢失空间”的问题。 然而,如果你喜欢,也欢迎你串联单独 的字符串。属性:value,这是字符串 数组用来组成单独的 SQL 语句。</td></tr><tr><td>@InsertProvider,@UpdateProvider,@DeleteProvider,@SelectProvider</td><td style="text-align:center">方法</td><td><code>&lt;insert&gt;</code>,<code>&lt;update&gt;</code>,<code>&lt;delete&gt;</code>,<code>&lt;select&gt;</code></td><td>这些可选的 SQL 注解允许你指定一个 类名和一个方法在执行时来返回运行 允许创建动态 的 SQL。 基于执行的映射语句, MyBatis 会实例化这个类,然后执行由 provider 指定的方法. 这个方法可以选择性的接 受参数对象作为它的唯一参数, 但是必 须只指定该参数或者没有参数。属性: type,method。type 属性是类的完全限 定名。method 是该类中的那个方法名。 注意: 这节之后是对 SelectBuilder 类的 讨论,它可以帮助你以干净,容于阅读 的方式来构建动态 SQL。</td></tr><tr><td><code>@Param</code></td><td style="text-align:center"><code>Parameter</code></td><td>N/A</td><td>如果你的映射器的方法需要多个参数, 这个注解可以被应用于映射器的方法 参数来给每个参数一个名字。否则,多 参数将会以它们的顺序位置来被命名 (不包括任何 RowBounds 参数) 比如。 #{param1} , #{param2} 等 , 这 是 默 认 的 。 使 用 @Param(“person”),参数应该被命名为 #{person}。</td></tr><tr><td><code>@SelectKey</code></td><td style="text-align:center"><code>Method</code></td><td><code>&lt;selectKey&gt;</code></td><td>This annotation duplicates the `` functionality for methods annotated with<code>@Insert</code>,<code>@InsertProvider</code>,<code>@Update</code>or<code>@UpdateProvider</code>. It is ignored for other methods. If you specify a<code>@SelectKey</code>annotation, then MyBatis will ignore any generated key properties set via the<code>@Options</code>annotation, or configuration properties. Attributes: statement an array of strings which is the SQL statement to execute,<code>keyProperty</code>which is the property of the parameter object that will be updated with the new value, before which must be either<code>true</code>or<code>false</code>to denote if the SQL statement should be executed before or after the insert,<code>resultType</code>which is the Java type of the<code>keyProperty</code>, and<code>statementType=PREPARED</code>.</td></tr><tr><td><code>@ResultMap</code></td><td style="text-align:center"><code>Method</code></td><td>N/A</td><td>This annotation is used to provide the id of a `` element in an XML mapper to a<code>@Select</code>or<code>@SelectProvider</code>annotation. This allows annotated selects to reuse resultmaps that are defined in XML. This annotation will override any<code>@Results</code>or<code>@ConstructorArgs</code> annotation if both are specified on an annotated select.</td></tr><tr><td><code>@ResultType</code></td><td style="text-align:center"><code>Method</code></td><td>N/A</td><td>This annotation is used when using a result handler. In that case, the return type is void so MyBatis must have a way to determine the type of object to construct for each row. If there is an XML result map, use the @ResultMap annotation. If the result type is specified in XML on the ` Night Mode</td></tr></tbody></table></div></div><h4 id="映射申明样例"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#映射申明样例"></a> 映射申明样例<a href="spring&mybatis/Mybatis - MybatisPlus#映射申明样例"></a></h4><p>这个例子展示了如何使用 @SelectKey 注解来在插入前读取数据库序列的值：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Insert(&quot;insert into table3 (id, name) values(#&#123;nameId&#125;, #&#123;name&#125;)&quot;)</span><br><span class="line">@SelectKey(statement=&quot;call next value for TestSequence&quot;, keyProperty=&quot;nameId&quot;, before=true, resultType=int.class)</span><br><span class="line">int insertTable3(Name name);</span><br></pre></td></tr></table></div></figure><p>这个例子展示了如何使用 @SelectKey 注解来在插入后读取数据库识别列的值：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Insert(&quot;insert into table2 (name) values(#&#123;name&#125;)&quot;)</span><br><span class="line">@SelectKey(statement=&quot;call identity()&quot;, keyProperty=&quot;nameId&quot;, before=false, resultType=int.class)</span><br><span class="line">int insertTable2(Name name);</span><br></pre></td></tr></table></div></figure><h2 id="mybatis-plus"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#mybatis-plus"></a> MyBatis Plus<a href="spring&mybatis/Mybatis - MybatisPlus#mybatis-plus"></a></h2><h3 id="一-mybatis-plus简介"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#一-mybatis-plus简介"></a> 一、mybatis-plus简介：<a href="spring&mybatis/Mybatis - MybatisPlus#一-mybatis-plus简介"></a></h3><p>Mybatis-Plus（简称MP）是一个 Mybatis 的增强工具，在 Mybatis 的基础上只做增强不做改变，为简化开发、提高效率而生。这是官方给的定义，关于mybatis-plus的更多介绍及特性，可以参考<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fmp.baomidou.com%2F%23%2F" target="_blank" rel="noopener">mybatis-plus官网</a>。那么它是怎么增强的呢？其实就是它已经封装好了一些crud方法，我们不需要再写xml了，直接调用这些方法就行，就类似于JPA。</p><h3 id="二-spring整合mybatis-plus"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#二-spring整合mybatis-plus"></a> 二、spring整合mybatis-plus:<a href="spring&mybatis/Mybatis - MybatisPlus#二-spring整合mybatis-plus"></a></h3><p>正如官方所说，mybatis-plus在mybatis的基础上只做增强不做改变，因此其与spring的整合亦非常简单。只需把mybatis的依赖换成mybatis-plus的依赖，再把sqlSessionFactory换成mybatis-plus的即可。接下来看具体操作：</p><h4 id="1-pomxml"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#1-pomxml"></a> <strong>1、pom.xml:</strong><a href="spring&mybatis/Mybatis - MybatisPlus#1-pomxml"></a></h4><p>核心依赖如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.14.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mp 依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>**注意：**这些是核心依赖，本项目还用到了mysql驱动、c3p0、日志（slf4j-api，slf4j-log4j2）、lombok。集成mybatis-plus要把mybatis、mybatis-spring去掉，避免冲突；lombok是一个工具，添加了这个依赖，开发工具再安装Lombok插件，就可以使用它了，最常用的用法就是在实体类中使用它的@Data注解，这样实体类就不用写set、get、toString等方法了。关于Lombok的更多用法，请自行百度。</p><h4 id="2-log4jxml"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#2-log4jxml"></a> <strong>2、log4j.xml:</strong><a href="spring&mybatis/Mybatis - MybatisPlus#2-log4jxml"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">log4j:configuration</span> <span class="attr">xmlns:log4j</span>=<span class="string">"http://jakarta.apache.org/log4j/"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Encoding"</span> <span class="attr">value</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"org.apache.log4j.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"ConversionPattern"</span> <span class="attr">value</span>=<span class="string">"%-5p %d&#123;MM-dd</span></span></span><br><span class="line"><span class="tag"><span class="string">HH:mm:ss,SSS&#125; %m (%F:%L) \n"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"java.sql"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.apache.ibatis"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"info"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"STDOUT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">log4j:configuration</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="3-jdbcproperties"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#3-jdbcproperties"></a> <strong>3、jdbc.properties:</strong><a href="spring&mybatis/Mybatis - MybatisPlus#3-jdbcproperties"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=<span class="symbol">jdbc:</span><span class="symbol">mysql:</span>/<span class="regexp">//</span>数据库名?useUnicode=<span class="literal">true</span>&amp;characterEncoding=utf8</span><br><span class="line">jdbc.username=<span class="comment">#</span></span><br><span class="line">jdbc.password=<span class="comment">#</span></span><br></pre></td></tr></table></div></figure><h4 id="4-mybatis-configxml"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#4-mybatis-configxml"></a> <strong>4、mybatis-config.xml:</strong><a href="spring&mybatis/Mybatis - MybatisPlus#4-mybatis-configxml"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>**注：**因为是与spring整合，所有mybatis-plus的大部分都写在spring的配置文件中，这里定义一个空的mybatis-config.xml即可。</p><h4 id="5-spring-daoxml"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#5-spring-daoxml"></a> <strong>5、spring-dao.xml:</strong><a href="spring&mybatis/Mybatis - MybatisPlus#5-spring-daoxml"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>    </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span>   </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"    </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"</span>&gt;</span>    </span><br><span class="line">        </span><br><span class="line">    <span class="comment">&lt;!-- 配置整合mybatis-plus过程 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1、配置数据库相关参数properties的属性：$&#123;url&#125; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2、配置数据库连接池 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- mybatis的sqlsessionFactorybean：org.mybatis.spring.SqlSessionFactoryBean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3、配置mybatis-plus的sqlSessionFactory --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.zhu.mybatisplus.entity"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4、DAO接口所在包名，Spring会自动查找其下的类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.zhu.mybatisplus.dao"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="6-entity"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#6-entity"></a> <strong>6、entity:</strong><a href="spring&mybatis/Mybatis - MybatisPlus#6-entity"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName(value = <span class="meta-string">"tb_employee"</span>)</span><span class="comment">//指定表名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="comment">//value与数据库主键列名一致，若实体类属性名与表主键列名一致可省略value</span></span><br><span class="line">    <span class="meta">@TableId(value = <span class="meta-string">"id"</span>,type = IdType.AUTO)</span><span class="comment">//指定自增策略</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="comment">//若没有开启驼峰命名，或者表中列名不符合驼峰规则，可通过该注解指定数据库表中的列名，exist标明数据表中有没有对应列</span></span><br><span class="line">    <span class="meta">@TableField(value = <span class="meta-string">"last_name"</span>,exist = true)</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> Integer gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="7-mapper"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#7-mapper"></a> <strong>7、mapper:</strong><a href="spring&mybatis/Mybatis - MybatisPlus#7-mapper"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EmplopyeeDao</span> <span class="keyword">extends</span> <span class="title">BaseMapper</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这样就完成了mybatis-plus与spring的整合。首先是把mybatis和mybatis-spring依赖换成mybatis-plus的依赖，然后把sqlsessionfactory换成mybatis-plus的，然后实体类中添加<code>@TableName</code>、<code>@TableId</code>等注解，最后mapper继承<code>BaseMapper</code>即可。</p><h4 id="8-测试"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#8-测试"></a> <strong>8、测试：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#8-测试"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/spring-dao.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>运行该junit，可输出获取到的连接，说明整合没问题：</p><h3 id="三-mp的通用crud"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#三-mp的通用crud"></a> 三、mp的通用crud<a href="spring&mybatis/Mybatis - MybatisPlus#三-mp的通用crud"></a></h3><ul><li><strong>需求：</strong><ul><li>存在一张 tb_employee 表，且已有对应的实体类 Employee，实现tb_employee 表的 CRUD 操作我们需要做什么呢？</li></ul></li><li><strong>基于 Mybatis：</strong><ul><li>需要编写 EmployeeMapper 接口，并在 EmployeeMapper.xml 映射文件中手动编写 CRUD 方法对应的sql语句。</li></ul></li><li><strong>基于 MP：</strong><ul><li>只需要创建 EmployeeMapper 接口, 并继承 BaseMapper 接口</li><li>我们已经有了Employee、tb_employee了，并且EmployeeDao也继承了BaseMapper了，接下来就使用crud方法</li></ul></li></ul><h4 id="1-insert操作"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#1-insert操作"></a> <strong>1、insert操作：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#1-insert操作"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/spring-dao.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> EmplopyeeDao emplopyeeDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">"东方不败"</span>);</span><br><span class="line">        employee.setEmail(<span class="string">"dfbb@163.com"</span>);</span><br><span class="line">        employee.setGender(<span class="number">1</span>);</span><br><span class="line">        employee.setAge(<span class="number">20</span>);</span><br><span class="line">        emplopyeeDao.insert(employee);</span><br><span class="line">        <span class="comment">//mybatisplus会自动把当前插入对象在数据库中的id写回到该实体中</span></span><br><span class="line">        System.out.println(employee.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行添加操作，直接调用insert方法传入实体即可。</p><h4 id="2-update操作"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#2-update操作"></a> <strong>2、update操作：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#2-update操作"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setId(<span class="number">1</span>);</span><br><span class="line">        employee.setLastName(<span class="string">"更新测试"</span>);</span><br><span class="line">        <span class="comment">//emplopyeeDao.updateById(employee);//根据id进行更新，没有传值的属性就不会更新</span></span><br><span class="line">        emplopyeeDao.updateAllColumnById(employee);<span class="comment">//根据id进行更新，没传值的属性就更新为null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>**注：**注意这两个update操作的区别，<code>updateById</code>方法，没有传值的字段不会进行更新，比如只传入了lastName，那么age、gender等属性就会保留原来的值；<code>updateAllColumnById</code>方法，顾名思义，会更新所有的列，没有传值的列会更新为null。</p><h4 id="3-select操作"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#3-select操作"></a> <strong>3、select操作：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#3-select操作"></a></h4><p>**(1)、**根据id查询：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Employee employee = emplopyeeDao.selectById(1);</span><br></pre></td></tr></table></div></figure><p>**(2)、**根据条件查询一条数据：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Employee employeeCondition = <span class="keyword">new</span> Employee();</span><br><span class="line">employeeCondition.setId(<span class="number">1</span>);</span><br><span class="line">employeeCondition.setLastName(<span class="string">"更新测试"</span>);</span><br><span class="line"><span class="comment">//若是数据库中符合传入的条件的记录有多条，那就不能用这个方法，会报错</span></span><br><span class="line">Employee employee = emplopyeeDao.selectOne(employeeCondition);</span><br></pre></td></tr></table></div></figure><p>**注：**这个方法的sql语句就是<code>where id = 1 and last_name = 更新测试</code>，若是符合这个条件的记录不止一条，那么就会报错。</p><p>**(3)、**根据查询条件返回多条数据：<br>当符合指定条件的记录数有多条时，上面那个方法就会报错，就应该用这个方法。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; columnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">columnMap.put(<span class="string">"last_name"</span>,<span class="string">"东方不败"</span>);<span class="comment">//写表中的列名</span></span><br><span class="line">columnMap.put(<span class="string">"gender"</span>,<span class="string">"1"</span>);</span><br><span class="line"><span class="built_in">List</span>&lt;Employee&gt; employees = emplopyeeDao.selectByMap(columnMap);</span><br><span class="line">System.out.println(employees.size());</span><br></pre></td></tr></table></div></figure><p>**注：**查询条件用map集合封装，columnMap，写的是数据表中的列名，而非实体类的属性名。比如属性名为lastName，数据表中字段为last_name，这里应该写的是last_name。selectByMap方法返回值用list集合接收。</p><p>**(4)、**通过id批量查询：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; idList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">idList.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">idList.<span class="keyword">add</span>(<span class="number">2</span>);</span><br><span class="line">idList.<span class="keyword">add</span>(<span class="number">3</span>);</span><br><span class="line">List&lt;Employee&gt; employees = emplopyeeDao.selectBatchIds(idList);</span><br><span class="line">System.<span class="keyword">out</span>.println(employees);</span><br></pre></td></tr></table></div></figure><p>**注：**把需要查询的id都add到list集合中，然后调用selectBatchIds方法，传入该list集合即可，该方法返回的是对应id的所有记录，所有返回值也是用list接收。</p><p>**(5)、**分页查询：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Employee&gt; employees = emplopyeeDao.selectPage(<span class="keyword">new</span> Page&lt;&gt;(<span class="number">1</span>,<span class="number">2</span>),<span class="literal">null</span>);</span><br><span class="line">System.<span class="keyword">out</span>.println(employees);</span><br></pre></td></tr></table></div></figure><p>**注：**selectPage方法就是分页查询，在page中传入分页信息，后者为null的分页条件，这里先让其为null，讲了条件构造器再说其用法。这个分页其实并不是物理分页，而是内存分页。也就是说，查询的时候并没有limit语句。等配置了分页插件后才可以实现真正的分页。</p><p><strong>4、delete操作：</strong></p><p>**(1)、**根据id删除：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">emplopyeeDao</span><span class="selector-class">.deleteById</span>(1);</span><br></pre></td></tr></table></div></figure><p>**(2)、**根据条件删除：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>,<span class="built_in">Object</span>&gt; columnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">columnMap.put(<span class="string">"gender"</span>,<span class="number">0</span>);</span><br><span class="line">columnMap.put(<span class="string">"age"</span>,<span class="number">18</span>);</span><br><span class="line">emplopyeeDao.deleteByMap(columnMap);</span><br></pre></td></tr></table></div></figure><p>**注：**该方法与selectByMap类似，将条件封装在columnMap中，然后调用deleteByMap方法，传入columnMap即可，返回值是Integer类型，表示影响的行数。</p><p>**(3)、**根据id批量删除：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; idList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">idList.<span class="keyword">add</span>(<span class="number">1</span>);</span><br><span class="line">idList.<span class="keyword">add</span>(<span class="number">2</span>);</span><br><span class="line">emplopyeeDao.deleteBatchIds(idList);</span><br></pre></td></tr></table></div></figure><p>**注：**该方法和selectBatchIds类似，把需要删除的记录的id装进idList，然后调用deleteBatchIds，传入idList即可。</p><h3 id="四-全局策略配置"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#四-全局策略配置"></a> 四、全局策略配置：<a href="spring&mybatis/Mybatis - MybatisPlus#四-全局策略配置"></a></h3><p>通过上面的小案例我们可以发现，实体类需要加@TableName注解指定数据库表名，通过@TableId注解指定id的增长策略。实体类少倒也无所谓，实体类一多的话也麻烦。所以可以在spring-dao.xml的文件中进行全局策略配置。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 5、mybatisplus的全局策略配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"globalConfiguration"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.entity.GlobalConfiguration"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2.3版本后，驼峰命名默认值就是true，所以可不配置 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;property name="dbColumnUnderline" value="true"/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局主键自增策略，0表示auto --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idType"</span> <span class="attr">value</span>=<span class="string">"0"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 全局表前缀配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"tablePrefix"</span> <span class="attr">value</span>=<span class="string">"tb_"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>这里配置了还没用，还需要在sqlSessionFactory中注入配置才会生效。如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 3、配置mybatisplus的sqlSessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"com.zhu.mybatisplus.entity"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入全局配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalConfig"</span> <span class="attr">ref</span>=<span class="string">"globalConfiguration"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>如此一来，实体类中的@TableName注解和@TableId注解就可以去掉了</p><h3 id="五-条件构造器entitywrapper"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#五-条件构造器entitywrapper"></a> 五、条件构造器(EntityWrapper)：<a href="spring&mybatis/Mybatis - MybatisPlus#五-条件构造器entitywrapper"></a></h3><p>以上基本的 CRUD 操作，我们仅仅需要继承一个 BaseMapper 即可实现大部分单表 CRUD 操作。BaseMapper 提供了多达 17 个方法供使用, 可以极其方便的实现单一、批量、分页等操作，极大的减少开发负担。但是mybatis-plus的强大不限于此，请看如下需求该如何处理：</p><ul><li><strong>需求：</strong><ul><li>我们需要分页查询 tb_employee 表中，年龄在 18~50 之间性别为男且姓名为 xx 的所有用户，这时候我们该如何实现上述需求呢？</li></ul></li><li><strong>使用MyBatis :</strong> 需要在 SQL 映射文件中编写带条件查询的 SQL,并用PageHelper 插件完成分页. 实现以上一个简单的需求，往往需要我们做很多重复单调的工作。</li><li><strong>使用MP:</strong> 依旧不用编写 SQL 语句，MP 提供了功能强大的条件构造器 ------  EntityWrapper。</li></ul><p><strong>接下来就直接看几个案例体会EntityWrapper的使用。</strong></p><h4 id="1-分页查询年龄在18-50且gender为0-姓名为tom的用户"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#1-分页查询年龄在18-50且gender为0-姓名为tom的用户"></a> <strong>1、分页查询年龄在18 - 50且gender为0、姓名为tom的用户：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#1-分页查询年龄在18-50且gender为0-姓名为tom的用户"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Employee&gt; employees = emplopyeeDao.selectPage(<span class="keyword">new</span> Page&lt;Employee&gt;(<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">     <span class="keyword">new</span> EntityWrapper&lt;Employee&gt;()</span><br><span class="line">        .between(<span class="string">"age"</span>,<span class="number">18</span>,<span class="number">50</span>)</span><br><span class="line">        .eq(<span class="string">"gender"</span>,<span class="number">0</span>)</span><br><span class="line">        .eq(<span class="string">"last_name"</span>,<span class="string">"tom"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><p>**注：**由此案例可知，分页查询和之前一样，new 一个page对象传入分页信息即可。至于分页条件，new 一个EntityWrapper对象，调用该对象的相关方法即可。between方法三个参数，分别是column、value1、value2，该方法表示column的值要在value1和value2之间；eq是equals的简写，该方法两个参数，column和value，表示column的值和value要相等。注意column是数据表对应的字段，而非实体类属性字段。</p><h4 id="2-查询gender为0且名字中带有老师-或者邮箱中带有a的用户"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#2-查询gender为0且名字中带有老师-或者邮箱中带有a的用户"></a> <strong>2、查询gender为0且名字中带有老师、或者邮箱中带有a的用户：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#2-查询gender为0且名字中带有老师-或者邮箱中带有a的用户"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Employee&gt; employees = emplopyeeDao.selectList(</span><br><span class="line">                <span class="keyword">new</span> EntityWrapper&lt;Employee&gt;()</span><br><span class="line">               .eq(<span class="string">"gender"</span>,<span class="number">0</span>)</span><br><span class="line">               .like(<span class="string">"last_name"</span>,<span class="string">"老师"</span>)</span><br><span class="line">                <span class="comment">//.or()//和or new 区别不大</span></span><br><span class="line">               .orNew()</span><br><span class="line">               .like(<span class="string">"email"</span>,<span class="string">"a"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><p>**注：**未说分页查询，所以用selectList即可，用EntityWrapper的like方法进行模糊查询，like方法就是指column的值包含value值，此处like方法就是查询last_name中包含“老师”字样的记录；“或者”用or或者orNew方法表示，这两个方法区别不大，用哪个都可以，可以通过控制台的sql语句自行感受其区别。</p><h4 id="3-查询gender为0根据age排序简单分页"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#3-查询gender为0根据age排序简单分页"></a> <strong>3、查询gender为0，根据age排序，简单分页：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#3-查询gender为0根据age排序简单分页"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Employee&gt; employees = emplopyeeDao.selectList(</span><br><span class="line">                <span class="keyword">new</span> EntityWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">"gender"</span>,<span class="number">0</span>)</span><br><span class="line">                .orderBy(<span class="string">"age"</span>)<span class="comment">//直接orderby 是升序，asc</span></span><br><span class="line">                .last(<span class="string">"desc limit 1,3"</span>)<span class="comment">//在sql语句后面追加last里面的内容(改为降序，同时分页)</span></span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><p>**注：**简单分页是指不用page对象进行分页。orderBy方法就是根据传入的column进行升序排序，若要降序，可以使用orderByDesc方法，也可以如案例中所示用last方法；last方法就是将last方法里面的value值追加到sql语句的后面，在该案例中，最后的sql语句就变为<code>select ······ order by desc limit 1, 3</code>，追加了<code>desc limit 1,3</code>所以可以进行降序排序和分页。</p><h4 id="4-分页查询年龄在18-50且gender为0-姓名为tom的用户"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#4-分页查询年龄在18-50且gender为0-姓名为tom的用户"></a> <strong>4、分页查询年龄在18 - 50且gender为0、姓名为tom的用户：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#4-分页查询年龄在18-50且gender为0-姓名为tom的用户"></a></h4><p>条件构造器除了EntityWrapper，还有Condition。用Condition来处理一下这个需求：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Employee&gt; employees = emplopyeeDao.selectPage(</span><br><span class="line">               <span class="keyword">new</span> Page&lt;Employee&gt;(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">               Condition.create()</span><br><span class="line">                       .between(<span class="string">"age"</span>,<span class="number">18</span>,<span class="number">50</span>)</span><br><span class="line">                       .eq(<span class="string">"gender"</span>,<span class="string">"0"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><p>**注：**Condition和EntityWrapper的区别就是，创建条件构造器时，EntityWrapper是new出来的，而Condition是调create方法创建出来。</p><h4 id="5-根据条件更新"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#5-根据条件更新"></a> <strong>5、根据条件更新：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#5-根据条件更新"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testEntityWrapperUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">"苍老师"</span>);</span><br><span class="line">        employee.setEmail(<span class="string">"cjk@sina.com"</span>);</span><br><span class="line">        employee.setGender(<span class="number">0</span>);</span><br><span class="line">        emplopyeeDao.update(employee,</span><br><span class="line">                <span class="keyword">new</span> EntityWrapper&lt;Employee&gt;()</span><br><span class="line">                .eq(<span class="string">"last_name"</span>,<span class="string">"tom"</span>)</span><br><span class="line">                .eq(<span class="string">"age"</span>,<span class="number">25</span>)</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>**注：**该案例表示把last_name为tom，age为25的所有用户的信息更新为employee中设置的信息。</p><h4 id="6-根据条件删除"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#6-根据条件删除"></a> <strong>6、根据条件删除：</strong><a href="spring&mybatis/Mybatis - MybatisPlus#6-根据条件删除"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">emplopyeeDao.<span class="keyword">delete</span>(</span><br><span class="line">        <span class="keyword">new</span> EntityWrapper&lt;Employee&gt;()</span><br><span class="line">        .eq(<span class="string">"last_name"</span>,<span class="string">"tom"</span>)</span><br><span class="line">        .eq(<span class="string">"age"</span>,<span class="number">16</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure><p>**注：**该案例表示把last_name为tom、age为16的所有用户删除。</p><h3 id="代码生成工具"><a class="markdownIt-Anchor" href="spring&mybatis/Mybatis - MybatisPlus#代码生成工具"></a> 代码生成工具<a href="spring&mybatis/Mybatis - MybatisPlus#代码生成工具"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zhx.plus_demo2.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringPool;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.InjectionConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.*;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableInfo;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 演示例子，执行 main 方法控制台输入模块表名回车自动生成对应项目目录中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MpGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String projectPath = System.getProperty(<span class="string">"user.dir"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 读取控制台内容</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">scanner</span><span class="params">(String tip)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入"</span> + tip + <span class="string">"："</span>);</span><br><span class="line">        <span class="keyword">if</span> (scanner.hasNext()) &#123;</span><br><span class="line">            String ipt = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNotEmpty(ipt)) &#123;</span><br><span class="line">                <span class="keyword">return</span> ipt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MybatisPlusException(<span class="string">"请输入正确的"</span> + tip + <span class="string">"！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        GlobalConfig globalConfig = generateGlobalConfig();</span><br><span class="line">        <span class="comment">// 数据源配置</span></span><br><span class="line">        DataSourceConfig dsc = generateDataSourceConfig();</span><br><span class="line">        <span class="comment">// 包设置</span></span><br><span class="line">        <span class="keyword">final</span> PackageConfig pc = generatePackageConfig();</span><br><span class="line">        <span class="comment">// 自定义设置</span></span><br><span class="line">        InjectionConfig injectionConfig = generateInjectConfig(pc);</span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        StrategyConfig strategy = generateStrategy();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置模板</span></span><br><span class="line">        TemplateConfig templateConfig = <span class="keyword">new</span> TemplateConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置自定义输出模板</span></span><br><span class="line">        <span class="comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span></span><br><span class="line">        <span class="comment">// templateConfig.setEntity("templates/entity2.java");</span></span><br><span class="line">        <span class="comment">// templateConfig.setService();</span></span><br><span class="line">        <span class="comment">// templateConfig.setController();</span></span><br><span class="line"></span><br><span class="line">        templateConfig.setXml(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代码生成器</span></span><br><span class="line">        AutoGenerator mpg = <span class="keyword">new</span> AutoGenerator();</span><br><span class="line">        mpg.setGlobalConfig(globalConfig);</span><br><span class="line">        mpg.setDataSource(dsc);</span><br><span class="line">        mpg.setPackageInfo(pc);</span><br><span class="line">        mpg.setStrategy(strategy);</span><br><span class="line">        mpg.setCfg(injectionConfig);</span><br><span class="line">        mpg.setTemplate(templateConfig);</span><br><span class="line"></span><br><span class="line">        mpg.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> StrategyConfig <span class="title">generateStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 策略配置</span></span><br><span class="line">        StrategyConfig strategy = <span class="keyword">new</span> StrategyConfig();</span><br><span class="line">        <span class="comment">// strategy.setCapitalMode(true);// 全局大写命名 ORACLE 注意</span></span><br><span class="line">        <span class="comment">//strategy.setTablePrefix(new String[] &#123; "tlog_", "tsys_" &#125;);// 此处可以修改为您的表前缀</span></span><br><span class="line">        strategy.setNaming(NamingStrategy.underline_to_camel);<span class="comment">// 表名生成策略</span></span><br><span class="line">        strategy.setInclude(scanner(<span class="string">"表名"</span>).split(<span class="string">","</span>)); <span class="comment">// 需要生成的表</span></span><br><span class="line">        strategy.setEntityLombokModel(<span class="keyword">true</span>);</span><br><span class="line">        strategy.setEntityBuilderModel(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// strategy.setExclude(new String[]&#123;"test"&#125;); // 排除生成的表</span></span><br><span class="line">        <span class="comment">// 自定义实体父类</span></span><br><span class="line">        <span class="comment">// strategy.setSuperEntityClass("com.baomidou.demo.TestEntity");</span></span><br><span class="line">        <span class="comment">// 自定义实体，公共字段</span></span><br><span class="line">        <span class="comment">// strategy.setSuperEntityColumns(new String[] &#123; "test_id", "age" &#125;);</span></span><br><span class="line">        <span class="comment">// 自定义 mapper 父类</span></span><br><span class="line">        <span class="comment">// strategy.setSuperMapperClass("com.baomidou.demo.TestMapper");</span></span><br><span class="line">        <span class="comment">// 自定义 service 父类</span></span><br><span class="line">        <span class="comment">// strategy.setSuperServiceClass("com.baomidou.demo.TestService");</span></span><br><span class="line">        <span class="comment">// 自定义 service 实现类父类</span></span><br><span class="line">        <span class="comment">// strategy.setSuperServiceImplClass("com.baomidou.demo.TestServiceImpl");</span></span><br><span class="line">        <span class="comment">// 自定义 controller 父类</span></span><br><span class="line">        <span class="comment">// strategy.setSuperControllerClass("com.baomidou.demo.TestController");</span></span><br><span class="line">        <span class="comment">// 【实体】是否生成字段常量（默认 false）</span></span><br><span class="line">        <span class="comment">// public static final String ID = "test_id";</span></span><br><span class="line">        <span class="comment">// strategy.setEntityColumnConstant(true);</span></span><br><span class="line">        <span class="keyword">return</span> strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> InjectionConfig <span class="title">generateInjectConfig</span><span class="params">(PackageConfig pc)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自定义配置</span></span><br><span class="line">        InjectionConfig cfg = <span class="keyword">new</span> InjectionConfig() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// to do nothing</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果模板引擎是 freemarker</span></span><br><span class="line"><span class="comment">//        String templatePath = "/templates/mapper.xml.ftl";</span></span><br><span class="line">        <span class="comment">// 如果模板引擎是 velocity</span></span><br><span class="line">        String templatePath = <span class="string">"/templates/mapper.xml.vm"</span>;</span><br><span class="line">        <span class="comment">// 自定义输出配置</span></span><br><span class="line">        List&lt;FileOutConfig&gt; focList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义配置会被优先输出</span></span><br><span class="line">        focList.add(<span class="keyword">new</span> FileOutConfig(templatePath) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">outputFile</span><span class="params">(TableInfo tableInfo)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span></span><br><span class="line">                <span class="keyword">return</span> projectPath + <span class="string">"/src/main/resources/mapper/"</span> +</span><br><span class="line">                        <span class="string">"/"</span> + tableInfo.getEntityName() + <span class="string">"Mapper"</span> + StringPool.DOT_XML;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        cfg.setFileCreate(new IFileCreate() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) &#123;</span></span><br><span class="line"><span class="comment">                // 判断自定义文件夹是否需要创建</span></span><br><span class="line"><span class="comment">                checkDir("调用默认方法创建的目录");</span></span><br><span class="line"><span class="comment">                return false;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        cfg.setFileOutConfigList(focList);</span><br><span class="line">        <span class="keyword">return</span> cfg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> PackageConfig <span class="title">generatePackageConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> PackageConfig pc = <span class="keyword">new</span> PackageConfig();</span><br><span class="line"><span class="comment">//        pc.setModuleName(scanner("模块名"));</span></span><br><span class="line">        <span class="comment">// 包配置</span></span><br><span class="line"><span class="comment">//        final PackageConfig pc = new PackageConfig();</span></span><br><span class="line"><span class="comment">//        pc.setModuleName(scanner("模块名"));</span></span><br><span class="line"><span class="comment">//        pc.setParent("com.nfsq.es.demo.bean");</span></span><br><span class="line"></span><br><span class="line">        pc.setParent(<span class="string">"cn.ng.springboot"</span>);</span><br><span class="line">        pc.setMapper(<span class="string">"dao.mapper"</span>);<span class="comment">//生成mapper接口</span></span><br><span class="line">        pc.setEntity(<span class="string">"dao.entity"</span>);</span><br><span class="line">        pc.setServiceImpl(<span class="string">"service.impl"</span>);</span><br><span class="line">        pc.setService(<span class="string">"service"</span>);</span><br><span class="line">        pc.setXml(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> pc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DataSourceConfig <span class="title">generateDataSourceConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DataSourceConfig dataSource = <span class="keyword">new</span> DataSourceConfig();</span><br><span class="line"><span class="comment">//        dsc.setDbType(DbType.MYSQL);</span></span><br><span class="line">        dataSource.setDriverName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setUrl(<span class="string">"jdbc:mysql://localhost:3306/hive"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        // 数据源配置</span></span><br><span class="line"><span class="comment">//        DataSourceConfig dsc = new DataSourceConfig();</span></span><br><span class="line"><span class="comment">//        dsc.setUrl("jdbc:mysql://localhost:3306/es_demo?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8");</span></span><br><span class="line"><span class="comment">//        // dsc.setSchemaName("public");</span></span><br><span class="line"><span class="comment">//        dsc.setDriverName("com.mysql.jdbc.Driver");</span></span><br><span class="line"><span class="comment">//        dsc.setUsername("root");</span></span><br><span class="line"><span class="comment">//        dsc.setPassword("aptx1230");</span></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> GlobalConfig <span class="title">generateGlobalConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        GlobalConfig gc = <span class="keyword">new</span> GlobalConfig();</span><br><span class="line">        gc.setOutputDir(projectPath + <span class="string">"/src/main/java"</span>);</span><br><span class="line">        gc.setAuthor(<span class="string">"ng"</span>);</span><br><span class="line">        gc.setOpen(<span class="keyword">false</span>);</span><br><span class="line">        gc.setFileOverride(<span class="keyword">true</span>);</span><br><span class="line">        gc.setActiveRecord(<span class="keyword">true</span>);<span class="comment">// 不需要ActiveRecord特性的请改为false</span></span><br><span class="line">        gc.setEnableCache(<span class="keyword">false</span>);<span class="comment">// XML 二级缓存</span></span><br><span class="line">        gc.setBaseResultMap(<span class="keyword">true</span>);<span class="comment">// XML ResultMap</span></span><br><span class="line">        gc.setBaseColumnList(<span class="keyword">false</span>);<span class="comment">// XML columList</span></span><br><span class="line">        gc.setKotlin(<span class="keyword">false</span>); <span class="comment">// 是否生成 kotlin 代码</span></span><br><span class="line">        gc.setDateType(DateType.ONLY_DATE); <span class="comment">//时间类型的映射规则</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mybatis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;spring&amp;mybatis/Mybatis - MybatisPlus#mybatis&quot;&gt;&lt;/a&gt; Mybatis&lt;a href=&quot;spring&amp;mybatis/Mybati
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring&amp;mybatis/Spring Cloud</title>
    <link href="ilucia.github.io/spring&amp;mybatis/Spring%20Cloud/"/>
    <id>ilucia.github.io/spring&amp;mybatis/Spring%20Cloud/</id>
    <published>2022-04-27T15:24:01.747Z</published>
    <updated>2022-04-27T15:24:01.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-cloud"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#spring-cloud"></a> Spring Cloud<a href="spring&mybatis/Spring Cloud#spring-cloud"></a></h1><p>SpringCloud的<strong>基础功能</strong>：</p><ul><li>服务治理： Spring Cloud Eureka</li><li>客户端负载均衡： Spring Cloud Ribbon</li><li>服务容错保护： Spring Cloud Hystrix</li><li>声明式服务调用： Spring Cloud Feign</li><li>API网关服务：Spring Cloud Zuul</li><li>分布式配置中心： Spring Cloud Config</li></ul><h2 id="spring-cloud-eureka"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#spring-cloud-eureka"></a> Spring Cloud Eureka<a href="spring&mybatis/Spring Cloud#spring-cloud-eureka"></a></h2><h4 id="使用场景及架构"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#使用场景及架构"></a> 使用场景及架构<a href="spring&mybatis/Spring Cloud#使用场景及架构"></a></h4><p>从分布式/微服务的角度而言：就是把我们一<strong>大</strong>的项目，<strong>分解</strong>成多个<strong>小</strong>的模块。这些小的模块组合起来，完成功能</p><p>拆分出多个模块以后，就会出现<strong>各种各样</strong>的问题</p><p>首当其冲的就是子系统之间的<strong>通讯</strong>问题。子系统与子系统之间不是在同一个环境下，那就需要<strong>远程调用</strong>。远程调用可能就会想到httpClient，WebService等等这些技术来实现。</p><p>既然是远程调用，就必须知道ip地址，我们可能有以下的场景。</p><ul><li><p>功能实现一：A服务需要调用B服务</p></li><li><ul><li>在A服务的代码里面调用B服务，<strong>显式通过IP地址调用</strong>：<code>http://123.123.123.123:8888/java3y/3</code></li></ul></li><li><p>功能实现二：A服务调用B服务，B服务调用C服务，C服务调用D服务</p></li><li><ul><li>在A服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C，C-&gt;D</li></ul></li><li><p>功能实现三：D服务调用B服务，B服务调用C服务</p></li><li><ul><li>在D服务的代码里面调用B服务，显式通过IP地址调用：<code>http://123.123.123.123:8888/java3y/3</code>，(同样地)B-&gt;C</li></ul></li><li><p>…等等等等</p></li></ul><p>万一，我们<strong>B服务的IP地址变了</strong>，想想会出现什么问题：A服务,D服务(等等)需要<strong>手动更新</strong>B服务的地址</p><ul><li>在服务多的情况下，手动来维护这些静态配置就是噩梦！</li></ul><blockquote><p>为了解决微服务架构中的<strong>服务实例维护问题(ip地址)</strong>， 产生了大量的<strong>服务治理</strong>框架和产品。 这些框架和产品的实现都围绕着服务注册与服务发现机制来完成对微服务应用实例的<strong>自动化管理</strong>。</p></blockquote><p>在SpringCloud中我们的服务治理框架一般使用的就是Eureka。</p><p>我们的问题：</p><ul><li>现在有A、B、C、D四个服务，它们之间会互相调用(而且IP地址很可能会发生变化)，一旦某个服务的IP地址变了，那服务中的代码要跟着变，手动维护这些静态配置(IP)非常麻烦！</li></ul><p>Eureka是这样解决上面所说的情况的：</p><ul><li>创建一个E服务，将A、B、C、D四个服务的信息都<strong>注册</strong>到E服务上，E服务维护这些已经注册进来的信息</li></ul><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E6%9E%B6%E6%9E%84.jpg" alt="" class="article-img"></p><p>A、B、C、D四个服务都可以<strong>拿到</strong>Eureka(服务E)那份<strong>注册清单</strong>。A、B、C、D四个服务互相调用不再通过具体的IP地址，而是<strong>通过服务名来调用</strong>！</p><ul><li>拿到注册清单—&gt;注册清单上有服务名—&gt;自然就能够拿到服务具体的位置了(IP)。</li><li>其实简单来说就是：代码中通过<strong>服务名找到对应的IP地址</strong>(IP地址会变，但服务名一般不会变)</li></ul><p><img src="https://pic1.zhimg.com/50/v2-5913ec6dc3604a877fca57cf77e35247_hd.jpg?source=1940ef5c" alt="img" class="article-img"><img src="https://pic1.zhimg.com/80/v2-5913ec6dc3604a877fca57cf77e35247_1440w.jpg?source=1940ef5c" alt="img" class="article-img"></p><h3 id="eureka服务治理机制"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#eureka服务治理机制"></a> Eureka服务治理机制<a href="spring&mybatis/Spring Cloud#eureka服务治理机制"></a></h3><p>Eureka专门用于给其他服务注册的称为Eureka Server(服务注册中心)，其余注册到Eureka Server的服务称为Eureka Client</p><p>在Eureka Server一般我们会这样配置：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">register-with-eureka:</span> <span class="literal">false</span>     <span class="comment">#false表示不向注册中心注册自己。</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span>     <span class="comment">#false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务</span></span><br></pre></td></tr></table></div></figure><p>Eureka Client<strong>分为服务提供者和服务消费者</strong>。</p><ul><li>但很可能，某服务<strong>既是服务提供者又是服务消费者</strong>。</li></ul><p>如果在网上看到SpringCloud的<strong>某个服务配置没有&quot;注册&quot;到Eureka-Server也不用过于惊讶</strong>(但是它是可以获取Eureka服务清单的)</p><ul><li>很可能只是作者把该服务认作为<strong>单纯的服务消费者</strong>，单纯的服务消费者无需对外提供服务，也就无须注册到Eureka中了</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>  <span class="comment"># 当前微服务不注册到eureka中(消费端)</span></span><br><span class="line"><span class="attr">    service-url:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/,http://eureka7003.com:7003/eureka/</span></span><br></pre></td></tr></table></div></figure><p>下面是Eureka的治理机制：</p><ul><li><p>服务提供者</p><ul><li><strong>服务注册：启动的时候会通过发送REST请求的方式将自己注册到Eureka Server上</strong>，同时带上了自身服务的一些元数据信息。</li><li>**服务续约：**在注册完服务之后，<strong>服务提供者会维护一个心跳</strong>用来持续告诉Eureka Server: &quot;我还活着 ” 、</li><li><strong>服务下线：当服务实例进行正常的关闭操作时，它会触发一个服务下线的REST请求</strong>给Eureka Server, 告诉服务注册中心：“我要下线了 ”。</li></ul></li><li><p>服务消费者</p><ul><li><strong>获取服务：当我们启动服务消费者</strong>的时候，它会发送一个REST请求给服务注册中心，来获取上面注册的服务清单</li><li><strong>服务调用：服务消费者在获取服务清单后，通过服务名</strong>可以获得具体提供服务的实例名和该实例的元数据信息。在进行服务调用的时候，<strong>优先访问同处一个Zone中的服务提供方</strong>。</li></ul></li><li><p>Eureka Server(服务注册中心)：</p><ul><li>**失效剔除：**默认每隔一段时间（默认为60秒） 将当前清单中超时（默认为90秒）<strong>没有续约的服务剔除出去</strong>。</li><li><strong>自我保护：</strong>。EurekaServer 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%(通常由于网络不稳定导致)。 Eureka Server会将当前的<strong>实例注册信息保护起来</strong>， 让这些实例不会过期，尽可能<strong>保护这些注册信息</strong>。</li></ul></li></ul><p>最后，我们就有了这张图：<img src="https://pic1.zhimg.com/80/v2-22ac91d35e2f2da97c6e8fd70c359f84_1440w.jpg?source=1940ef5c" alt="img"></p><p>举个例子：</p><ul><li>3y跟女朋友去东站的东方宝泰逛街，但不知道东方宝泰有什么好玩的。于是就去<strong>物业</strong>搜了一下<strong>东方宝泰商户清单</strong>，发现一楼有优衣库，二楼有星巴克，三楼有麦当劳。</li><li>在优衣库旁边，有新开张的KFC，在墙壁打上了很大的标识“欢迎KFC<strong>入驻</strong>东方宝泰”。</li><li>商家们需要定时<strong>交物业费</strong>给物业。</li><li><strong>物业维持</strong>东方宝泰的稳定性。如果某个商家不想在东方宝泰运营了，告诉了物业。物业自然就会将其在东方宝泰商户清单去除。</li></ul><h3 id="服务注册与发现"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#服务注册与发现"></a> 服务注册与发现<a href="spring&mybatis/Spring Cloud#服务注册与发现"></a></h3><h4 id="创建服务注册中心"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#创建服务注册中心"></a> 创建“服务注册中心”<a href="spring&mybatis/Spring Cloud#创建服务注册中心"></a></h4><p>创建一个基础的Spring Boot工程，命名为<code>eureka-server</code>，并在<code>pom.xml</code>中引入需要的依赖内容：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>通过<code>@EnableEurekaServer</code>注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class)</span><br><span class="line">                    .web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在<code>application.properties</code>配置文件中增加如下信息：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=eureka-server</span><br><span class="line">server.port=1001</span><br><span class="line"></span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">eureka.client.fetch-registry=false</span><br></pre></td></tr></table></div></figure><p>为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：<a href="http://localhost:1001/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%8B%E9%9D%A2%E7%9A%84%E9%A1%B5%E9%9D%A2%EF%BC%8C%E5%85%B6%E4%B8%AD%E8%BF%98%E6%B2%A1%E6%9C%89%E5%8F%91%E7%8E%B0%E4%BB%BB%E4%BD%95%E6%9C%8D%E5%8A%A1%E3%80%82" target="_blank" rel="noopener">http://localhost:1001/，可以看到下面的页面，其中还没有发现任何服务。</a></p><p><a href="http://blog.didispace.com/content/images/posts/spring-cloud-starter-dalston-1-1.png" target="_blank" rel="noopener"><img src="http://blog.didispace.com/content/images/posts/spring-cloud-starter-dalston-1-1.png" alt="img"></a></p><h4 id="创建服务提供方"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#创建服务提供方"></a> 创建“服务提供方”<a href="spring&mybatis/Spring Cloud#创建服务提供方"></a></h4><p>下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。</p><p>首先，创建一个基本的Spring Boot应用。命名为<code>eureka-client</code>，在<code>pom.xml</code>中，加入如下配置：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>Dalston.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/dc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String services = <span class="string">"Services: "</span> + discoveryClient.getServices();</span><br><span class="line">        System.out.println(services);</span><br><span class="line">        <span class="keyword">return</span> services;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>最后在应用主类中通过加上<code>@EnableDiscoveryClient</code>注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(</span><br><span class="line">            ComputeServiceApplication.class)</span><br><span class="line">            .web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们在完成了服务内容的实现之后，再继续对<code>application.properties</code>做一些配置工作，具体如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-client</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">2001</span></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1001/eureka/</span></span><br></pre></td></tr></table></div></figure><p>通过<code>spring.application.name</code>属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。<code>eureka.client.serviceUrl.defaultZone</code>属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用<code>server.port</code>属性设置不同的端口。</p><p>启动该工程后，再次访问：<a href="http://localhost:1001/%E3%80%82%E5%8F%AF%E4%BB%A5%E5%A6%82%E4%B8%8B%E5%9B%BE%E5%86%85%E5%AE%B9%EF%BC%8C%E6%88%91%E4%BB%AC%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%A2%AB%E6%88%90%E5%8A%9F%E6%B3%A8%E5%86%8C%E4%BA%86%E3%80%82" target="_blank" rel="noopener">http://localhost:1001/。可以如下图内容，我们定义的服务被成功注册了。</a></p><p><a href="http://blog.didispace.com/content/images/posts/spring-cloud-starter-dalston-1-2.png" target="_blank" rel="noopener"><img src="http://blog.didispace.com/content/images/posts/spring-cloud-starter-dalston-1-2.png" alt="img"></a></p><p>当然，我们也可以通过直接访问<code>eureka-client</code>服务提供的<code>/dc</code>接口来获取当前的服务清单，只需要访问：<a href="http://localhost:2001/dc%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E5%A6%82%E4%B8%8B%E8%BE%93%E5%87%BA%E8%BF%94%E5%9B%9E%EF%BC%9A" target="_blank" rel="noopener">http://localhost:2001/dc，我们可以得到如下输出返回：</a></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Services: [eureka-client]</span><br></pre></td></tr></table></div></figure><p>其中，方括号中的<code>eureka-client</code>就是通过Spring Cloud定义的<code>DiscoveryClient</code>接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中区。</p><p>我们已经成功地将服务提供者：eureka-client或consul-client注册到了Eureka服务注册中心或Consul服务端上了，同时我们也通过<code>DiscoveryClient</code>接口的<code>getServices</code>获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务提供者的接口？</p><h3 id="使用loadbalancerclient"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#使用loadbalancerclient"></a> 使用LoadBalancerClient<a href="spring&mybatis/Spring Cloud#使用loadbalancerclient"></a></h3><p>在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括<code>DiscoveryClient</code>、这里我们即将介绍的<code>LoadBalancerClient</code>等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。</p><p>从<code>LoadBalancerClient</code>接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。</p><p>下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。</p><ul><li>我们先来创建一个服务消费者工程，命名为：<code>eureka-consumer</code>。并在<code>pom.xml</code>中引入依赖（这里省略了parent和dependencyManagement的配置）：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>配置<code>application.properties</code>，指定eureka注册中心的地址：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">eureka-consumer</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">2101</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.serviceUrl.defaultZone</span>=<span class="string">http://localhost:1001/eureka/</span></span><br></pre></td></tr></table></div></figure><ul><li>创建应用主类。初始化<code>RestTemplate</code>，用来真正发起REST请求。<code>@EnableDiscoveryClient</code>注解用来将当前应用加入到服务治理体系中。</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>创建一个接口用来消费eureka-client提供的接口：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    LoadBalancerClient loadBalancerClient;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ServiceInstance serviceInstance = loadBalancerClient.choose(<span class="string">"eureka-client"</span>);</span><br><span class="line">        String url = <span class="string">"http://"</span> + serviceInstance.getHost() + <span class="string">":"</span> + serviceInstance.getPort() + <span class="string">"/dc"</span>;</span><br><span class="line">        System.out.println(url);</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到这里，我们注入了<code>LoadBalancerClient</code>和<code>RestTemplate</code>，并在<code>/consumer</code>接口的实现中，先通过<code>loadBalancerClient</code>的<code>choose</code>函数来负载均衡的选出一个<code>eureka-client</code>的服务实例，这个服务实例的基本信息存储在<code>ServiceInstance</code>中，然后通过这些对象中的信息拼接出访问<code>/dc</code>接口的详细地址，最后再利用<code>RestTemplate</code>对象实现对服务提供者接口的调用。</p><p>在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的<code>/dc</code>接口的</p><h2 id="spring-cloud-ribbon"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#spring-cloud-ribbon"></a> Spring Cloud Ribbon<a href="spring&mybatis/Spring Cloud#spring-cloud-ribbon"></a></h2><p>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</p><p>当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。</p><p>而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。</p><p>我们在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡。</p><p>负载均衡有两种类型：</p><ul><li><p>客户端负载均衡(Ribbon)</p></li><li><ul><li>服务实例的<strong>清单在客户端</strong>，客户端进行负载均衡算法分配。</li><li>(从上面的知识我们已经知道了：客户端可以从Eureka Server中得到一份服务清单，在发送请求时通过负载均衡算法，<strong>在多个服务器之间选择一个进行访问</strong>)</li></ul></li><li><p>服务端负载均衡(Nginx)</p></li><li><ul><li>服务实例的<strong>清单在服务端</strong>，服务器进行负载均衡算法分配</li></ul></li></ul><p>所以，我们的图可以画成这样：</p><p><img src="https://pic2.zhimg.com/50/v2-3cebcf81da382b55f4e9e740b48c727e_hd.jpg?source=1940ef5c" alt="img" class="article-img"><img src="https://pic2.zhimg.com/80/v2-3cebcf81da382b55f4e9e740b48c727e_1440w.jpg?source=1940ef5c" alt="img" class="article-img"></p><p>Ribbon是支持负载均衡，默认的负载均衡策略是轮询，我们也是可以根据自己实际的需求自定义负载均衡策略的。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySelfRule</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">myRule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//return new RandomRule();// Ribbon默认是轮询，我自定义为随机</span></span><br><span class="line"><span class="comment">//return new RoundRobinRule();// Ribbon默认是轮询，我自定义为随机</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RandomRule_ZY();<span class="comment">// 我自定义为每台机器5次</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>实现起来也很简单：继承AbstractLoadBalancerRule类，重写<code>public Server choose(ILoadBalancer lb, Object key)</code>即可。</p><p>SpringCloud 在CAP理论是选择了AP的，在Ribbon中还可以配置<strong>重试机制</strong>的</p><p>下面我们通过具体的例子来看看如何使用Spring Cloud Ribbon来实现服务的调用以及客户端均衡负载。</p><h3 id="项目修改"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#项目修改"></a> 项目修改<a href="spring&mybatis/Spring Cloud#项目修改"></a></h3><p>我们将利用之前构建的<code>eureka-server</code>作为服务注册中心、<code>eureka-client</code>作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据<code>eureka-consumer</code>实现的内容进行简单改在就能完成，具体步骤如下：</p><ul><li>根据<code>eureka-consumer</code>复制一个服务消费者工程，命名为：<code>eureka-consumer-ribbon</code>。在<code>pom.xml</code>中增加下面的依赖：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>修改应用主类。为<code>RestTemplate</code>增加<code>@LoadBalanced</code>注解：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>修改Controller。去掉原来通过<code>LoadBalancerClient</code>选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(<span class="string">"http://eureka-client/dc"</span>, String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以看到这里，我们除了去掉了原来与<code>LoadBalancerClient</code>相关的逻辑之外，对于<code>RestTemplate</code>的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。</p><p>将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的<code>/dc</code>接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。</p><h2 id="spring-cloud-feign"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#spring-cloud-feign"></a> Spring Cloud Feign<a href="spring&mybatis/Spring Cloud#spring-cloud-feign"></a></h2><p>Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p><p>下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。</p><h3 id="项目修改-2"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#项目修改-2"></a> 项目修改<a href="spring&mybatis/Spring Cloud#项目修改-2"></a></h3><p>下面的例子，我们将利用之前构建的<code>eureka-server</code>作为服务注册中心、<code>eureka-client</code>作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据<code>eureka-consumer</code>实现的内容进行简单改在就能完成，具体步骤如下：</p><ul><li>根据<code>eureka-consumer</code>复制一个服务消费者工程，命名为：<code>eureka-consumer-feign</code>。在<code>pom.xml</code>中增加下面的依赖：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>修改应用主类。通过<code>@EnableFeignClients</code>注解开启扫描Spring Cloud Feign客户端的功能：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>创建一个Feign的客户端接口定义。使用<code>@FeignClient</code>注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定<code>eureka-client</code>服务的<code>/dc</code>接口的例子：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"eureka-client"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DcClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/1"</span>)</span><br><span class="line">    <span class="function">String <span class="title">consumer1</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/2"</span>)</span><br><span class="line">    <span class="function">String <span class="title">consumer2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>修改Controller。通过定义的feign客户端来调用服务提供方的接口：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DcController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DcClient dcClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/consumer1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dcClient.consumer1();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@GetMapping</span>(<span class="string">"/consumer2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dcClient.consumer2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过<code>@FeignClient</code>定义的接口来统一的声明我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。</p><p>将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-feign服务是如何消费eureka-client服务的<code>/dc</code>接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。</p><h3 id="feign-传输文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#feign-传输文件"></a> Feign 传输文件<a href="spring&mybatis/Spring Cloud#feign-传输文件"></a></h3><p>在Spring Cloud封装的Feign中并不直接支持传文件，但可以通过引入Feign的扩展包来实现，本来就来具体说说如何实现。</p><h4 id="服务提供方接收文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#服务提供方接收文件"></a> 服务提供方（接收文件）<a href="spring&mybatis/Spring Cloud#服务提供方接收文件"></a></h4><p>服务提供方的实现比较简单，就按Spring MVC的正常实现方式即可，比如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RestController</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@PostMapping</span>(value = <span class="string">"/uploadFile"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">handleFileUpload</span><span class="params">(@RequestPart(value = <span class="string">"file"</span>)</span> MultipartFile file) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> file.getName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="服务消费方发送文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#服务消费方发送文件"></a> 服务消费方（发送文件）<a href="spring&mybatis/Spring Cloud#服务消费方发送文件"></a></h4><p>在服务消费方由于会使用Feign客户端，所以在这里需要在引入feign对表单提交的依赖，具体如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>定义文件上传方的应用主类和FeignClient，假设服务提供方的服务名为<code>eureka-feign-upload-server</code></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"upload-server"</span>, configuration = UploadService.MultipartSupportConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UploadService</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@PostMapping</span>(value = <span class="string">"/uploadFile"</span>, consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span><br><span class="line">    <span class="function">String <span class="title">handleFileUpload</span><span class="params">(@RequestPart(value = <span class="string">"file"</span>)</span> MultipartFile file)</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Configuration</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultipartSupportConfig</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Bean</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Encoder <span class="title">feignFormEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SpringFormEncoder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在启动了服务提供方之后，尝试在服务消费方编写测试用例来通过上面定义的Feign客户端来传文件，比如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadTester</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UploadService uploadService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHandleFileUpload</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"upload.txt"</span>);</span><br><span class="line">        DiskFileItem fileItem = (DiskFileItem) <span class="keyword">new</span> DiskFileItemFactory().createItem(<span class="string">"file"</span>,</span><br><span class="line">                MediaType.TEXT_PLAIN_VALUE, <span class="keyword">true</span>, file.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (InputStream input = <span class="keyword">new</span> FileInputStream(file); OutputStream os = fileItem.getOutputStream()) &#123;</span><br><span class="line">            IOUtils.copy(input, os);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid file: "</span> + e, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        MultipartFile multi = <span class="keyword">new</span> CommonsMultipartFile(fileItem);</span><br><span class="line"></span><br><span class="line">        log.info(uploadService.handleFileUpload(multi));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="spring-cloud-config"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#spring-cloud-config"></a> Spring Cloud Config<a href="spring&mybatis/Spring Cloud#spring-cloud-config"></a></h2><p>Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。</p><p>在本文中，我们将学习如何构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其能够从配置中心获取配置信息并绑定到代码中的整个过程。</p><h3 id="准备配置仓库"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#准备配置仓库"></a> 准备配置仓库<a href="spring&mybatis/Spring Cloud#准备配置仓库"></a></h3><ul><li>准备一个git仓库，可以在码云或Github上创建都可以。<ul><li><a href="https://gitee.com/ilucia/config_demo" target="_blank" rel="noopener">https://gitee.com/ilucia/config_demo</a></li></ul></li><li>假设我们读取配置中心的应用名为<code>config-client</code>，那么我们可以在git仓库中创建该项目的默认配置文件<code>config-client.yml</code>：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="attr">  profile:</span> <span class="string">default</span></span><br></pre></td></tr></table></div></figure><ul><li>为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件<code>config-client-dev.yml</code>：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">info:</span></span><br><span class="line"><span class="attr">  profile:</span> <span class="string">dev</span></span><br></pre></td></tr></table></div></figure><h3 id="构建配置中心"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#构建配置中心"></a> 构建配置中心<a href="spring&mybatis/Spring Cloud#构建配置中心"></a></h3><p>通过Spring Cloud Config来构建一个分布式配置中心非常简单，只需要三步：</p><ul><li>创建一个基础的Spring Boot工程，命名为：<code>config-server-git</code>，并在<code>pom.xml</code>中引入下面的依赖（省略了parent和dependencyManagement部分）：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>创建Spring Boot的程序主类，并添加<code>@EnableConfigServer</code>注解，开启Spring Cloud Config的服务端功能。</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>在<code>application.yml</code>中添加配置服务的基本信息以及Git仓库的相关信息，例如：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config-server</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      server:</span></span><br><span class="line"><span class="attr">        git:</span></span><br><span class="line"><span class="attr">          uri:</span> <span class="attr">https://gitee.com/ilucia/config_demo</span></span><br><span class="line"><span class="attr">          username:</span> <span class="string">ilucia</span></span><br><span class="line"><span class="attr">          password:</span> <span class="number">321324543</span><span class="string">x</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">1201</span></span><br></pre></td></tr></table></div></figure><p>到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。</p><blockquote><p>如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现；<br>spring.cloud.config.server.git.username：访问Git仓库的用户名<br>spring.cloud.config.server.git.password：访问Git仓库的用户密码</p></blockquote><p>完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下：</p><ul><li>/{application}/{profile}[/{label}]</li><li>/{application}-{profile}.yml</li><li>/{label}/{application}-{profile}.yml</li><li>/{application}-{profile}.properties</li><li>/{label}/{application}-{profile}.properties</li></ul><p>上面的url会映射<code>{application}-{profile}.properties</code>对应的配置文件，其中<code>{label}</code>对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url：<code>http://localhost:1201/config-client/dev/master</code>，并获得如下返回：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"config-client"</span>,</span><br><span class="line">    <span class="attr">"profiles"</span>: [</span><br><span class="line">        <span class="string">"dev"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"label"</span>: <span class="string">"master"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"state"</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">"propertySources"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"https://gitee.com/ilucia/config_demo/config-client-dev.yml"</span>,</span><br><span class="line">            <span class="attr">"source"</span>: &#123;</span><br><span class="line">                <span class="attr">"info.profile"</span>: <span class="string">"dev"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"https://gitee.com/ilucia/config_demo/config-client.yml"</span>,</span><br><span class="line">            <span class="attr">"source"</span>: &#123;</span><br><span class="line">                <span class="attr">"info.profile"</span>: <span class="string">"default"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。</p><h3 id="构建客户端"><a class="markdownIt-Anchor" href="spring&mybatis/Spring Cloud#构建客户端"></a> 构建客户端<a href="spring&mybatis/Spring Cloud#构建客户端"></a></h3><p>在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。</p><ul><li>创建一个Spring Boot应用，命名为<code>config-client</code>，并在<code>pom.xml</code>中引入下述依赖：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>创建Spring Boot的应用主类，具体如下：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> SpringApplicationBuilder(Application.class).web(<span class="keyword">true</span>).run(args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>创建<code>bootstrap.yml</code>配置，来指定获取配置文件的<code>config-server-git</code>位置，例如：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">config-client</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    config:</span></span><br><span class="line"><span class="attr">      uri:</span> <span class="attr">http://localhost:1201/</span></span><br><span class="line"><span class="attr">      profile:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">      label:</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">2001</span></span><br></pre></td></tr></table></div></figure><p>上述配置参数与Git中存储的配置文件中各个部分的对应关系如下：</p><ul><li><a href="http://spring.application.name" target="_blank" rel="noopener">spring.application.name</a>：对应配置文件规则中的<code>{application}</code>部分</li><li>spring.cloud.config.profile：对应配置文件规则中的<code>{profile}</code>部分</li><li>spring.cloud.config.label：对应配置文件规则中的<code>{label}</code>部分</li><li>spring.cloud.config.uri：配置中心<code>config-server</code>的地址</li></ul><p><strong>这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载。</strong></p><p>在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问http://localhost:2001/info ，我们可以看到该端点将会返回从git仓库中获取的配置信息：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"profile"</span>: <span class="string">"default"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>另外，我们也可以修改config-client的profile为dev来观察加载配置的变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-cloud&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;spring&amp;mybatis/Spring Cloud#spring-cloud&quot;&gt;&lt;/a&gt; Spring Cloud&lt;a href=&quot;spring&amp;mybatis/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring&amp;mybatis/Spring IoC</title>
    <link href="ilucia.github.io/spring&amp;mybatis/Spring%20IoC/"/>
    <id>ilucia.github.io/spring&amp;mybatis/Spring%20IoC/</id>
    <published>2022-04-27T15:24:01.747Z</published>
    <updated>2022-04-27T15:24:01.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-ioc"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#spring-ioc"></a> Spring IoC<a href="spring&mybatis/Spring IoC#spring-ioc"></a></h1><h2 id="ioc"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#ioc"></a> IoC<a href="spring&mybatis/Spring IoC#ioc"></a></h2><h5 id="ioc的概念"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#ioc的概念"></a> IoC的概念<a href="spring&mybatis/Spring IoC#ioc的概念"></a></h5><ul><li>简单点儿说，IoC的理念就是，让别人为你服务！</li><li>通常情况下，被注入对象会直接依赖于被依赖对象。但是，在IoC的场景中，二者之间通过<strong>IoC Service Provider</strong>来打交道，所有的被注入对象和依赖对象现在由IoC Service Provider统一管理。被注入对象需要什么，直接跟IoC Service Provider招呼一声，后者就会把相应的被依赖对象注入到被注入对象中，从而达到IoC Service Provider为被注入对象服务的目的</li><li>IoC Service Provider在这里就是通常的IoC容器所充当的角色。从被注入对象的角度看，<strong>与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转</strong>，<strong>控制也从被注入对象转到了IoC Service Provider那里</strong></li><li><strong>原来是需要什么东西自己去拿，现在是需要什么东西就让别人送过来</strong></li><li><strong>IoC是一种可以帮助我们解耦各业务对象间依赖关系的对象绑定方式</strong></li></ul><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/IoC%E7%9A%84%E8%A7%92%E8%89%B2.png" alt="" class="article-img"></p><h3 id="依赖注入"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#依赖注入"></a> 依赖注入<a href="spring&mybatis/Spring IoC#依赖注入"></a></h3><ul><li><strong>接口注入</strong><ul><li>从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，<strong>带有侵入性</strong>。而构造方法注入和setter方法注入则不需要如此</li></ul></li><li><strong>构造方法注入</strong><ul><li>这种注入方式的优点就是，<strong>对象在构造完成之后，即已进入就绪状态，可以马上使用</strong></li><li>缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法<strong>无法被继承，无法设置默认值</strong>。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便</li></ul></li><li><strong>setter方法注入</strong><ul><li>因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。另外，setter方法<strong>可以被继承，允许设置默认值</strong>，而且有良好的IDE支持</li><li>缺点当然就是<strong>对象无法在构造完成后马上进入就绪状态</strong></li></ul></li></ul><h2 id="ioc-service-provider"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#ioc-service-provider"></a> IoC Service Provider<a href="spring&mybatis/Spring IoC#ioc-service-provider"></a></h2><h5 id="概念"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#概念"></a> 概念<a href="spring&mybatis/Spring IoC#概念"></a></h5><ul><li>它可以指代<strong>任何将IoC场景中的业务对象绑定到一起</strong>的实现方式</li><li><strong>Spring的IoC容器</strong>就是一个<strong>提供依赖注入服务的IoC Service Provider</strong></li><li>IoC Service Provider的职责<ul><li>业务对象的构建管理</li><li>业务对象间的依赖绑定</li></ul></li></ul><h3 id="ioc-service-provider-如何管理对象间的依赖关系"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#ioc-service-provider-如何管理对象间的依赖关系"></a> IoC Service Provider 如何管理对象间的依赖关系<a href="spring&mybatis/Spring IoC#ioc-service-provider-如何管理对象间的依赖关系"></a></h3><h5 id="直接编码方式"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#直接编码方式"></a> 直接编码方式<a href="spring&mybatis/Spring IoC#直接编码方式"></a></h5><ul><li><p>通过<strong>程序编码</strong>的方式<strong>将被注入对象和依赖对象注册到容器中</strong>，并<strong>明确它们相互之间的依赖注入关系</strong></p></li><li><p>通过<strong>为相应的类指定对应的具体实例</strong>，可以告知IoC容器，当我们要这种类型的对象实例时，将容器中注册的、对应的那个具体实例返回给我们</p><p><code>IoContainer container = ...;</code><br><code>container.register(FXNewsProvider.class,new FXNewsProvider());</code><br><code>container.register(IFXNewsListener.class,new DowJonesNewsListener());</code><br><code>...</code><br><code>FXNewsProvider newsProvider = (FXNewsProvider)container.get(FXNewsProvider.class);</code><br><code>newProvider.getAndPersistNews();</code></p></li></ul><h5 id="直接编码方式-接口注入"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#直接编码方式-接口注入"></a> 直接编码方式-接口注入<a href="spring&mybatis/Spring IoC#直接编码方式-接口注入"></a></h5><ul><li><p>除了注册相应对象，还要<strong>将“注入标志接口”与相应的依赖对象绑定</strong>一下</p><p><code>IoContainer container = ...;</code><br><code>container.register(FXNewsProvider.class,new FXNewsProvider());</code><br><code>container.register(IFXNewsListener.class,new DowJonesNewsListener());</code><br><code>...</code><br><strong><code>container.bind(IFXNewsListenerCallable.class, container.get(IFXNewsListener.class));</code></strong><br><code>...</code><br><code>FXNewsProvider newsProvider = (FXNewsProvider)container.get(FXNewsProvider.class);</code><br><code>newProvider.getAndPersistNews();</code></p></li><li><p>通过<strong>bind方法</strong>将“被注入对象”（由IFXNewsListenerCallable接口添加标志）所依赖的对象，绑定为容器中注册过的IFXNewsListener类型的对象实例</p></li><li><p>容器在返回FXNewsProvider对象实例之前，会<strong>根据这个绑定信息</strong>，将IFXNewsListener注册到容器中的对象实例<strong>注入到“被注入对象”</strong>——FXNewsProvider中，并最终返回已经组装完毕FXNewsProvider对象</p></li></ul><h5 id="配置文件方式"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#配置文件方式"></a> 配置文件方式<a href="spring&mybatis/Spring IoC#配置文件方式"></a></h5><ul><li>通过XML文件来管理对象注册和对象间依赖关系</li></ul><h5 id="注解方式"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#注解方式"></a> 注解方式<a href="spring&mybatis/Spring IoC#注解方式"></a></h5><ul><li>直接在类中<strong>使用元数据信息来标注各个对象之间的依赖关系</strong>，然后<strong>由Guice框架根据这些注解所提供的信息将这些对象组装</strong>后，交给客户端对象使用</li><li>通过**@Inject**，我们指明需要IoC Service Provider<strong>通过构造方法注入方式</strong>，为FXNewsProvider注入其所依赖的对象。至于余下的<strong>依赖相关信息</strong>，<strong>在Guice中是由相应的Module来提供的</strong><ul><li>通过Module指定进一步的依赖注入相关信息之后，我们就可以直接从Guice那里取得最终已经注入完毕，并直接可用的对象了</li></ul></li><li><strong>注解最终也要通过代码处理来确定最终的注入关系</strong>，从这点儿来说，注解方式可以算作编码方式的一种特殊情况</li></ul><h2 id="beanfactory"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#beanfactory"></a> BeanFactory<a href="spring&mybatis/Spring IoC#beanfactory"></a></h2><h3 id="beanfactory和applicationcontext"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#beanfactory和applicationcontext"></a> BeanFactory和ApplicationContext<a href="spring&mybatis/Spring IoC#beanfactory和applicationcontext"></a></h3><ul><li>BeanFactory<ul><li>基础类型IoC容器，提供完整的IoC服务支持</li><li>默认采用<strong>延迟初始化策略</strong>（lazy-load）<ul><li>只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作</li><li>容器启动初期速度较快，所需要的资源有限</li></ul></li><li>对于<strong>资源有限，并且功能要求不是很严格</strong>的场景，BeanFactory是比较合适的IoC容器选择</li></ul></li><li>ApplicationContext<ul><li>在BeanFactory的基础上构建，拥有BeanFactory的所有支持，还提供了其他高级特性<ul><li>ApplicationContext<strong>间接继承自BeanFactory</strong>，所以说它是构建于BeanFactory之上的IoC容器</li></ul></li><li>ApplicationContext所管理的对象，在该类型<strong>容器启动之后，默认全部初始化并绑定完成</strong><ul><li><strong>要求更多的系统资源</strong>，同时，因为在启动时就完成所有初始化，<strong>容器启动时间较</strong>之BeanFactory也会<strong>长</strong>一些</li></ul></li><li>在那些<strong>系统资源充足，并且要求更多功能</strong>的场景中，ApplicationContext类型的容器是比较合适的选择</li></ul></li></ul><h3 id="beanfactory概念"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#beanfactory概念"></a> BeanFactory概念<a href="spring&mybatis/Spring IoC#beanfactory概念"></a></h3><ul><li>BeanFactory，顾名思义，就是<strong>生产Bean的工厂</strong><ul><li><strong>把每个业务对象看作一个JavaBean对象</strong></li><li>BeanFactory就像一个汽车生产厂。你从其他汽车零件厂商或者自己的零件生产部门取得汽车零件送入这个汽车生产厂，最后，只需要从生产线的终点取得成品汽车就可以了。相似地，将应用所需的所有业务对象交给BeanFactory之后，剩下要做的，就是直接从BeanFactory取得最终组装完成并且可用的对象。至于这个最终业务对象如何组装，你不需要关心，BeanFactory会帮你搞定</li><li>BeanFactory肯定<strong>会公开一个取得组装完成的对象的方法接口</strong></li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123; </span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>; </span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Class requiredType)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.5 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object[] args)</span> <span class="keyword">throws</span> BeansException</span>; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.3 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>; </span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 2.0.1 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class targetType)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>; </span><br><span class="line">    <span class="function">Class <span class="title">getType</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>; </span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><p>上面代码中的方法基本上都是<strong>查询相关的方法</strong>，例如，取得某个对象的方法（getBean）、查询某个对象是否存在于容器中的方法（containsBean），或者取得某个bean的状态或者类型的方法等</p><ul><li>因为通常情况下，对于独立的应用程序，只有主入口类才会跟容器的API直接耦合。</li></ul></li><li><p>使用BeanFactory<strong>前后唯一的不同，就是对象之间依赖关系的解决方式改变了</strong></p></li></ul><h5 id="fx新闻应用设计和实现框架代码"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#fx新闻应用设计和实现框架代码"></a> FX新闻应用设计和实现框架代码<a href="spring&mybatis/Spring IoC#fx新闻应用设计和实现框架代码"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设计FXNewsProvider类用于普遍的新闻处理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FXNewsProvider</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//设计IFXNewsListener接口抽象各个新闻社不同的新闻获取方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFXNewsListener</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//给出相应实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsListener</span> <span class="keyword">implements</span> <span class="title">IFXNewsListener</span></span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//设计IFXNewsPersister接口抽象不同数据访问方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFXNewsPersister</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">... </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//实现相应的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DowJonesNewsPersister</span> <span class="keyword">implements</span> <span class="title">IFXNewsPersister</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><strong>BeanFactory</strong>会<strong>通过常用的XML文件来注册并管理各个业务对象之间的依赖关系</strong></li></ul><h3 id="beanfactory的对象注册与依赖绑定方式"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#beanfactory的对象注册与依赖绑定方式"></a> BeanFactory的对象注册与依赖绑定方式<a href="spring&mybatis/Spring IoC#beanfactory的对象注册与依赖绑定方式"></a></h3><ul><li>为了能够明确<strong>管理各个业务对象以及业务对象之间的依赖绑定关系</strong>，需要某种途径来记录和管理这些信息<ul><li>直接编码，配置文件，元数据</li></ul></li></ul><h4 id="直接编码"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#直接编码"></a> 直接编码<a href="spring&mybatis/Spring IoC#直接编码"></a></h4><ul><li>BeanFactory只是一个接口，我们最终<strong>需要一个该接口的实现来进行实际的Bean的管理</strong></li><li><strong>BeanFactory接口只定义如何访问容器内管理的Bean的方法</strong>，各个BeanFactory的具体实现类负责具体Bean的注册以及管理工作</li><li><strong>BeanDefinitionRegistry接口才是在BeanFactory的实现中担当Bean注册管理的角色</strong><ul><li>通常情况下，具体的BeanFactory实现类会实现这个接口来管理Bean的注册</li></ul></li><li>打个比方说，<strong>BeanDefinitionRegistry就像图书馆的书架</strong>，所有的书是放在书架上的。虽然你还书或者借书都是跟<strong>图书馆</strong>（也就是<strong>BeanFactory</strong>，或许BookFactory可能更好些）打交道，但书架才是存放各类图书的地方</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory(); </span><br><span class="line">    BeanFactory container = (BeanFactory)bindViaCode(beanRegistry); </span><br><span class="line">    FXNewsProvider newsProvider = ➥</span><br><span class="line">    (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>); </span><br><span class="line">    newsProvider.getAndPersistNews(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaCode</span><span class="params">(BeanDefinitionRegistry registry)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    AbstractBeanDefinition newsProvider = ➥</span><br><span class="line">    <span class="keyword">new</span> RootBeanDefinition(FXNewsProvider.class,<span class="keyword">true</span>); </span><br><span class="line">    AbstractBeanDefinition newsListener = ➥</span><br><span class="line">    <span class="keyword">new</span> RootBeanDefinition(DowJonesNewsListener.class,<span class="keyword">true</span>); </span><br><span class="line">    AbstractBeanDefinition newsPersister = ➥</span><br><span class="line">    <span class="keyword">new</span> RootBeanDefinition(DowJonesNewsPersister.class,<span class="keyword">true</span>); </span><br><span class="line">    <span class="comment">// 将bean定义注册到容器中</span></span><br><span class="line">    registry.registerBeanDefinition(<span class="string">"djNewsProvider"</span>, newsProvider); </span><br><span class="line">    registry.registerBeanDefinition(<span class="string">"djListener"</span>, newsListener); </span><br><span class="line">    registry.registerBeanDefinition(<span class="string">"djPersister"</span>, newsPersister); </span><br><span class="line">    <span class="comment">// 指定依赖关系</span></span><br><span class="line">    <span class="comment">// 1. 可以通过构造方法注入方式</span></span><br><span class="line">    ConstructorArgumentValues argValues = <span class="keyword">new</span> ConstructorArgumentValues(); </span><br><span class="line">    argValues.addIndexedArgumentValue(<span class="number">0</span>, newsListener); </span><br><span class="line">    argValues.addIndexedArgumentValue(<span class="number">1</span>, newsPersister); </span><br><span class="line">    newsProvider.setConstructorArgumentValues(argValues); </span><br><span class="line">    <span class="comment">// 2. 或者通过setter方法注入方式</span></span><br><span class="line">    MutablePropertyValues propertyValues = <span class="keyword">new</span> MutablePropertyValues(); </span><br><span class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> ropertyValue(<span class="string">"newsListener"</span>,newsListener)); </span><br><span class="line">    propertyValues.addPropertyValue(<span class="keyword">new</span> PropertyValue(<span class="string">"newPersistener"</span>,newsPersister)); </span><br><span class="line">    newsProvider.setPropertyValues(propertyValues); </span><br><span class="line">    <span class="comment">// 绑定完成</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      因为传入的DefaultListableBeanFactory同时实现了BeanFactory和</span></span><br><span class="line"><span class="comment">      BeanDefinitionRegistry接口，所以，这样做强制类型转换不会出现问题。但需要注意的是，单纯</span></span><br><span class="line"><span class="comment">      的BeanDefinitionRegistry是无法强制转换到BeanFactory类型的</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">return</span> (BeanFactory)registry; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>在 main 方法中，<strong>首先构造一个 DefaultListableBeanFactory 作 为 BeanDefinition Registry</strong>，<strong>然后将其交给bindViaCode方法进行具体的对象注册和相关依赖管理</strong>，<strong>然后通过bindViaCode返回的BeanFactory取得需要的对象</strong>，<strong>最后执行相应逻辑</strong>。在我们的实例里，当然就是取得FXNewsProvider进行新闻的处理</li><li>在bindViaCode方法中，<strong>首先针对相应的业务对象构造与其相对应的BeanDefinition</strong>，使用了 RootBeanDefinition 作 为 BeanDefinition 的实现类。构造完成后，<strong>将这些BeanDefinition注册到通过方法参数传进来的BeanDefinitionRegistry中</strong>。之后，因为我们的FXNewsProvider是采用的构造方法注入，所以，需要<strong>通过ConstructorArgumentValues为其注入相关依赖</strong>。在这里为了同时说明setter方法注入，也同时展示了在Spring中如何使用代码实现setter方法注入。如果要运行这段代码，需要把setter方法注入部分的4行代码注释掉。<strong>最后，以BeanFactory的形式返回已经注册并绑定了所有相关业务对象的BeanDefinitionRegistry实例</strong></li></ul><h4 id="配置文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#配置文件"></a> 配置文件<a href="spring&mybatis/Spring IoC#配置文件"></a></h4><ul><li>采用外部配置文件时，Spring的IoC容器有一个统一的处理方式。通常情况下，需要根据不同的外<br>部配置文件格式，<strong>给出相应的BeanDefinitionReader实现类</strong>，<strong>由BeanDefinitionReader的相应实</strong><br><strong>现类负责将相应的配置文件内容读取并映射到BeanDefinition</strong>，然后<strong>将映射后的BeanDefinition注</strong><br><strong>册到一个BeanDefinitionRegistry</strong>，之后，<strong>BeanDefinitionRegistry即完成Bean的注册和加载</strong></li></ul><h5 id="properties文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#properties文件"></a> properties文件<a href="spring&mybatis/Spring IoC#properties文件"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Properties格式表达的依赖注入配置内容</span></span><br><span class="line"><span class="meta">djNewsProvider.(class)</span>=<span class="string">..FXNewsProvider </span></span><br><span class="line"><span class="comment"># ----------通过构造方法注入的时候------------- </span></span><br><span class="line"><span class="meta">djNewsProvider.$0(ref)</span>=<span class="string">djListener </span></span><br><span class="line"><span class="meta">djNewsProvider.$1(ref)</span>=<span class="string">djPersister </span></span><br><span class="line"><span class="comment"># ----------通过setter方法注入的时候--------- </span></span><br><span class="line"><span class="comment"># djNewsProvider.newsListener(ref)=djListener </span></span><br><span class="line"><span class="comment"># djNewsProvider.newPersistener(ref)=djPersister </span></span><br><span class="line"><span class="meta">djListener.(class)</span>=<span class="string">..impl.DowJonesNewsListener </span></span><br><span class="line"><span class="meta">djPersister.(class)</span>=<span class="string">..impl.DowJon</span></span><br><span class="line"><span class="attr">esNewsPersister</span></span><br></pre></td></tr></table></div></figure><ul><li><strong>djNewsProvider作为beanName，后面通过.(class)表明对应的实现类是什么</strong>，实际上使用djNewsProvider.class=…的形式也是可以的，但Spring 1.2.6之后不再提倡使用，而<strong>提倡使用.(class)的形式</strong></li><li><strong>通过在表示beanName的名称后添加.$[number]后缀的形式，来表示当前beanName对应的对象需要通过构造方法注入的方式注入相应依赖对象</strong>。在这里，我们分别将构造方法的第一个<br>参数和第二个参数对应到djListener和djPersister。需要注意的一点，就是**$0和$1后面的(ref)，(ref)用来表示所依赖的是引用对象，而不是普通的类型**。如果不加(ref)，<br>PropertiesBeanDefinitionReader会将djListener和djPersister作为简单的String类型进行注入，异常自然不可避免啦</li><li>FXNewsProvider采用的是构造方法注入，而为了演示setter方法注入在Properties配置文件中又 5<br>是一个什么样子，以便于你更全面地了解基于Properties文件的配置方式，我们在下面增加了<br><strong>setter方法注入</strong>的例子，不过进行了注释。实际上，<strong>与构造方法注入最大的区别就是，它不使用数字顺序来指定注入的位置，而使用相应的属性名称来指定注入</strong>。newsListener和<br>newPersistener恰好就是我们的FXNewsProvider类中所声明的属性名称。这印证了之前在<br>比较构造方法注入和setter方法注入方式不同时提到的差异，<strong>即构造方法注入无法通过参数名称来标识注入的确切位置，而setter方法注入则可以通过属性名称来明确标识注入</strong>。与在<br>Properties中表达构造方法注入一样，同样需要注意，如果属性名称所依赖的是引用对象，那<br>么一定不要忘了(ref)</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载Properties配置的BeanFactory的使用演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DefaultListableBeanFactory beanRegistry = <span class="keyword">new</span> DefaultListableBeanFactory(); </span><br><span class="line">  BeanFactory container = (BeanFactory)bindViaPropertiesFile(beanRegistry); </span><br><span class="line">  FXNewsProvider newsProvider = (FXNewsProvider)container.getBean(<span class="string">"djNewsProvider"</span>);</span><br><span class="line">  newsProvider.getAndPersistNews(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanFactory <span class="title">bindViaPropertiesFile</span><span class="params">(BeanDefinitionRegistry registry)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  PropertiesBeanDefinitionReader reader = </span><br><span class="line">  <span class="keyword">new</span> PropertiesBeanDefinitionReader(registry); </span><br><span class="line">  reader.loadBeanDefinitions(<span class="string">"classpath:../../binding-config.properties"</span>); </span><br><span class="line">  <span class="keyword">return</span> (BeanFactory)registry; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="xml文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#xml文件"></a> xml文件<a href="spring&mybatis/Spring IoC#xml文件"></a></h5><ul><li>Properties配置文件格式提供PropertiesBeanDefinitionReader相对应，<strong>Spring同样为XML格式的配置文件提供了现成的BeanDefinitionReader实现，即XmlBeanDefinitionReader</strong>。<strong>XmlBeanDefinitionReader负责读取Spring指定格式的XML配置文件并解析，之后将解析后的文件内容映射到相应的BeanDefinition，并加载到相应的BeanDefinitionRegistry中</strong>（在这里是DefaultListableBeanFactory）。这时，整个BeanFactory就可以放给客户端使用了</li><li>Spring在DefaultListableBeanFactory的基础上构建了简化XML格式配置加载的XmlBeanFactory实现<ul><li>XmlBeanFactory现已不再使用</li></ul></li></ul><h4 id="元数据"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#元数据"></a> 元数据<a href="spring&mybatis/Spring IoC#元数据"></a></h4><ul><li><strong>@Autowired的存在将告知Spring容器需要为当前对象注入哪些依赖对象</strong>。而**@Component则是配合Spring 2.5中新的classpath-scanning功能使用的**。现在我们只要再向Spring的配置文件中增加一个“触发器”，使用@Autowired和@Component标注的类就能获得依赖对象的注入了</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/context/spring-context-2.5.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.spring21.project.base.package"</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li><code>&lt;context:component-scan/&gt;</code>会到指定的包（package）下面<strong>扫描标注有@Component的类</strong>，如果找到，则将它们<strong>添加到容器进行管理</strong>，并根据它们所标注的@Autowired为<strong>这些类注入符合条件的依赖对象</strong></li></ul><h2 id="ioc容器的实现"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#ioc容器的实现"></a> IoC容器的实现<a href="spring&mybatis/Spring IoC#ioc容器的实现"></a></h2><ul><li><p>Spring的IoC容器会<strong>以某种方式加载Configuration Metadata</strong>（通常也就是XML格式的配置信息），然后<strong>根据这些信息绑定整个系统的对象</strong>，最终<strong>组装成一个可用的基于轻量级容器的应用系统</strong></p></li><li><p>Spring的IoC容器实现以上功能的过程，基本上可以按照类似的流程划分为两个阶段，即<strong>容器启动阶段</strong>和<strong>Bean实例化阶段</strong></p></li></ul><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/%E5%AE%B9%E5%99%A8%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%84%E4%B8%AA%E9%98%B6%E6%AE%B5.png" alt="" class="article-img"></p><h5 id="容器启动阶段"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#容器启动阶段"></a> 容器启动阶段<a href="spring&mybatis/Spring IoC#容器启动阶段"></a></h5><ul><li>容器启动伊始，首先会<strong>通过某种途径加载Configuration MetaData</strong>。除了代码方式比较直接，在大部分情况下，容器需要依赖某些工具类（BeanDefinitionReader）对加载的Configuration MetaData进行解析和分析，并<strong>将分析后的信息编组为相应的BeanDefinition</strong>，最后<strong>把这些保存了bean定义必要信息的BeanDefinition，注册到相应的BeanDefinitionRegistry</strong>，这样容器启动工作就完成了</li></ul><h5 id="bean实例化阶段"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#bean实例化阶段"></a> Bean实例化阶段<a href="spring&mybatis/Spring IoC#bean实例化阶段"></a></h5><ul><li>经过第一阶段，现在所有的bean定义信息都通过BeanDefinition的方式注册到了BeanDefinitionRegistry中。<strong>当某个请求方通过容器的getBean方法明确地请求某个对象，或者因依赖关系容器需要隐式地调用getBean方法时，就会触发第二阶段的活动</strong></li><li>该阶段，容器会首先检查所请求的对象之前是否已经初始化。<strong>如果没有，则会根据注册的BeanDefinition所提供的信息实例化被请求对象，并为其注入依赖</strong>。如果该对象实现了某些回调接口，也会根据回调接口的要求来装配它。<strong>当该对象装配完毕之后，容器会立即将其返回请求方使用</strong>。如果说第一阶段只是根据图纸装配生产线的话，那么第二阶段就是使用装配好的生产线来生产具体的产品了</li></ul><h3 id="干预容器启动阶段"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#干预容器启动阶段"></a> 干预容器启动阶段<a href="spring&mybatis/Spring IoC#干预容器启动阶段"></a></h3><ul><li>Spring提供了一种叫做<strong>BeanFactoryPostProcessor</strong>的容器扩展机制。该机制<strong>允许我们在容器实例化相应对象之前，对注册到容器的BeanDefinition所保存的信息做相应的修改</strong>。这就相当于在容器实现的第一阶段最后加入一道工序，让我们对最终的BeanDefinition做一些额外的操作，比如修改其中bean定义的某些属性，为bean定义增加其他信息等</li><li>对于BeanFactory来说，我们需要用手动方式应用所有的BeanFactoryPostProcessor</li><li>对于ApplicationContext来说，因为<strong>ApplicationContext会自动识别配置文件中的BeanFactoryPostProcessor并应用它</strong>，所以，相对于BeanFactory，在ApplicationContext中加载并应用BeanFactoryPostProcessor，<strong>仅需要在XML配置文件中将这些BeanFactoryPostProcessor简单配置一下即可</strong></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>conf/jdbc.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>conf/mail.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="spring提供的beanfactorypostprocessor实现"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#spring提供的beanfactorypostprocessor实现"></a> Spring提供的BeanFactoryPostProcessor实现<a href="spring&mybatis/Spring IoC#spring提供的beanfactorypostprocessor实现"></a></h4><h5 id="propertyplaceholderconfigurer"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#propertyplaceholderconfigurer"></a> PropertyPlaceholderConfigurer<a href="spring&mybatis/Spring IoC#propertyplaceholderconfigurer"></a></h5><ul><li>PropertyPlaceholderConfigurer<strong>允许我们在XML配置文件中使用占位符（Placeholder）</strong>，并<strong>将这些占位符所代表的资源单独配置到简单的properties文件中来加载</strong></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.url&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.driver&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.username&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>$&#123;jdbc.password&#125;<span class="tag">&lt;/<span class="name">value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li><strong>当BeanFactory在第一阶段加载完成所有配置信息时，BeanFactory中保存的对象的属性信息还只是以占位符的形式存在</strong>，如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>j</mi><mi>d</mi><mi>b</mi><mi>c</mi><mi mathvariant="normal">.</mi><mi>u</mi><mi>r</mi><mi>l</mi></mrow><mi mathvariant="normal">、</mi></mrow><annotation encoding="application/x-tex">{jdbc.url}、</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">d</span><span class="mord mathdefault">b</span><span class="mord mathdefault">c</span><span class="mord">.</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span><span class="mord cjk_fallback">、</span></span></span></span>{jdbc.driver}。<strong>当PropertyPlaceholderConfigurer作为BeanFactoryPostProcessor被应用时，它会使用properties配置文件中的配置信息来替换相应BeanDefinition中占位符所表示的属性值</strong>。这样，当<strong>进入容器实现的第二阶段实例化bean时，bean定义中的属性值就是最终替换完成的了</strong></li><li>PropertyPlaceholderConfigurer不单会从其配置的properties文件中加载配置项，同时还<strong>会检查Java的System类中的Properties</strong>，可以通过setSystemPropertiesMode()或者setSystemPropertiesModeName()来控制是否加载或者覆盖System相应Properties的行为</li></ul><h5 id="propertyoverrideconfigurer"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#propertyoverrideconfigurer"></a> PropertyOverrideConfigurer<a href="spring&mybatis/Spring IoC#propertyoverrideconfigurer"></a></h5><ul><li>可以<strong>通过PropertyOverrideConfigurer对容器中配置</strong>的任何你想处理的<strong>bean定义的property信息进行覆盖替换</strong></li><li>PropertyOverrideConfigurer的<strong>properties文件中的配置项，覆盖掉了原来XML中的bean定义的property信息</strong></li><li>PropertyOverrideConfigurer使用的配置文件示例：<br><code>beanName.propertyName=Value</code><br>也就是说，properties文件中的键是<strong>以XML中配置的bean定义的beanName为标志开始</strong>的（通常就是id指定的值），后面<strong>跟着相应被覆盖的property的名称</strong></li><li>当容器中配置的多个PropertyOverrideConfigurer对同一个bean定义的同一个property值进<br>行处理的时候，<strong>最后一个将会生效</strong></li></ul><h5 id="customeditorconfigure"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#customeditorconfigure"></a> CustomEditorConfigure<a href="spring&mybatis/Spring IoC#customeditorconfigure"></a></h5><ul><li>CustomEditorConfigure只是<strong>辅助性地将后期会用到的信息注册到容器，对BeanDefinition没有做任何变动</strong></li><li>不管对象是什么类型，也不管这些对象所声明的依赖对象是什么类型，<strong>通常都是通过XML（或者properties）文件格式来配置这些对象类型</strong>。但XML所记载的，都是String类型，即<strong>容器从XML格式的文件中读取的都是字符串形式，最终应用程序却是由各种类型的对象所构成</strong>。要想<strong>完成这种由字符串到具体对象的转换</strong>，<strong>都需要这种转换规则相关的信息</strong>，而CustomEditorConfigurer就是帮助我们传达类似信息的</li><li>Spring内部<strong>通过JavaBean的PropertyEditor来帮助进行String类型到其他类型的转换工作</strong>。只要<strong>为每种对象类型提供一个 PropertyEditor ，就可以根据该对象类型取得与其相对应的PropertyEditor来做具体的类型转换</strong>。Spring容器内部在做具体的类型转换的时候，会<strong>采用JavaBean框架内默认的PropertyEditor搜寻逻辑</strong>，从而<strong>继承了对原生类型以及java.lang.String.java.awt.Color和java.awt.Font等类型的转换支持</strong>。同时，Spring框架还提供了自身实现的一些PropertyEditor，这些PropertyEditor大部分都位于org.springframework. beans.propertyeditors包下<ul><li><strong>StringArrayPropertyEditor</strong>。该PropertyEditor会<strong>将符合CSV格式的字符串转换成String[]数组的形式，默认是以逗号（,）分隔的字符串</strong>，但可以指定自定义的字符串分隔符</li><li>ClassEditor。<strong>根据String类型的class名称，直接将其转换成相应的Class对象，相当于通</strong><br><strong>过Class.forName(String)完成的功效</strong>。可以通过String[]数组的形式传入需转换的值，以<br>达到与提供的ClassArrayEditor同样的目的<ul><li>ClassEditor，FileEditor，LocaleEditor，PatternEditor等均<strong>默认加载使用</strong></li></ul></li></ul></li></ul><h5 id="给出针对特定对象类型的propertyeditor实现"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#给出针对特定对象类型的propertyeditor实现"></a> 给出针对特定对象类型的PropertyEditor实现<a href="spring&mybatis/Spring IoC#给出针对特定对象类型的propertyeditor实现"></a></h5><ul><li>假设需要<strong>对yyyy/MM/dd形式的日期格式转换提供支持</strong>。虽然可以直接让PropertyEditor实现类去实现java.beans.PropertyEditor接口，不过，我们可以<strong>直接继承java.beans.PropertyEditorSupport类以避免实现java.beans.PropertyEditor接口的所有方法</strong>。就好像这次，我们仅仅让DatePropertyEditor完成从 String 到 java.util.Date 的转换，<strong>只需要实现setAsText(String)方法</strong>，而其他方法一概不管</li></ul><p>![image-20201026162419885](/Users/ng/Library/Application Support/typora-user-images/image-20201026162419885.png)</p><ul><li><strong>通过CustomEditorConfigurer将刚实现的DatePropertyEditor注册到容器，以告知容器按照DatePropertyEditor的形式进行String到java.util.Date类型的转换工作</strong></li><li>如果容器是<strong>BeanFactory的实现</strong>，比如XmlBeanFactory，则<strong>需要通过编码手动应用</strong></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XmlBeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> ClassPathResource</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">CustomEditorConfigurer ceConfigurer = <span class="keyword">new</span> CustomEditorConfigurer(); </span><br><span class="line">Map customerEditors = <span class="keyword">new</span> HashMap(); </span><br><span class="line">customerEditors.put(java.util.Date.class, <span class="keyword">new</span> DatePropertyEditor())；</span><br><span class="line">ceConfigurer.setCustomEditors(customerEditors); </span><br><span class="line"><span class="comment">// </span></span><br><span class="line">ceConfigurer.postProcessBeanFactory(beanFactory);</span><br></pre></td></tr></table></div></figure><ul><li><strong>ApplicationContext相应实现</strong>，因为ApplicationContext会<strong>自动识别BeanFactoryPostProcessor并应用</strong>，所以<strong>只需要在相应配置文件中配置一下</strong></li></ul><h3 id="bean的生命周期"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#bean的生命周期"></a> Bean的生命周期<a href="spring&mybatis/Spring IoC#bean的生命周期"></a></h3><ul><li>ApplicationContext启动之后会实例化所有的bean定义，但<strong>ApplicationContext在实现的过程中依然遵循Spring容器实现流程的两个阶段</strong>，只不过它会<strong>在启动阶段的活动完成之后，紧接着调用注册到该容器的所有bean定义的实例化方法getBean()</strong>。这就是为什么当你得到ApplicationContext类型的容器引用时，容器内所有对象已经被全部实例化完成</li><li>说getBean()方法是有可能触发Bean实例化阶段的活动，是因为<strong>只有当对应某个bean定义的getBean()方法第一次被调用时</strong>，不管是显式的还是隐式的，<strong>Bean实例化阶段的活动才会被触发</strong>，<strong>第二次被调用则会直接返回容器缓存的第一次实例化完的对象实例</strong>（prototype类型bean除外）。当<strong>getBean()方法内部发现该bean定义之前还没有被实例化之后，会通过createBean()方法来进行具体的对象实例化</strong></li></ul><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/Bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%BF%87%E7%A8%8B.png" alt="" class="article-img"></p><ul><li>Spring容器将对其所管理的对象<strong>全部给予统一的生命周期管理</strong></li></ul><h4 id="bean的实例化与beanwrapper"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#bean的实例化与beanwrapper"></a> Bean的实例化与BeanWrapper<a href="spring&mybatis/Spring IoC#bean的实例化与beanwrapper"></a></h4><ul><li>容器在内部实现的时候，<strong>采用“策略模式（Strategy Pattern）”来决定采用何种方式初始化bean实例</strong>。通常，可以通过反射或者CGLIB动态字节码生成来初始化相应的bean实例或者动态生成其子类。InstantiationStrategy是实例化策略的抽象接口，其直接子类<strong>SimpleInstantiationStrategy实现了简单的对象实例化功能</strong>，可以通过反射来实例化对象实例，但不支持方法注入方式的对象实例化</li><li><strong>CglibSubclassingInstantiationStrategy</strong>继承了SimpleInstantiationStrategy的以反射方式实例化对象的功能，并且通过CGLIB的动态字节码生成功能，该策略实现类<strong>可以动态生成某个类的子类，进而满足了方法注入所需的对象实例化需求</strong>。默认情况下，容器内部采用的是CglibSubclassingInstantiationStrategy</li></ul><h5 id="第一步实例化bean对象"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#第一步实例化bean对象"></a> 第一步：实例化Bean对象<a href="spring&mybatis/Spring IoC#第一步实例化bean对象"></a></h5><ul><li>容器只要根据相应bean定义的BeanDefintion取得实例化信息，结合CglibSubclassingInstantiationStrategy以及不同的bean定义类型，就可以返回实例化完成的对象实例。但是，<strong>不是直接返回构造完成的对象实例，而是以BeanWrapper对构造完成的对象实例进行包裹，返回相应的BeanWrapper实例</strong></li></ul><h5 id="第二步设置对象属性"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#第二步设置对象属性"></a> 第二步：设置对象属性<a href="spring&mybatis/Spring IoC#第二步设置对象属性"></a></h5><ul><li>在第一步结束后返回BeanWrapper实例而不是原先的对象实例，就是为了第二步“设置对象属性”</li><li><strong>BeanWrapper定义继承了PropertyAccessor接口，可以以统一的方式对对象属性进行访问</strong>；BeanWrapper定义同时又直接或者间接<strong>继承了PropertyEditorRegistry和TypeConverter接口</strong>。<strong>在第一步构造完成对象之后，Spring会根据对象实例构造一个BeanWrapperImpl实例</strong>，然后<strong>将之前CustomEditorConfigurer注册的PropertyEditor复制一份给BeanWrapperImpl实例</strong>（这就是BeanWrapper同时又是PropertyEditorRegistry的原因）。这样，当BeanWrapper转换类型、设置对象属性值时，就不会无从下手了</li><li>使用BeanWrapper对bean实例操作很方便，可以<strong>免去直接使用Java反射API操作对象实例的烦琐</strong></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object provider = Class.forName(<span class="string">"package.name.FXNewsProvider"</span>).newInstance(); </span><br><span class="line">Object listener = Class.forName(<span class="string">"package.name.DowJonesNewsListener"</span>).newInstance(); </span><br><span class="line">Object persister = Class.forName(<span class="string">"package.name.DowJonesNewsPersister"</span>).newInstance(); </span><br><span class="line">BeanWrapper newsProvider = <span class="keyword">new</span> BeanWrapperImpl(provider); </span><br><span class="line"></span><br><span class="line">newsProvider.setPropertyValue(<span class="string">"newsListener"</span>, listener); </span><br><span class="line">newsProvider.setPropertyValue(<span class="string">"newPersistener"</span>, persister); </span><br><span class="line"></span><br><span class="line">assertTrue(newsProvider.getWrappedInstance() <span class="keyword">instanceof</span> FXNewsProvider); </span><br><span class="line">assertSame(provider, newsProvider.getWrappedInstance()); </span><br><span class="line">assertSame(listener, newsProvider.getPropertyValue(<span class="string">"newsListener"</span>)); </span><br><span class="line">assertSame(persister, newsProvider.getPropertyValue(<span class="string">"newsPersister"</span>));</span><br></pre></td></tr></table></div></figure><h4 id="aware接口"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#aware接口"></a> Aware接口<a href="spring&mybatis/Spring IoC#aware接口"></a></h4><ul><li>当对象实例化完成并且相关属性以及依赖设置完成之后，Spring容器会检查当前对象实例是否实现了一系列的以Aware命名结尾的接口定义。如果是，则将这些Aware接口定义中规定的依赖注入给当前对象实例</li><li>BeanFactory的Aware接口<ul><li>BeanNameAware。如果Spring容器检测到当前对象实例实现了该接口，会<strong>将该对象实例的bean定义对应的beanName设置到当前对象实例</strong></li><li>BeanClassLoaderAware。如果容器检测到当前对象实例实现了该接口，会<strong>将对应加载当前bean的Classloader注入当前对象实例</strong>。默认会使用加载org.springframework.util.ClassUtils类的Classloader</li><li>BeanFactoryAware。在介绍方法注入的时候，我们提到过使用该接口以便每次获取prototype类型bean的不同实例。<strong>如果对象声明实现了BeanFactoryAware接口，BeanFactory容器会将自身设置到当前对象实例</strong>。这样，<strong>当前对象实例就拥有了一个BeanFactory容器的引用，并且可以对这个容器内允许访问的对象按照需要进行访问</strong></li></ul></li><li>ApplicationContext的Aware接口<ul><li>ResourceLoaderAware。ApplicationContext<strong>实现了Spring的ResourceLoader接口</strong>。当容器检测到当前对象实例实现了ResourceLoaderAware接口之后，会将当前ApplicationContext自身设置到对象实例，这样<strong>当前对象实例就拥有了其所在ApplicationContext容器的一个引用</strong></li><li>ApplicationEventPublisherAware。ApplicationContext作为一个容器，同时还实现了ApplicationEventPublisher接口，这样，它就<strong>可以作为ApplicationEventPublisher来使用</strong>。所以，<strong>当前ApplicationContext容器如果检测到当前实例化的对象实例声明了ApplicationEventPublisherAware接口，则会将自身注入当前对象</strong></li><li>MessageSourceAware。<strong>ApplicationContext通过MessageSource接口提供国际化的信息支持</strong>，即I18n（Internationalization）。它自身就实现了MessageSource接口，所以<strong>当检测到当前对象实例实现了MessageSourceAware接口，则会将自身注入当前对象实例</strong></li><li>org.springframework.context.ApplicationContextAware。 <strong>如果ApplicationContext容器检测到当前对象实现了ApplicationContextAware接口，则会将自身注入当前对象实例</strong></li></ul></li></ul><h4 id="beanpostprocessor"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#beanpostprocessor"></a> BeanPostProcessor<a href="spring&mybatis/Spring IoC#beanpostprocessor"></a></h4><ul><li><strong>BeanPostProcessor</strong>存在于<strong>对象实例化阶段</strong>，而<strong>BeanFactoryPostProcessor</strong>则存在于<strong>容器启动阶段</strong></li><li>与BeanFactoryPostProcessor通常会处理容器内所有符合条件的BeanDefinition类似，BeanPostProcessor<strong>会处理容器内所有符合条件的实例化后的对象实例</strong></li><li><strong>postProcessBeforeInitialization()方法</strong>是图4-10中BeanPostProcessor<strong>前置处理</strong>这一步将会执行的方法，<strong>postProcessAfterInitialization()<strong>则是对应图4-10中BeanPostProcessor</strong>后置处理</strong>那一步将会执行的方法。BeanPostProcessor的两个方法中<strong>都传入了原来的对象实例的引用</strong>，这为我们扩展容器的对象实例化过程中的行为提供了极大的便利，我们几乎可以对传入的对象实例执行任何的操作</li><li>通常比较常见的使用BeanPostProcessor的场景，是<strong>处理标记接口实现类，或者为当前对象提供代理实现</strong>。在图4-10的第三步中，ApplicationContext对应的那些<strong>Aware接口实际上就是通过BeanPostProcessor的方式进行处理的</strong></li></ul><h4 id="initializingbean和init-method"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#initializingbean和init-method"></a> InitializingBean和init-method<a href="spring&mybatis/Spring IoC#initializingbean和init-method"></a></h4><ul><li>InitializingBean是容器内部广泛使用的一个<strong>对象生命周期标识接口</strong><ul><li>其作用在于，在对象实例化过程调用过“BeanPostProcessor的前置处理”之后，会接着检测当前对象是否实现了InitializingBean接口，如果<strong>是，则会调用其afterPropertiesSet()方法进一步调整对象实例的状态</strong>。比如，在有些情况下，某个业务对象实例化完成后，还不能处于可以使用状态。这个时候就可以让该业务对象实现该接口，并在方法afterPropertiesSet()中完成对该业务对象的后续处理</li><li>让业务对象实现这个接口，则显得Spring容器比较具有侵入性</li></ul></li><li>Spring还提供了另一种方式来指定自定义的对象初始化操作，那就是在XML配置的时候，使用<code>&lt;bean&gt;</code>的init-method属性<ul><li>通过init-method，系统中业务对象的自定义初始化操作可以以任何方式命名，而不再受制于InitializingBean的afterPropertiesSet()。如果系统开发过程中规定：所有业务对象的自定义初始化操作都必须以init()命名，为了省去挨个<code>&lt;bean&gt;</code>的设置init-method这样的烦琐，我们还<strong>可以通过最顶层的<code>&lt;beans&gt;</code>的default-init-method统一指定这一init()方法名</strong></li><li>一般，我们是在集成第三方库，或者其他特殊的情况下，才会需要使用该特性</li></ul></li></ul><h4 id="disposablebean与destroy-method"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#disposablebean与destroy-method"></a> DisposableBean与destroy-method<a href="spring&mybatis/Spring IoC#disposablebean与destroy-method"></a></h4><ul><li>当所有的一切，该设置的设置，该注入的注入，该调用的调用完成之后，容器<strong>将检查singleton类型的bean实例，看其是否实现了DisposableBean接口</strong>。<strong>或者其对应的bean定义是否通过<code>&lt;bean&gt;</code>的destroy-method属性指定了自定义的对象销毁方法</strong>。如果<strong>是，就会为该实例注册一个用于对象销毁的回调</strong>（Callback），<strong>以便在这些singleton类型的对象实例销毁之前，执行销毁逻辑</strong></li><li>与InitializingBean和init-method用于对象的自定义初始化相对应，<strong>DisposableBean和destroy-method为对象提供了执行自定义销毁逻辑的机会</strong></li><li>最常见到的该功能的使用场景就是<strong>在Spring容器中注册数据库连接池</strong></li><li>不过，这些<strong>自定义的对象销毁逻辑，在对象实例初始化完成并注册了相关的回调方法之后，并不会马上执行</strong>。<strong>回调方法注册后，返回的对象实例即处于使用状态，只有该对象实例不再被使用的时候，才会执行相关的自定义销毁逻辑</strong>，此时<strong>通常也就是Spring容器关闭的时候</strong>。但<strong>Spring容器在关闭之前，不会自动调用这些回调方法。所以，需要我们告知容器，在哪个时间点来执行对象的自定义销毁方法</strong></li><li>对于BeanFactory容器来说。我们<strong>需要在独立应用程序的主程序退出之前</strong>，或者其他被认为是合适的情况下（依照应用场景而定），<strong>调用ConfigurableBeanFactory提供的destroySingletons()方法销毁容器中管理的所有singleton类型的对象实例</strong></li><li>对于ApplicationContext容器来说，它为我们提供了<strong>registerShutdownHook()方法</strong>，该方法<strong>底层使用标准的Runtime类的addShutdownHook()方式来调用相应bean对象的销毁逻辑</strong>，从而<strong>保证在Java虚拟机退出之前，这些singtleton类型的bean对象实例的自定义销毁逻辑会被执行</strong></li></ul><h2 id="applicationcontext"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#applicationcontext"></a> ApplicationContext<a href="spring&mybatis/Spring IoC#applicationcontext"></a></h2><ul><li>作为Spring提供的较之BeanFactory更为先进的IoC容器实现，ApplicationContext除了拥有BeanFactory支持的所有功能之外，还进一步扩展了基本容器的功能，包括BeanFactoryPostProcessor、BeanPostProcessor以及其他特殊类型bean的自动识别、容器启动后bean实例的自动初始化、国际化的信息支持、容器内事件发布等</li></ul><h3 id="统一资源加载策略"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#统一资源加载策略"></a> 统一资源加载策略<a href="spring&mybatis/Spring IoC#统一资源加载策略"></a></h3><h5 id="使用原因"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#使用原因"></a> 使用原因<a href="spring&mybatis/Spring IoC#使用原因"></a></h5><ul><li>java SE提供的URL全名是Uniform Resource Locator（统一资源定位器）。首先，说是统一资源定位，但基本实现却<strong>只限于网络形式发布的资源的查找和定位工作</strong>，基本上只提供了基于HTTP、FTP、File等协议的资源定位功能</li><li>资源这个词的范围比较广义，资源<strong>可以任何形式存在</strong>，如以<strong>二进制对象</strong>形式存在、以<strong>字节流</strong>形式存在、以<strong>文件</strong>形式存在等；而且，资源也<strong>可以存在于任何场所</strong>，如存在于<strong>文件系统</strong>、存在于<strong>Java应用的Classpath</strong>中，甚至存在于<strong>URL可以定位的地方</strong></li></ul><h4 id="spring中的resource"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#spring中的resource"></a> Spring中的Resource<a href="spring&mybatis/Spring IoC#spring中的resource"></a></h4><ul><li>Spring框架内部使用<strong>Resource接口作为所有资源的抽象和访问接口</strong>，我们之前在构造BeanFactory的时候已经接触过它，如下代码：<ul><li>``BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(&quot;…&quot;));`</li><li>其中<strong>ClassPathResource</strong>就是Resource的一个特定类型的实现，<strong>代表的是位于Classpath中的资源</strong></li></ul></li><li>Resource接口可以根据资源的不同类型，或者资源所处的不同场合，给出相应的具体实现。Spring框架在这个理念的基础上，提供了一些实现类（可以在org.springframework.core.io包下找到这些实现类）<ul><li><strong>ByteArrayResource</strong>。将字节（byte）数组提供的数据作为一种资源进行封装，如果通过InputStream形式访问该类型的资源，该实现<strong>会根据字节数组的数据，构造相应的ByteArrayInputStream并返回</strong></li><li>ClassPathResource。该实现<strong>从Java应用程序的ClassPath中加载具体资源并进行封装</strong>，可以使用指定的类加载器（ClassLoader）或者给定的类进行资源加载</li><li>FileSystemResource。对java.io.File类型的封装，所以，我们<strong>可以以文件或者URL的形式对该类型资源进行访问</strong>，只要能跟File打的交道，基本上跟FileSystemResource也可以</li><li>UrlResource。<strong>通过java.net.URL进行的具体资源查找定位的实现类</strong>，内部委派URL进行具体的资源操作</li><li>InputStreamResource。将给定的InputStream视为一种资源的Resource实现类，较为少用。可能的情况下，以ByteArrayResource以及其他形式资源实现代之</li></ul></li><li>想实现自定义的Resource，我们可以继承AbstractResource抽象类，然后根据当前具体资源特征，覆盖相应的方法就可以了</li></ul><h4 id="更广义的urlresourceloader"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#更广义的urlresourceloader"></a> “更广义的URL”——ResourceLoader<a href="spring&mybatis/Spring IoC#更广义的urlresourceloader"></a></h4><ul><li><p>资源是有了，但如何去查找和定位这些资源，则应该是ResourceLoader的职责所在了</p></li><li><p><strong>ResourceLoader接口是资源查找定位策略的统一抽象</strong>，具体的资源查找定位策略则由相应的ResourceLoader实现类给出</p><ul><li>把ResourceLoader称作<strong>统一资源定位器</strong>或许才更恰当一些</li></ul></li><li><p>ResourceLoader定义如下</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123; </span><br><span class="line">    String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; </span><br><span class="line">    <span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>; </span><br><span class="line">    <span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>其中<strong>最主要的就是Resource getResource(String location)方法</strong>，通过它，我们就<strong>可以根据指定的资源位置，定位到具体的资源实例</strong></li></ul></li></ul><h5 id="defaultresourceloader"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#defaultresourceloader"></a> DefaultResourceLoader<a href="spring&mybatis/Spring IoC#defaultresourceloader"></a></h5><ul><li>ResourceLoader有一个默认的实现类，即DefaultResourceLoader，该类默认的资源查找处理逻辑如下<ol><li>首先<strong>检查资源路径是否以classpath:前缀打头</strong>，如果是，则<strong>尝试构造ClassPathResource类型资源并返回</strong></li><li><strong>否则尝试通过URL，根据资源路径来定位资源</strong>，如果没有抛出MalformedURLException，<strong>有则会构造UrlResource类型的资源并返回</strong><ol><li>如果还是无法根据资源路径定位指定的资源，则<strong>委派getResourceByPath(String) 方法来定位</strong>， DefaultResourceLoader 的getResourceByPath(String)方法默认实现逻辑是，构造ClassPathResource类型的资源并返回</li></ol></li></ol></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Resource fakeFileResource = resourceLoader.getResource(<span class="string">"D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(fakeFileResource <span class="keyword">instanceof</span> ClassPathResource); </span><br><span class="line">assertFalse(fakeFileResource.exists()); </span><br><span class="line">Resource urlResource1 = resourceLoader.getResource(<span class="string">"file:D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(urlResource1 <span class="keyword">instanceof</span> UrlResource); </span><br><span class="line">Resource urlResource2 = resourceLoader.getResource(<span class="string">"http://www.spring21.cn"</span>); </span><br><span class="line">assertTrue(urlResource2 <span class="keyword">instanceof</span> UrlResource); </span><br><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">fakeFileResource.getFile();</span><br><span class="line">fail(<span class="string">"no such file with path["</span>+fakeFileResource.getFilename()+<span class="string">"] exists in classpath"</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>(FileNotFoundException e)&#123; </span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">try</span>&#123; </span><br><span class="line">  urlResource1.getFile();</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">catch</span>(FileNotFoundException e)&#123; </span><br><span class="line">  fail();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><strong>fakeFileResource资源的类型</strong>，并不是我们所预期的FileSystemResource类型，而<strong>是ClassPathResource类型</strong>，这是由DefaultResourceLoader的资源查找逻辑所决定的。<strong>如果最终没有找到符合条件的相应资源，getResourceByPath(String)方法就会构造一个实际上并不存在的资源并返回</strong>。而指定有协议前缀的资源路径，则通过URL能够定位，所以，<strong>返回的都是UrlResource类型</strong></li></ul><h5 id="filesystemresourceloader"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#filesystemresourceloader"></a> FileSystemResourceLoader<a href="spring&mybatis/Spring IoC#filesystemresourceloader"></a></h5><ul><li>为了<strong>避免DefaultResourceLoader在最后getResourceByPath(String)方法上的不恰当处理</strong>，我们可以使用<strong>FileSystemResourceLoader，它继承自DefaultResourceLoader，但覆写getResourceByPath(String)方法</strong>，<strong>使之从文件系统加载资源并以FileSystemResource类型返回</strong>。这样，我们就可以取得预想的资源类型</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testResourceTypesWithFileSystemResourceLoader</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader(); </span><br><span class="line">Resource fileResource = resourceLoader.getResource(<span class="string">"D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(fileResource <span class="keyword">instanceof</span> FileSystemResource); </span><br><span class="line">assertTrue(fileResource.exists()); </span><br><span class="line">Resource urlResource = resourceLoader.getResource(<span class="string">"file:D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(urlResource <span class="keyword">instanceof</span> UrlResource); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>FileSystemResourceLoader在ResourceLoader家族中的兄弟<strong>FileSystemXmlApplicationContext</strong>，也是<strong>覆写了getResourceByPath(String)方法的逻辑</strong>，以改变DefaultResourceLoader的默认资源加载行为，<strong>最终从文件系统中加载并返回FileSystemResource类型的资源</strong></li></ul><h5 id="resourcepatternresolver-批量查找的resourceloader"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#resourcepatternresolver-批量查找的resourceloader"></a> ResourcePatternResolver ——批量查找的ResourceLoader<a href="spring&mybatis/Spring IoC#resourcepatternresolver-批量查找的resourceloader"></a></h5><ul><li>ResourcePatternResolver是ResourceLoader的扩展，<strong>ResourceLoader每次只能根据资源路径返回确定的单个Resource实例</strong>，而<strong>ResourcePatternResolver则可以根据指定的资源路径匹配模式，每次返回多个Resource实例</strong>。接口ResourcePatternResolver定义如下：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123; </span><br><span class="line">    String CLASSPATH_ALL_URL_PREFIX = <span class="string">"classpath*:"</span>; </span><br><span class="line">    Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>ResourcePatternResolver在继承ResourceLoader原有定义的基础上，又引入了Resource[] getResources(String)方法定义，以支持根据路径匹配模式返回多个Resources的功能。它同时还引入了一种新的协议前缀classpath*:，针对这一点的支持，将由相应的子类实现给出</li><li>ResourcePatternResolver最常用的一个实现是<strong>PathMatchingResourcePatternResolver</strong>，该实现类<strong>支持ResourceLoader级别的资源加载，支持基于Ant风格的路径匹配模式（类似于**/*.suffix之类的路径形式），支持ResourcePatternResolver新增加的classpath*:前缀等</strong>，基本上集所有技能于一身</li><li>在构造PathMatchingResourcePatternResolver实例的时候，可以指定一个ResourceLoader，如果不指定的话，则PathMatchingResourcePatternResolver内部会默认构造一个DefaultResourceLoader实例。PathMatchingResourcePatternResolver内部会将匹配后确定的资源路径，委派给它的ResourceLoader来查找和定位资源。这样，<strong>如果不指定任何ResourceLoader的话，PathMatchingResourcePatternResolver在加载资源的行为上会与DefaultResourceLoader基本相同，只存在返回的Resource数量上的差异</strong>。如下代码表明了二者在资源加载行为上的一致性：</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ResourcePatternResolver resourceResolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver(); </span><br><span class="line">Resource fileResource = resourceResolver.getResource(<span class="string">"D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(fileResource <span class="keyword">instanceof</span> ClassPathResource); </span><br><span class="line">assertFalse(fileResource.exists()); </span><br><span class="line">...</span><br></pre></td></tr></table></div></figure><ul><li>不过，<strong>可以通过传入其他类型的ResourceLoader来替换PathMatchingResourcePatternResolver内部默认使用的DefaultResourceLoader，从而改变其默认行为</strong><ul><li>使用FileSystemResourceLoader替换默认的DefaultResourceLoader，从而使得PathMatchingResourcePatternResolver的行为跟使用FileSystemResourceLoader一样</li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testResourceTypesWithPathMatchingResourcePatternResolver</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">ResourcePatternResolver resourceResolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver(); </span><br><span class="line">Resource fileResource = resourceResolver.getResource(<span class="string">"D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(fileResource <span class="keyword">instanceof</span> ClassPathResource); </span><br><span class="line">assertFalse(fileResource.exists()); </span><br><span class="line">resourceResolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver(<span class="keyword">new</span> ➥</span><br><span class="line">FileSystemResourceLoader()); </span><br><span class="line">fileResource = resourceResolver.getResource(<span class="string">"D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(fileResource <span class="keyword">instanceof</span> FileSystemResource); </span><br><span class="line">assertTrue(fileResource.exists()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="applicationcontext与resourceloader"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#applicationcontext与resourceloader"></a> ApplicationContext与ResourceLoader<a href="spring&mybatis/Spring IoC#applicationcontext与resourceloader"></a></h4><ul><li><strong>ApplicationContext</strong>继承了ResourcePatternResolver，当然就<strong>间接实现了ResourceLoader接口</strong>。所以，<strong>任何的ApplicationContext实现都可以看作是一个ResourceLoader甚至ResourcePatternResolver</strong>。而<strong>这就是ApplicationContext支持Spring内统一资源加载策略的真相</strong></li></ul><p>![image-20201104112529095](/Users/ng/Library/Application Support/typora-user-images/image-20201104112529095.png)</p><h5 id="扮演resourceloader的角色"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#扮演resourceloader的角色"></a> 扮演ResourceLoader的角色<a href="spring&mybatis/Spring IoC#扮演resourceloader的角色"></a></h5><ul><li>既然ApplicationContext可以作为ResourceLoader或者ResourcePatternResolver来使用，那么，很显然，我们可以通过ApplicationContext来加载任何Spring支持的Resource类型</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResourceLoader resourceLoader = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"配置文件路径"</span>); </span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="comment">// ResourceLoader resourceLoader = new FileSystemXmlApplicationContext("配置文件路径"); </span></span><br><span class="line">Resource fileResource = resourceLoader.getResource(<span class="string">"D:/spring21site/README"</span>); </span><br><span class="line">assertTrue(fileResource <span class="keyword">instanceof</span> ClassPathResource); </span><br><span class="line">assertFalse(fileResource.exists()); </span><br><span class="line">Resource urlResource2 = resourceLoader.getResource(<span class="string">"http://www.spring21.cn"</span>); </span><br><span class="line">assertTrue(urlResource2 <span class="keyword">instanceof</span> UrlResource);</span><br></pre></td></tr></table></div></figure><h5 id="resourceloader类型的注入"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#resourceloader类型的注入"></a> ResourceLoader类型的注入<a href="spring&mybatis/Spring IoC#resourceloader类型的注入"></a></h5><ul><li>在大部分情况下，如果<strong>某个bean需要依赖于ResourceLoader来查找定位资源</strong>，我们可以为其<strong>注入容器中声明的某个具体的ResourceLoader实现</strong>，该bean也无需实现任何接口，<strong>直接通过构造方法注入或者setter方法注入规则声明依赖即可</strong>，这样处理是比较合理的。不过，如果你不介意你的bean定义依赖于Spring的API，那不妨考虑用一下Spring提供的便利</li><li>ApplicationContext容器本身就是一个ResourceLoader，我们为了该类还需要单独提供一个resourceLoader实例就有些多于了，<strong>直接将当前的ApplicationContext容器作为ResourceLoader注入</strong></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span></span>&#123; </span><br><span class="line"><span class="keyword">private</span> ResourceLoader resourceLoader; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String location)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">System.out.println(getResourceLoader().getResource(location).getClass()); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> resourceLoader;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.resourceLoader = resourceLoader; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123; </span><br><span class="line"><span class="keyword">private</span> ResourceLoader resourceLoader; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(String location)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">System.out.println(getResourceLoader().getResource(location).getClass()); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">return</span> resourceLoader; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> ➥</span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123; </span><br><span class="line"><span class="keyword">this</span>.resourceLoader = ctx; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>剩下的就是直接将FooBar配置到bean定义文件即可，如下所示</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"fooBar"</span> <span class="attr">class</span>=<span class="string">"...FooBar"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>现在，<strong>容器启动的时候，就会自动将当前ApplicationContext容器本身注入到FooBar中</strong>，因为ApplicationContext类型容器可以自动识别Aware接口</li></ul><h5 id="resource类型的注入"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#resource类型的注入"></a> Resource类型的注入<a href="spring&mybatis/Spring IoC#resource类型的注入"></a></h5><ul><li>我们之前讲过，容器可以将bean定义文件中的字符串形式表达的信息，正确地转换成具体对象定义的依赖类型。对于那些Spring容器提供的默认的PropertyEditors无法识别的对象类型，我们可以提供自定义的PropertyEditor实现并注册到容器中，以供容器做类型转换的时候使用。默认情况下，BeanFactory容器不会为Resource类型提供相应的PropertyEditor，所以，如果我们想注入Resource类型的bean定义，就需要注册自定义的PropertyEditor到BeanFactory容器。不过，对于ApplicationContext来说，我们无需这么做，因为<strong>ApplicationContext容器可以正确识别Resource类型并转换后注入相关对象</strong></li><li><strong>直接在配置文件中以String形式指定template所在位置，ApplicatonContext就可以正确地转换类型并注入依赖</strong></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"mailer"</span> <span class="attr">class</span>=<span class="string">"...XMailer"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"template"</span> <span class="attr">value</span>=<span class="string">"..resources.default_template.vm"</span>/&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li><p>ApplicationContext启动伊始，<strong>会通过一个ResourceEditorRegistrar来注册Spring提供的针对Resource类型的PropertyEditor实现到容器中</strong>，这个PropertyEditor叫做 ResourceEditor。这样，ApplicationContext就可以正确地识别Resource类型的依赖了。ResourceEditor怎么实现：<strong>把配置文件中的路径让ApplicationContext作为ResourceLoader定位一下</strong></p></li><li><p>如果应用对象需要<strong>依赖一组Resource</strong>，与ApplicationContext注册了ResourceEditor类似，<strong>Spring提供了ResourceArrayPropertyEditor实现，我们只需要通过CustomEditorConfigurar告知容器即可</strong></p></li></ul><h5 id="在特定情况下applicationcontext的resource加载行为"><a class="markdownIt-Anchor" href="spring&mybatis/Spring IoC#在特定情况下applicationcontext的resource加载行为"></a> 在特定情况下，ApplicationContext的Resource加载行为<a href="spring&mybatis/Spring IoC#在特定情况下applicationcontext的resource加载行为"></a></h5><ul><li><p>我们下面主要讨论两种类型的ApplicationContext容器，即ClassPathXmlApplicationContext和FileSystemXmlApplicationContext</p></li><li><p>我们知道，对于URL所接受的资源路径来说，通常开始都会有一个协议前缀，比如file:、http:、ftp:等。既然Spring使用UrlResource对URL定位查找的资源进行了抽象，那么，同样也支持这样类型的资源路径，而且，在这个基础上，Spring还扩展了协议前缀的集合。ResourceLoader中增加了一种新的资源路径协议——classpath:，ResourcePatternResolver又增加了一种——classpath*:。这样，我们就可以<strong>通过这些资源路径协议前缀，明确地告知Spring容器要classpath中加载资源</strong></p><p><code>// 代码中使用协议前缀 ResourceLoader resourceLoader = new ➥ FileSystemXmlApplicationContext(&quot;classpath:conf/container-conf.xml&quot;); // 配置中使用协议前缀 &lt;bean id=&quot;...&quot; class=&quot;...&quot;&gt; ean id=&quot;...&quot; class=&quot;.. &lt;value&gt;classpath:resource/template.vm&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt;</code></p></li><li><p><em><em>classpath</em>:与classpath:的唯一区别就在于，如果能够在classpath中找到多个指定的资源，则返回多个</em>*。我们可以通过这两个前缀改变某些ApplicationContext实现类的默认资源加载行为</p></li><li><p>ClassPathXmlApplicationContext和FileSystemXmlApplicationContext在处理资源加载的默认行为上有所不同</p><ul><li><p><em><em>当ClassPathXmlApplicationContext在实例化的时候，即使没有指明classpath:或者classpath</em>:等前缀，它会默认从classpath中加载bean定义配置文件</em>*</p></li><li><p>而<strong>FileSystemXmlApplicationContext则有些不同，它会尝试从文件系统中加载bean定义文件</strong></p></li><li><p><strong>通过在资源路径之前增加classpath:前缀，明确指定</strong><br><strong>FileSystemXmlApplicationContext从classpath中加载bean定义的配置文件</strong></p><p><code>ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;classpath:conf/appContext.xml&quot;);</code></p></li><li><p>这时，<strong>FileSystemXmlApplicationContext就是从Classpath中加载配置，而不是从文件系统中加载</strong>。也就是说，它现在对应的是ClassPathResource类型的资源，而不是默认的FileSystemResource类型资源。FileSystemXmlApplicationContext之所以如此，是因为它与FileSystemResourceLoader一样，也<strong>覆写了DefaultResourceLoader的getResourceByPath(String)方法</strong>，逻辑跟 FileSystemResourceLoader一模一样</p></li><li><p>对于ClassPathXmlApplicationContext来说，如果我们<strong>不指定路径之前的前缀</strong>，它也不会像资源路径所表现的那样，从文件系统加载资源，而是像实例化时候的行为一样，<strong>从Classpath中加载这种没有路径前缀的资源</strong></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-ioc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;spring&amp;mybatis/Spring IoC#spring-ioc&quot;&gt;&lt;/a&gt; Spring IoC&lt;a href=&quot;spring&amp;mybatis/Spring I
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring&amp;mybatis/Spring MVC</title>
    <link href="ilucia.github.io/spring&amp;mybatis/Spring%20MVC/"/>
    <id>ilucia.github.io/spring&amp;mybatis/Spring%20MVC/</id>
    <published>2022-04-27T15:24:01.747Z</published>
    <updated>2022-04-27T15:24:01.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="spring-mvc"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#spring-mvc"></a> Spring MVC<a href="spring&mybatis/Spring MVC#spring-mvc"></a></h2><h3 id="spring-ioc"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#spring-ioc"></a> Spring ioc<a href="spring&mybatis/Spring MVC#spring-ioc"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/SpringIOC.jpg" alt="" class="article-img"></p><h3 id="原理"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#原理"></a> 原理<a href="spring&mybatis/Spring MVC#原理"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="" class="article-img"></p><h4 id="1-dispatcherservlet"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#1-dispatcherservlet"></a> 1. DispatcherServlet<a href="spring&mybatis/Spring MVC#1-dispatcherservlet"></a></h4><ul><li>DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器</li></ul><h4 id="2-handlermapping"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#2-handlermapping"></a> 2. HandlerMapping<a href="spring&mybatis/Spring MVC#2-handlermapping"></a></h4><ul><li>DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会<strong>根据请求所携带的 URL 信息来进行决策</strong></li><li>例如通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"simpleUrlHandlerMapping"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- /hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/hello"</span>&gt;</span>helloController<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloController"</span> <span class="attr">class</span>=<span class="string">"controller.HelloController"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="3-控制器"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#3-控制器"></a> 3. 控制器<a href="spring&mybatis/Spring MVC#3-控制器"></a></h4><ul><li>一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="4-返回dispatcherservlet"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#4-返回dispatcherservlet"></a> 4. 返回DispatcherServlet<a href="spring&mybatis/Spring MVC#4-返回dispatcherservlet"></a></h4><ul><li>当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为<strong>模型（Model）</strong>。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个<strong>视图（view）</strong>，通常会是 JSP</li><li>控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名**（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet**</li><li>这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，<strong>它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图</strong></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 返回给 DispatcherServlet</span></span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="5-视图解析器"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#5-视图解析器"></a> 5. 视图解析器<a href="spring&mybatis/Spring MVC#5-视图解析器"></a></h4><ul><li>DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP</li></ul><h4 id="6-视图"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#6-视图"></a> 6. 视图<a href="spring&mybatis/Spring MVC#6-视图"></a></h4><ul><li>既然 DispatcherServlet 已经知道由哪个视图渲染结果了，那请求的任务基本上也就完成了</li><li>它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端</li></ul><h3 id="使用注解配置springmvc"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#使用注解配置springmvc"></a> 使用注解配置SpringMVC<a href="spring&mybatis/Spring MVC#使用注解配置springmvc"></a></h3><h4 id="完整的命名空间"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#完整的命名空间"></a> 完整的命名空间<a href="spring&mybatis/Spring MVC#完整的命名空间"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/context/spring-context-4.2.xsd"</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="主要注解"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#主要注解"></a> 主要注解<a href="spring&mybatis/Spring MVC#主要注解"></a></h4><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/SpringMVC%E6%B3%A8%E8%A7%A3.png" alt="" class="article-img"></p><h3 id="配置视图解析器"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#配置视图解析器"></a> 配置视图解析器<a href="spring&mybatis/Spring MVC#配置视图解析器"></a></h3><p>视图解析器负责定位视图，它接受一个由 DispaterServlet 传递过来的逻辑视图名来匹配一个特定的视图。</p><ul><li><strong>需求：</strong> 有一些页面我们不希望用户用户直接访问到，例如有重要数据的页面，例如有模型数据支撑的页面</li><li><strong>造成的问题：</strong><ul><li>我们可以在【web】根目录下放置一个【test.jsp】模拟一个重要数据的页面，我们什么都不用做，重新启动服务器，网页中输入 <code>localhost/test.jsp</code> 就能够直接访问到了，这会造成<strong>数据泄露</strong></li><li>另外我们可以直接输入 <code>localhost/index.jsp</code> 试试，根据我们上面的程序，这会是一个空白的页面，因为并没有获取到 <code>${message}</code> 参数就直接访问了，这会<strong>影响用户体验</strong></li></ul></li></ul><h4 id="解决方案"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#解决方案"></a> 解决方案<a href="spring&mybatis/Spring MVC#解决方案"></a></h4><ul><li><p>我们将我们的 JSP 文件配置在【WEB-INF】文件夹中的【page】文件夹下，【WEB-INF】是 Java Web 中默认的安全目录，是不允许用户直接访问的</p><ul><li>也就是你说你通过 <code>localhost/WEB-INF/</code> 这样的方式是永远访问不到的</li></ul></li><li><p>但是我们需要将这告诉给视图解析器，我们在 dispatcher-servlet.xml 文件中做如下配置</p></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"viewResolver"</span></span><br><span class="line">      <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"prefix"</span> value=<span class="string">"/WEB-INF/page/"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"suffix"</span> value=<span class="string">".jsp"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></div></figure><p>这里配置了一个 Spring MVC 内置的一个视图解析器，该解析器是遵循着一种约定：会<strong>在视图名上添加前缀和后缀，进而确定一个 Web 应用中视图资源的物理路径的</strong></p><h5 id="修改hellocontroller"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#修改hellocontroller"></a> 修改HelloController<a href="spring&mybatis/Spring MVC#修改hellocontroller"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Controller用来声明控制器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * description: RequestMapping注解用来映射 路径请求和方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpServletRequest 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpServletResponse 回应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> org.springframework.web.servlet.ModelAndView</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">        mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello Spring MVC"</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="配置视图解析器-2"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#配置视图解析器-2"></a> 配置视图解析器<a href="spring&mybatis/Spring MVC#配置视图解析器-2"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id="simpleUrlHandlerMapping"--&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name="mappings"&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;props&gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&amp;lt;!&amp;ndash; /hello 路径的请求交给 id 为 helloController 的控制器处理&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--&lt;prop key="/hello"&gt;helloController&lt;/prop&gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;/props&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;bean id="helloController" class="controller.HelloController"&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描controller下的组件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/page/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h5 id="剪切indexjsp文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#剪切indexjsp文件"></a> 剪切index.jsp文件<a href="spring&mybatis/Spring MVC#剪切indexjsp文件"></a></h5><h3 id="控制器接收请求数据"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#控制器接收请求数据"></a> 控制器接收请求数据<a href="spring&mybatis/Spring MVC#控制器接收请求数据"></a></h3><h5 id="testjsp"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#testjsp"></a> test.jsp<a href="spring&mybatis/Spring MVC#testjsp"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span> <span class="attr">import</span>=<span class="string">"java.util.*"</span> <span class="attr">isELIgnored</span>=<span class="string">"false"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring MVC 传参方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/param"</span> <span class="attr">role</span>=<span class="string">"form"</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"userName"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提  交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handlePost</span><span class="params">(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"test"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><h4 id="使用servlet原生api"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#使用servlet原生api"></a> 使用Servlet原生API<a href="spring&mybatis/Spring MVC#使用servlet原生api"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getParam</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                         HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    String userName = request.getParameter(<span class="string">"userName"</span>);</span><br><span class="line">    String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(userName);</span><br><span class="line">    System.out.println(password);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="使用requestparam前台参数名注入"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#使用requestparam前台参数名注入"></a> 使用@RequestParam(“前台参数名”)注入<a href="spring&mybatis/Spring MVC#使用requestparam前台参数名注入"></a></h4><ul><li>同名匹配原则</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getParam</span><span class="params">(@RequestParam(<span class="string">"userName"</span>)</span> String name, @<span class="title">RequestParam</span><span class="params">(<span class="string">"password"</span>)</span> String pwd) </span>&#123;</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(pwd);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><p>该注解有三个变量：<code>value</code>、<code>required</code>、<code>defaultvalue</code></p></li><li><p><code>value</code> ：指定 <code>name</code> 属性的名称是什么，<code>value</code> 属性都可以默认不写</p><p><code>required</code> ：是否必须要有该参数，可以设置为【true】或者【false】</p><p><code>defaultvalue</code> ：设置默认值</p></li></ul><h4 id="使用模型传参"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#使用模型传参"></a> 使用模型传参<a href="spring&mybatis/Spring MVC#使用模型传参"></a></h4><ul><li><strong>要求： 前台参数名字必须和模型中的字段名一样</strong></li></ul><h5 id="user模型"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#user模型"></a> User模型<a href="spring&mybatis/Spring MVC#user模型"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String userName;</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* getter and setter */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/param"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getParam</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user.getUserName());</span><br><span class="line">    System.out.println(user.getPassword());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="中文乱码解决"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#中文乱码解决"></a> 中文乱码解决<a href="spring&mybatis/Spring MVC#中文乱码解决"></a></h4><ul><li><strong>注意：</strong> 跟 Servlet 中的一样，该方法只对 POST 方法有效（因为是直接处理的 request）</li></ul><p>我们可以通过配置 Spring MVC 字符编码过滤器来完成，在 web.xml 中添加</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">name</span>&gt;<span class="title">encoding</span>&lt;/<span class="title">param</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">        &lt;!-- 设置编码格式 --&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="title">param</span>-<span class="title">value</span>&gt;<span class="title">utf</span>-8&lt;/<span class="title">param</span>-<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">init</span>-<span class="title">param</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">CharacterEncodingFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h3 id="控制器回显数据"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#控制器回显数据"></a> 控制器回显数据<a href="spring&mybatis/Spring MVC#控制器回显数据"></a></h3><ul><li>在page下创建test2.jsp</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span> <span class="attr">import</span>=<span class="string">"java.util.*"</span> <span class="attr">isELIgnored</span>=<span class="string">"false"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Spring MVC 数据回显<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>回显数据：$&#123;message&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="使用servlet原生api-2"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#使用servlet原生api-2"></a> 使用Servlet原生API<a href="spring&mybatis/Spring MVC#使用servlet原生api-2"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/value"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showData</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    request.setAttribute(<span class="string">"message"</span>,<span class="string">"成功！"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"test2"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="使用modelandview"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#使用modelandview"></a> 使用ModelAndView<a href="spring&mybatis/Spring MVC#使用modelandview"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/value"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showData</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"test2"</span>);</span><br><span class="line">  mav.addObject(<span class="string">"message"</span>,<span class="string">"成功！"</span>)</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="使用model对象"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#使用model对象"></a> 使用model对象<a href="spring&mybatis/Spring MVC#使用model对象"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">model</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"message"</span>, <span class="string">"注解成功"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/value"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">showData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"test2"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="客户端跳转"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#客户端跳转"></a> 客户端跳转<a href="spring&mybatis/Spring MVC#客户端跳转"></a></h3><ul><li>前面不管是地址 <code>/hello</code> 跳转到 index.jsp 还是 <code>/test</code> 跳转到 test.jsp，这些都是服务端的跳转，也就是 <code>request.getRequestDispatcher(&quot;地址&quot;).forward(request, response);</code></li><li>那我们如何进行客户端跳转呢？我们继续在 HelloController 中编写</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">    mav.addObject(<span class="string">"message"</span>, <span class="string">"Hello Spring MVC"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jump"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mav = <span class="keyword">new</span> ModelAndView(<span class="string">"redirect:/hello"</span>);</span><br><span class="line">    <span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/jump"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect: ./hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>我们使用 <code>redirect:/hello</code> 就表示我们要跳转到 <code>/hello</code> 这个路径，我们重启服务器，在地址栏中输入：<code>localhost/jump</code> ，会自动跳转到 <code>/hello</code> 路径下</li></ul><h3 id="文件上传"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#文件上传"></a> 文件上传<a href="spring&mybatis/Spring MVC#文件上传"></a></h3><ul><li>需要先导入 <code>commons-io-1.3.2.jar</code> 和 <code>commons-fileupload-1.2.1.jar</code> 两个包</li></ul><h4 id="1-配置上传解析器"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#1-配置上传解析器"></a> 1. 配置上传解析器<a href="spring&mybatis/Spring MVC#1-配置上传解析器"></a></h4><ul><li>在 dispatcher-servlet.xml 中新增一句<ul><li>开启对上传功能的支持</li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"multipartResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>/&gt;</span><br></pre></td></tr></table></div></figure><h4 id="2-编写uploadjsp"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#2-编写uploadjsp"></a> 2. 编写upload.jsp<a href="spring&mybatis/Spring MVC#2-编写uploadjsp"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试文件上传<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"picture"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"上 传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="3-编写控制器"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#3-编写控制器"></a> 3. 编写控制器<a href="spring&mybatis/Spring MVC#3-编写控制器"></a></h4><ul><li>在 Package【controller】下新建【UploadController】类</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/upload"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">(@RequestParam(<span class="string">"picture"</span>)</span> MultipartFile picture) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(picture.getOriginalFilename());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">upload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView(<span class="string">"upload"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="4-测试"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#4-测试"></a> 4. 测试<a href="spring&mybatis/Spring MVC#4-测试"></a></h4><h3 id="webxml"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#webxml"></a> web.xml<a href="spring&mybatis/Spring MVC#webxml"></a></h3><h4 id="加载流程"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#加载流程"></a> 加载流程<a href="spring&mybatis/Spring MVC#加载流程"></a></h4><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/web_xml%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png" alt="" class="article-img"></p><h4 id="配置"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#配置"></a> 配置<a href="spring&mybatis/Spring MVC#配置"></a></h4><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/web_xml%E9%85%8D%E7%BD%AE.png" alt="" class="article-img"></p><h3 id="dispatcherservlet"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#dispatcherservlet"></a> DispatcherServlet<a href="spring&mybatis/Spring MVC#dispatcherservlet"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/SpringMVC%E6%B5%81%E7%A8%8B%E7%A4%BA%E4%BE%8B.jpg" alt="" class="article-img"></p><h3 id="特殊bean"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#特殊bean"></a> 特殊bean<a href="spring&mybatis/Spring MVC#特殊bean"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/SpringMVC%E7%89%B9%E6%AE%8Abean.png" alt="" class="article-img"></p><h3 id="applicationcontextxml配置文件标签"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#applicationcontextxml配置文件标签"></a> applicationContext.xml配置文件标签<a href="spring&mybatis/Spring MVC#applicationcontextxml配置文件标签"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/applicationContext_xml%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A0%87%E7%AD%BE.png" alt="" class="article-img"></p><h3 id="异常处理"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#异常处理"></a> 异常处理<a href="spring&mybatis/Spring MVC#异常处理"></a></h3><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/SpringMVC%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.png" alt="" class="article-img"></p><h3 id="数据处理"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#数据处理"></a> 数据处理<a href="spring&mybatis/Spring MVC#数据处理"></a></h3><div class="article-bounded"><div class="article-table"><table><thead><tr><th>数据类型</th><th>处理所需注解</th></tr></thead><tbody><tr><td>application/x-www-form-urlencoded</td><td>Html表单默认传输编码类型，@RequestParam、@ModelAttribute可以处理，@RequestBody也能处理</td></tr><tr><td>multipart/form-data</td><td>是表单上传的非文本的内容，传递的是文件数据，设置该属性再配合post请求方式从而实现文件上传。需要使用解析器，不能直接处理（即使用@RequestBody不能处理这种格式的数据）</td></tr><tr><td>其他格式</td><td>其他格式包括application/json, application/xml等。这些格式的数据，必须使用@RequestBody来处理</td></tr></tbody></table></div></div><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单get请求</span></span><br><span class="line"><span class="comment">     * 组合注解 <span class="doctag">@GetMapping</span></span></span><br><span class="line"><span class="comment">     * 是<span class="doctag">@RequestMapping</span>(method = RequestMethod.GET)的缩写</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test2/sun</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"test2/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test2</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// \n不起作用了,那就直接用html中的标签吧</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"oh you are "</span> + name + <span class="string">"&lt;br&gt; nice to meet you"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单get请求2</span></span><br><span class="line"><span class="comment">     * 注解 <span class="doctag">@PathVariable</span> 映射URL绑定的占位符</span></span><br><span class="line"><span class="comment">     * 1）带占位符的URL是Spring3.0新增的功能，该功能在SpringMVC向REST目标挺进发展过程中具有里程碑的意义。</span></span><br><span class="line"><span class="comment">     * 2）通过<span class="doctag">@PathVariable</span>可以将URL中占位符参数绑定到控制器处理方法的入参中：</span></span><br><span class="line"><span class="comment">     *    URL中的&#123;xxx&#125;占位符可以通过<span class="doctag">@PathVariable</span>("xxx")绑定到操作方法的入参中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test3/admin&amp;admin</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"/test3/&#123;name&#125;&amp;&#123;pwd&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test3</span><span class="params">(@PathVariable String name, @PathVariable String pwd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"admin"</span>) &amp;&amp; pwd.equals(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello welcome admin"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"oh sorry user name or password is wrong"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get请求</span></span><br><span class="line"><span class="comment">     * 注解 <span class="doctag">@RequestParam</span>绑定请求参数值</span></span><br><span class="line"><span class="comment">     * 在处理方法入参使用<span class="doctag">@RequestParam</span>可以把请求参数传递给请求方法，<span class="doctag">@RequestParam</span>包含的属性值：</span></span><br><span class="line"><span class="comment">     * --- value ：参数名称</span></span><br><span class="line"><span class="comment">     * --- required ：是否必须，默认为true，表示请求参数中必须包含对应的参数，否则抛出异常。</span></span><br><span class="line"><span class="comment">     * --- defaultValue：当请求参数缺少或者有请求参数但值为空时，值采用该设置值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test4?name=111&amp;pwd=111</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test4"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test4</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">true</span>)</span> String name,</span></span><br><span class="line"><span class="function">                             @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"pwd"</span>, required = <span class="keyword">true</span>)</span> String pwd) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"admin"</span>) &amp;&amp; pwd.equals(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.success());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.error());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单post请求</span></span><br><span class="line"><span class="comment">     * 组合注解 <span class="doctag">@PostMapping</span></span></span><br><span class="line"><span class="comment">     * 是<span class="doctag">@RequestMapping</span>(method = RequestMethod.POST)的缩写。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test5"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello test5"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"test5"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * post请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test6?name=111&amp;pwd=111</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test6"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test6</span><span class="params">(@RequestParam(value = <span class="string">"name"</span>, required = <span class="keyword">true</span>)</span> String name,</span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(value = <span class="string">"pwd"</span>, required = <span class="keyword">true</span>)</span> String pwd) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"admin"</span>) &amp;&amp; pwd.equals(<span class="string">"admin"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.success());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.error());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数为一个bean对象.spring会自动为我们关联映射</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * get post</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test7?id=1</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * post form-data和 x-www-form-urlencoded</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test7</span></span><br><span class="line"><span class="comment">     * id  1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test7"</span>, method = &#123; RequestMethod.POST, RequestMethod.GET &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test7</span><span class="params">(BaseEntity entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != entity &amp;&amp; entity.getId() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.success());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.error());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求内容是一个json串,spring会自动把他和我们的参数bean对应起来</span></span><br><span class="line"><span class="comment">     * 不过要加<span class="doctag">@RequestBody</span>注解</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * post row(application/json)</span></span><br><span class="line"><span class="comment">     * http://localhost:8089/test/test8</span></span><br><span class="line"><span class="comment">     * id   1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test8"</span>, method = &#123; RequestMethod.POST, RequestMethod.GET &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test8</span><span class="params">(@RequestBody BaseEntity entity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != entity &amp;&amp; entity.getId() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.success());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> JSON.toJSONString(Result.error());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="处理multipartform-data"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#处理multipartform-data"></a> 处理multipart/form-data<a href="spring&mybatis/Spring MVC#处理multipartform-data"></a></h4><ul><li>multipart格式的数据会将一个表单拆分为多个部分（part），每个部分对应一个输入域。在一般的表单输入域中，它所对应的部分中会放置文本型数据，但是如果上传文件的话，它所对应的部分可以是二进制</li></ul><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/multipart_form-data%E7%A4%BA%E4%BE%8B.png" alt="" class="article-img"></p><ul><li>配置一个multipart解析器，通过它来告诉DispatcherServlet该如何读取multipart请求</li></ul><h5 id="standardservletmultipartresolver"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#standardservletmultipartresolver"></a> StandardServletMultipartResolver<a href="spring&mybatis/Spring MVC#standardservletmultipartresolver"></a></h5><ul><li>applicationContext.xml中添加</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.StandardServletMultipartResolver"</span>/&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>配置类</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"multipartResolver"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> StandardServletMultipartResolver <span class="title">getStandardServletMultipartResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> StandardServletMultipartResolver();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>web.xml配置上传参数</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--上传到/tmp/upload 目录--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">location</span>&gt;</span>/tmp/upload<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--文件大小为2M--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--整个请求不超过4M--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>4194304<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有文件都要写入磁盘--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">file-size-threshold</span>&gt;</span>0<span class="tag">&lt;/<span class="name">file-size-threshold</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>配置类中配置上传参数</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeRegistration</span><span class="params">(ServletRegistration.Dynamic registration)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//上传到/tmp/upload 目录，文件大小为2M，整个请求不超过4M，而且所有文件都要写入磁盘</span></span><br><span class="line">  registration.setMultipartConfig(<span class="keyword">new</span> MultipartConfigElement(<span class="string">"E:\\upload_ftp"</span>,<span class="number">2097152</span>,<span class="number">4194304</span>,<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="commonsmultipartresolver"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#commonsmultipartresolver"></a> CommonsMultipartResolver<a href="spring&mybatis/Spring MVC#commonsmultipartresolver"></a></h5><ul><li>在applicationContext.xml中设置</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"multipartResolver"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span><br><span class="line">       &lt;!--设置上传目录/tmp/upload;最大的文件容量设置为<span class="number">2</span>M;最大的内存大小设置为<span class="number">0</span>，表示所有文件都会写入磁盘中;无法设定multipart请求整体的最大容量--&gt;</span><br><span class="line">        &lt;property name=<span class="string">"uploadTempDir"</span> value=<span class="string">"/tmp/upload"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"maxUploadSize"</span> value=<span class="string">"2097152"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"maxInMemorySize"</span> value=<span class="string">"0"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></div></figure><ul><li>CommonsMultipartResolver 相比较 StandardServletMultipartResolver 来说 就是无法设定multipart请求整体的最大容量。</li><li>CommonsMultipartResolver不会强制要求设置临时文件路径。默认情况下，这个路径就是Servlet容器的临时目录。 StandardServletMultipartResolver 必须设置临时文件路径才能正常执行。（以上所述上传目录均为临时文件路径）</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/picture"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"picture"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/picture"</span>,method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getHome</span><span class="params">(@RequestPart(<span class="string">"picture"</span>)</span> MultipartFile picture) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">String name = picture.getName();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = picture.getBytes();</span><br><span class="line">  picture.transferTo(<span class="keyword">new</span> File(<span class="string">"/"</span>+picture.getOriginalFilename())); </span><br><span class="line">  <span class="comment">//这里保存到文件系统的时候要用相对路径，比如这里配置的是 /。以配置的上传目录为基准。即文件路径E:/upload_ftp/ 是保存的目录</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>@RequestPart(“picture”) ：当注册表单提交的时候，picture属性将会给定一个byte数组，这个数组中包含了请求中对应part的数据（通过@RequestPart指定）。如果用户提交表单的时候没有选择文件，那么这个数组会是空（而不是null）<ul><li>甚至可以用byte[]数组接收Multipart请求而不用 MultipartFile</li></ul></li><li>用MultipartFile接收为我们提供了很多的方法以便进行接下来的工作</li></ul><h4 id="下载文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring MVC#下载文件"></a> 下载文件<a href="spring&mybatis/Spring MVC#下载文件"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"download/&#123;fileName:.+&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">downloadZipResource</span><span class="params">(HttpServletRequest request, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     HttpServletResponse response, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     @PathVariable(<span class="string">"fileName"</span>)</span> String fileName) </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServletContext context = request.getSession().getServletContext();</span><br><span class="line">        String dataDirectory  = context.getRealPath(<span class="string">"/downloads"</span>) + <span class="string">"/"</span> + fileName;</span><br><span class="line">        File file = <span class="keyword">new</span> File(dataDirectory);</span><br><span class="line">        <span class="keyword">if</span> (file.isFile()) </span><br><span class="line">        &#123;</span><br><span class="line">            String mimeType = context.getMimeType(dataDirectory);   <span class="comment">//直接根据文件的路径名来获取它的MineType，这样就可以灵活的根据请求的文件类型来返回输出流了</span></span><br><span class="line">            response.setContentType(mimeType);</span><br><span class="line">            response.addHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment; filename="</span>+fileName);</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                OutputStream os = response.getOutputStream();;</span><br><span class="line">                IOUtils.copy(<span class="keyword">new</span> FileInputStream(file), os);</span><br><span class="line">                os.flush();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;spring-mvc&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;spring&amp;mybatis/Spring MVC#spring-mvc&quot;&gt;&lt;/a&gt; Spring MVC&lt;a href=&quot;spring&amp;mybatis/Spring M
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>spring&amp;mybatis/Spring基础</title>
    <link href="ilucia.github.io/spring&amp;mybatis/Spring%E5%9F%BA%E7%A1%80/"/>
    <id>ilucia.github.io/spring&amp;mybatis/Spring%E5%9F%BA%E7%A1%80/</id>
    <published>2022-04-27T15:24:01.747Z</published>
    <updated>2022-04-27T15:24:01.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring基础"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#spring基础"></a> Spring基础<a href="spring&mybatis/Spring基础#spring基础"></a></h1><h2 id="core模块"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#core模块"></a> Core模块<a href="spring&mybatis/Spring基础#core模块"></a></h2><h3 id="注解方式配置"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#注解方式配置"></a> 注解方式配置<a href="spring&mybatis/Spring基础#注解方式配置"></a></h3><p>⾃从jdk5有了注解这个新特性，我们可以看到Struts2框架、Hibernate框架都⽀持使⽤注解来配置信<br>息…<br>通过注解来配置信息就是为了简化IOC容器的配置，注解可以把对象添加到IOC容器中、处理对象依赖<br>关系，我们来看看怎么⽤吧：<br>使⽤注解步骤：<br>1）先引⼊context名称空间<br>xmlns:context=&quot;<a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a></p><p>2）开启注解扫描器<br>&lt;context:component-scan base-package=&quot;&quot;&gt;&lt;/context:component-scan&gt;<br>第⼆种⽅法:也可以通过⾃定义扫描类以@CompoentScan修饰来扫描IOC容器的bean对象。<br>如下代码:</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表明该类是配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//启动扫描器，扫描bb包下的</span></span><br><span class="line"><span class="comment">//也可以指定多个基础包</span></span><br><span class="line"><span class="comment">//也可以指定类型</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"bb"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationScan</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>在使⽤<code>@ComponentScan()</code>这个注解的时候，在测试类上需要<code>@ContextConfiguration</code>这个注解来加载配置类</li><li><code>@ContextConfiguration</code>这个注解⼜在Spring的test包下</li><li>创建对象以及处理对象依赖关系，相关的注解：<ul><li><code>@ComponentScan</code>扫描器</li><li><code>@Configuration</code>表明该类是配置类</li><li><code>@Component</code> 指定把⼀个对象加⼊IOC容器—&gt;@Name也可以实现相同的效果【⼀般少⽤】</li><li><code>@Repository</code> 作⽤同@Component； 在持久层使⽤</li><li><code>@Service</code> 作⽤同@Component； 在业务逻辑层使⽤</li><li><code>@Controller</code> 作⽤同@Component； 在控制层使⽤</li><li><code>@Resource</code> 依赖关系<ul><li>如果<code>@Resource</code>不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个<br>如果<code>@Resource</code>指定了值，那么就根据名字来找</li></ul></li></ul></li></ul><h4 id="userdao"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#userdao"></a> UserDao<a href="spring&mybatis/Spring基础#userdao"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package aa;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line">/**</span><br><span class="line">* Created by ozc on 2017/5/10.</span><br><span class="line">*/</span><br><span class="line">//把对象添加到容器中,⾸字⺟会⼩写</span><br><span class="line">@Repository</span><br><span class="line">public class UserDao &#123;</span><br><span class="line">public void save() &#123;</span><br><span class="line">System.out.println(&quot;DB:保存⽤户&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="userservice"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#userservice"></a> userService<a href="spring&mybatis/Spring基础#userservice"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">//把UserService对象添加到IOC容器中,⾸字⺟会⼩写</span><br><span class="line">@Service</span><br><span class="line">public class UserService &#123;</span><br><span class="line">//如果@Resource不指定值，那么就根据类型来找---&gt;UserDao....当然了，IOC容器不能有两个</span><br><span class="line">UserDao类型的对象</span><br><span class="line">//@Resource</span><br><span class="line">//如果指定了值，那么Spring就在IOC容器找有没有id为userDao的对象。</span><br><span class="line">@Resource(name = &quot;userDao&quot;)</span><br><span class="line">private UserDao userDao;</span><br><span class="line">public void save() &#123;</span><br><span class="line">userDao.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="useraction"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#useraction"></a> userAction<a href="spring&mybatis/Spring基础#useraction"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*/</span><br><span class="line">//把对象添加到IOC容器中,⾸字⺟会⼩写</span><br><span class="line">@Controller</span><br><span class="line">public class UserAction &#123;</span><br><span class="line">@Resource(name = &quot;userService&quot;)</span><br><span class="line">private UserService userService;</span><br><span class="line">public String execute() &#123;</span><br><span class="line">userService.save();</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="测试"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#测试"></a> 测试<a href="spring&mybatis/Spring基础#测试"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class App &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 创建容器对象</span><br><span class="line">ApplicationContext ac = new</span><br><span class="line">ClassPathXmlApplicationContext(&quot;aa/applicationContext.xml&quot;);</span><br><span class="line">UserAction userAction = (UserAction) ac.getBean(&quot;userAction&quot;);</span><br><span class="line">userAction.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="bean创建细节"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#bean创建细节"></a> Bean创建细节<a href="spring&mybatis/Spring基础#bean创建细节"></a></h4><ul><li>参数指定</li></ul><h5 id="单例多例"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#单例多例"></a> 单例/多例<a href="spring&mybatis/Spring基础#单例多例"></a></h5><ul><li><code>scope=&quot;singleton&quot;</code> 默认值， 即 默认是单例 【service/dao/⼯具类】</li></ul><ul><li><code>scope=&quot;prototype&quot;</code> 多例<ul><li>Action对象</li></ul></li></ul><h5 id="创建时间点"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#创建时间点"></a> 创建时间点<a href="spring&mybatis/Spring基础#创建时间点"></a></h5><ul><li><code>scope=&quot;prototype&quot;</code> 在⽤到对象的时候，才创建对象</li></ul><ul><li><code>scope=&quot;singleton&quot;</code> 在启动(容器初始化之前)， 就已经创建了bean，且整个应⽤只有⼀<br>个</li></ul><h5 id="是否延迟创建"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#是否延迟创建"></a> 是否延迟创建<a href="spring&mybatis/Spring基础#是否延迟创建"></a></h5><ul><li><code>lazy-init=&quot;false&quot;</code> 默认为false, 不延迟创建，即在启动时候就创建对象</li><li><code>lazy-init=&quot;true&quot;</code> 延迟初始化, 在⽤到对象的时候才创建对象<ul><li>只对单例有效</li></ul></li></ul><h5 id="创建对象之后的初始化销毁"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#创建对象之后的初始化销毁"></a> 创建对象之后的初始化/销毁<a href="spring&mybatis/Spring基础#创建对象之后的初始化销毁"></a></h5><ul><li><code>init-method=&quot;init_user&quot;</code> 对应对象的init_user⽅法，在对象创建之后执⾏</li></ul><ul><li><code>destroy-method=&quot;destroy_user&quot;</code> 在调⽤容器对象的destroy⽅法时候执⾏，(容器⽤<br>实现类)</li></ul><h2 id="依赖注入"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#依赖注入"></a> 依赖注入<a href="spring&mybatis/Spring基础#依赖注入"></a></h2><p>Spring提供了好⼏种的⽅式来给属性赋值</p><ol><li>通过构造函数</li><li>通过set⽅法给属性注⼊值</li><li>p名称空间</li><li>⾃动装配(了解)</li><li>注解</li></ol><h3 id="使用注解实现自动装配"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#使用注解实现自动装配"></a> 使用注解实现自动装配<a href="spring&mybatis/Spring基础#使用注解实现自动装配"></a></h3><ul><li>@Autowired注解来实现⾃动装配<ul><li>可以在构造器上修饰，也可以在setter⽅法上修饰</li><li>来⾃java的@Inject的和@AutoWired有相同的功能</li><li>如果没有匹配到bean，为了避免异常的出现，我们可以使⽤required属性上设置为false</li></ul></li></ul><p>UserService中使⽤userDao变量来维护与Dao层之间的依赖关系，UserAction中使⽤userService变量<br>来维护与Service层之间的依赖关系。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"DB:保存⽤户"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userDao.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">userService.save();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="applicationcontextxml配置文件"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#applicationcontextxml配置文件"></a> applicationContext.xml配置⽂件<a href="spring&mybatis/Spring基础#applicationcontextxml配置文件"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建userDao对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"UserDao"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--创建userService对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userService"</span> <span class="attr">class</span>=<span class="string">"UserService"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--要想在userService层中能够引⽤到userDao，就必须先创建userDao对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">type</span>=<span class="string">"UserDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h2 id="aop"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#aop"></a> AOP<a href="spring&mybatis/Spring基础#aop"></a></h2><h3 id="注解方式实现aop编程"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#注解方式实现aop编程"></a> 注解⽅式实现AOP编程<a href="spring&mybatis/Spring基础#注解方式实现aop编程"></a></h3><p>我们之前⼿动的实现AOP编程是需要⾃⼰来编写代理⼯⼚的，现在有了Spring，就不需要我们⾃⼰写代<br>理⼯⼚了。Spring内部会帮我们创建代理⼯⼚。也就是说，不⽤我们⾃⼰写代理对象了</p><p>因此，我们只要关⼼<strong>切⾯类、切⼊点、编写切⼊表达式指定拦截什么⽅法</strong>就可以了</p><h4 id="在配置文件中开启aop注解方式"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#在配置文件中开启aop注解方式"></a> 在配置⽂件中开启AOP注解⽅式<a href="spring&mybatis/Spring基础#在配置文件中开启aop注解方式"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">                           http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"aa"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 开启aop注解⽅式 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="类代码"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#类代码"></a> 类代码<a href="spring&mybatis/Spring基础#类代码"></a></h4><h5 id="切面类"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#切面类"></a> 切⾯类<a href="spring&mybatis/Spring基础#切面类"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span><span class="comment">//指定为切⾯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AOP</span> </span>&#123;</span><br><span class="line">    <span class="comment">//⾥⾯的值为切⼊点表达式</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* aa.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* aa.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="userdao-2"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#userdao-2"></a> UserDao<a href="spring&mybatis/Spring基础#userdao-2"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> <span class="keyword">implements</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DB:保存⽤户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="iuser接口"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#iuser接口"></a> IUser接口<a href="spring&mybatis/Spring基础#iuser接口"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="测试-2"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#测试-2"></a> 测试<a href="spring&mybatis/Spring基础#测试-2"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aa/applicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">//这⾥得到的是代理对象....</span></span><br><span class="line">        IUser iUser = (IUser) ac.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">        System.out.println(iUser.getClass());</span><br><span class="line">        iUser.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="aop注解api"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#aop注解api"></a> AOP注解API<a href="spring&mybatis/Spring基础#aop注解api"></a></h4><ul><li><strong>@Aspect</strong><ul><li>指定⼀个类为切⾯类</li></ul></li><li><em><em>@Pointcut(&quot;execution(</em> cn.itcast.e_aop_anno…(…))&quot;)</em>*<ul><li>指定切⼊点表达式</li></ul></li><li><strong>@Before(“pointCut_()”)</strong><ul><li>前置通知，⽬标⽅法之前执⾏</li></ul></li><li><strong>@After(“pointCut_()”)</strong><ul><li>后置通知，⽬标⽅法之后执⾏（始终执⾏）</li></ul></li><li><strong>@AfterReturning(“pointCut_()”)</strong><ul><li>返回后通知，执⾏⽅法结束前执⾏(异常不执⾏)</li></ul></li><li><strong>@AfterThrowing(“pointCut_()”)</strong><ul><li>异常通知，出现异常时候执⾏</li></ul></li><li><strong>@Around(“pointCut_()”)</strong><ul><li>环绕通知，环绕⽬标⽅法执⾏</li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定切⼊点表达式，拦截哪个类的哪些⽅法</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* aa.*.*(..))"</span>)</span><br><span class="line"><span class="comment">//Point签名</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointCut_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前置通知 : 在执⾏⽬标⽅法之前执⾏</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"pointCut_()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"开始事务/异常"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后置/最终通知：在执⾏⽬标⽅法之后执⾏，⽆论是否出现异常最终都会执⾏</span></span><br><span class="line"><span class="meta">@After</span>(<span class="string">"pointCut_()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"提交事务/关闭"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回后通知： 在调⽤⽬标⽅法结束后执⾏ 【出现异常不执⾏】</span></span><br><span class="line"><span class="meta">@AfterReturning</span>(<span class="string">"pointCut_()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"afterReturning()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常通知： 当⽬标⽅法执⾏异常时候执⾏此关注点代码</span></span><br><span class="line"><span class="meta">@AfterThrowing</span>(<span class="string">"pointCut_()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"afterThrowing()"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 环绕通知：环绕⽬标⽅式执⾏</span></span><br><span class="line"><span class="meta">@Around</span>(<span class="string">"pointCut_()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"环绕前...."</span>);</span><br><span class="line">  pjp.proceed(); <span class="comment">// 执⾏⽬标⽅法</span></span><br><span class="line">  System.out.println(<span class="string">"环绕后...."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="pointcut"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#pointcut"></a> @Pointcut<a href="spring&mybatis/Spring基础#pointcut"></a></h4><p>在Spring 2.0中，Pointcut的定义包括两个部分：<strong>Pointcut表示式</strong>(expression)和<strong>Pointcut签名</strong>(signature)</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Pointcut表示式</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.savage.aop.MessageSender.*(..))"</span>)</span><br><span class="line"><span class="comment">//Point签名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></div></figure><p>然后要使用所定义的Pointcut时，可以指定Pointcut签名</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"og()"</span>)</span><br></pre></td></tr></table></div></figure><p>这种使用方式等同于以下方式，直接定义execution表达式使用</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* com.savage.aop.MessageSender.*(..))"</span>)</span><br></pre></td></tr></table></div></figure><p>Pointcut定义时，还<strong>可以使用&amp;&amp;、||、! 这三个运算</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.savage.aop.MessageSender.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logSender</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.savage.aop.MessageReceiver.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logReceiver</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"logSender() || logReceiver()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></div></figure><p>这个例子中，<strong>logMessage()将匹配任何MessageSender和MessageReceiver中的任何方法</strong></p><p>还可以<strong>将公用的Pointcut放到一个类中，以供整个应用程序使用</strong>，如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.savage.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pointcuts</span> </span>&#123;</span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* *Message(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* *Attachment(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logAttachment</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* *Service.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">auth</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在使用上面定义Pointcut时，指定完整的类名加上Pointcut签名就可以了，如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.savage.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogBeforeAdvice</span> </span>&#123;</span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"com.sagage.aop.Pointcuts.logMessage()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Logging before "</span> + joinPoint.getSignature().getName());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="切入点表达式"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#切入点表达式"></a> 切入点表达式<a href="spring&mybatis/Spring基础#切入点表达式"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</span><br></pre></td></tr></table></div></figure><ul><li><p><strong>?</strong> 号代表0或1，可以不写</p></li><li><p>*** **号代表任意类型，0或多</p></li><li><p>⽅法参数为 <strong>…</strong> 表示为可变参数</p></li><li><p><strong>modifiers-pattern?</strong>【修饰的类型，可以不写】</p></li><li><p><strong>ret-type-pattern</strong>【⽅法返回值类型，必写】</p></li><li><p><strong>declaring-type-pattern?</strong>【⽅法声明的类型，可以不写】</p></li><li><p><strong>name-pattern(param-pattern)</strong>【要匹配的名称，括号⾥⾯是⽅法的参数】</p></li><li><p><strong>throws-pattern?</strong>【⽅法抛出的异常类型，可以不写】</p></li></ul><h5 id="例"><a class="markdownIt-Anchor" href="spring&mybatis/Spring基础#例"></a> 例<a href="spring&mybatis/Spring基础#例"></a></h5><p><img src="/Users/ng/Documents/spring&amp;mybatis/pictures/%E5%88%87%E5%85%A5%E7%82%B9%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="" class="article-img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;spring&amp;mybatis/Spring基础#spring基础&quot;&gt;&lt;/a&gt; Spring基础&lt;a href=&quot;spring&amp;mybatis/Spring基础#spring基
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java1.8/集合_容器</title>
    <link href="ilucia.github.io/java1.8/%E9%9B%86%E5%90%88_%E5%AE%B9%E5%99%A8/"/>
    <id>ilucia.github.io/java1.8/%E9%9B%86%E5%90%88_%E5%AE%B9%E5%99%A8/</id>
    <published>2022-04-27T15:24:01.727Z</published>
    <updated>2022-04-27T15:24:01.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="容器"><a class="markdownIt-Anchor" href="java1.8/集合_容器#容器"></a> 容器<a href="java1.8/集合_容器#容器"></a></h1><h2 id="作用"><a class="markdownIt-Anchor" href="java1.8/集合_容器#作用"></a> 作用<a href="java1.8/集合_容器#作用"></a></h2><ul><li>可以动态增加长度</li><li>存储的元素都是对象(引用地址)，所以集合可以存储不同的数据类型，但如果是需要比较元素来排序的集合，则需要类型一致</li><li>提供了统一的增删改查方法，使用方便</li><li>支持泛型，避免数据不一致和转换异常，还对常用的数据结构进行了封装</li></ul><h2 id="总框架"><a class="markdownIt-Anchor" href="java1.8/集合_容器#总框架"></a> 总框架<a href="java1.8/集合_容器#总框架"></a></h2><ul><li>由Collection、Map(映射关系)和Iterator(迭代器)组成</li></ul><h3 id="collection体系"><a class="markdownIt-Anchor" href="java1.8/集合_容器#collection体系"></a> Collection体系<a href="java1.8/集合_容器#collection体系"></a></h3><ul><li>Set(集)： 元素是无序的且不可重复</li><li>List(列表)：元素是有序的且可重复</li><li>Queue(队列)：封装了数据结构中的队列</li></ul><h3 id="map体系"><a class="markdownIt-Anchor" href="java1.8/集合_容器#map体系"></a> Map体系<a href="java1.8/集合_容器#map体系"></a></h3><ul><li>Map用于保存具有映射关系的数据，即key-value(键值对)。Map集合的key是唯一的，不可重复，而value可以重复。所以一个value可以对应多个key</li><li>Map体系除了常用类之外，还有Properties（属性类）也属于Map体系</li></ul><h3 id="iterator迭代器"><a class="markdownIt-Anchor" href="java1.8/集合_容器#iterator迭代器"></a> Iterator(迭代器)<a href="java1.8/集合_容器#iterator迭代器"></a></h3><h4 id="迭代器模式"><a class="markdownIt-Anchor" href="java1.8/集合_容器#迭代器模式"></a> 迭代器模式<a href="java1.8/集合_容器#迭代器模式"></a></h4><ul><li>把访问逻辑从不同类型的集合类中抽取出来，从而避免向外部暴露集合的内部结构</li><li>在java中是一个对象，其目的是遍历并选中其中的每个元素，而使用者（客户端）无需知道里面的具体细节</li><li>要足够“轻量”，即创建代价小</li></ul><h4 id="iterator"><a class="markdownIt-Anchor" href="java1.8/集合_容器#iterator"></a> Iterator<a href="java1.8/集合_容器#iterator"></a></h4><ul><li>Collection集合元素的通用获取方式：在取出元素之前先判断集合中有没有元素。如果有，就把这个元素取出来，继续再判断，如果还有就再取出来，一直把集合中的所有元素全部取出来，这种取出元素的方式专业术语称为迭代</li><li>java.util.Iterator:在Java中Iterator为一个接口，它只提供了迭代的基本规则</li><li>Collection中有一个抽象方法iterator方法，所有的Collection子类都实现了这个方法，该方法返回一个Iterator对象</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;<span class="comment">//判断是否存在下一个对象元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;<span class="comment">//获取下一个元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>;<span class="comment">//移除元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="异常"><a class="markdownIt-Anchor" href="java1.8/集合_容器#异常"></a> 异常<a href="java1.8/集合_容器#异常"></a></h5><ul><li>在迭代集合中元素的过程中，集合的长度发生改变（进行了add或者remove操作)，会出现修改并发异常ConcurrentModificationException<ul><li>增强for的底层原理也是迭代器，所以也需要避免这种操作<ul><li>获取迭代器由jvm完成，不需要我们获取迭代器</li></ul></li></ul></li><li>在进行集合元素取出的时候，如果集合中没有元素了，还继续使用next()方法的话，将发生NoSuchElementException</li><li>解决上述异常的方法：使用ListIterator</li></ul><h4 id="iterable接口"><a class="markdownIt-Anchor" href="java1.8/集合_容器#iterable接口"></a> Iterable接口<a href="java1.8/集合_容器#iterable接口"></a></h4><ul><li>Iterable接口实现后的功能是‘返回’一个迭代器</li><li>该接口的iterator()方法返回一个标准的Iterator实现，实现Iterable接口允许对象成为Foreach语句的目标，就可以通过foreach语句来遍历你的底层序列</li></ul><h5 id="for-each语法使用"><a class="markdownIt-Anchor" href="java1.8/集合_容器#for-each语法使用"></a> for each语法使用<a href="java1.8/集合_容器#for-each语法使用"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); </span><br><span class="line"><span class="keyword">for</span> (String str: strs) &#123; out.println(str); &#125;</span><br></pre></td></tr></table></div></figure><ul><li>代码减少，方便遍历</li><li>没有索引，不能操作容器里的元素</li></ul><h4 id="foreach"><a class="markdownIt-Anchor" href="java1.8/集合_容器#foreach"></a> forEach()<a href="java1.8/集合_容器#foreach"></a></h4><ul><li>forEach方法接收lambda表达式</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strs = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>); <span class="comment">//使用Java 1.8的lambda表达式 </span></span><br><span class="line">strs.forEach(out::println);</span><br></pre></td></tr></table></div></figure><h4 id="spliterator迭代器"><a class="markdownIt-Anchor" href="java1.8/集合_容器#spliterator迭代器"></a> Spliterator迭代器<a href="java1.8/集合_容器#spliterator迭代器"></a></h4><ul><li>1.8新增的迭代器</li><li>属于并行迭代器，可以将迭代任务分割交由多个线程来进行<ul><li>使用Spliterator的时候，将元素分割成多份，分别交于不于的线程去遍历，以提高效率</li></ul></li><li>使用 Spliterator 每次可以处理某个元素集合中的一个元素<ul><li>不是从 Spliterator 中获取元素，而是使用 tryAdvance() 或 forEachRemaining() 方法对元素应用操作</li></ul></li><li>Spliterator 还可以用于估计其中保存的元素数量，而且还可以像细胞分裂一样变为一分为二</li></ul><h4 id="listiterator"><a class="markdownIt-Anchor" href="java1.8/集合_容器#listiterator"></a> ListIterator<a href="java1.8/集合_容器#listiterator"></a></h4><ul><li>是一个更强大的Iterator子类型，能用于各种List类访问</li><li>可以双向移动，所以能指出迭代器当前位置的前一个和后一个索引</li><li>可以用set方法替换它访问过的最后一个元素</li><li>调用listIterator方法产生一个指向List开始处的ListIterator</li><li>可以用过重载方法listIterator(n)来创建一个指定列表索引为n的元素的ListIterator</li></ul><h5 id="和iterator区别"><a class="markdownIt-Anchor" href="java1.8/集合_容器#和iterator区别"></a> 和Iterator区别<a href="java1.8/集合_容器#和iterator区别"></a></h5><ul><li>两者都有next()和hasNext()，可以实现向后遍历，但是ListIterator有previous()和hasPrevious()方法，即可以实现向前遍历</li><li>ListIterator可以定位当前位置，nextIndex()和previous()可以实现</li><li>ListIterator有add()方法，可以向list集合中添加数据</li><li>都可以实现删除操作，但是ListIterator可以通过set方法实现对对象的修改，Iterator仅能遍历，不能修改</li></ul><h4 id="fail-fast"><a class="markdownIt-Anchor" href="java1.8/集合_容器#fail-fast"></a> Fail-Fast<a href="java1.8/集合_容器#fail-fast"></a></h4><ul><li>类中的iterator()方法和listIterator()方法返回的iterators迭代器是<strong>fail-fast</strong>的</li><li>当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件</li></ul><h2 id="接口工具类"><a class="markdownIt-Anchor" href="java1.8/集合_容器#接口工具类"></a> 接口/工具类<a href="java1.8/集合_容器#接口工具类"></a></h2><h3 id="arrays"><a class="markdownIt-Anchor" href="java1.8/集合_容器#arrays"></a> Arrays<a href="java1.8/集合_容器#arrays"></a></h3><ul><li>数组的工具类,里面都是操作数组的工具</li></ul><h4 id="常用方法"><a class="markdownIt-Anchor" href="java1.8/集合_容器#常用方法"></a> 常用方法<a href="java1.8/集合_容器#常用方法"></a></h4><p>1、数组的排序:Arrays.sort(a);//实现了对数组从小到大的排序//注：此类中只有升序排序，而无降序排序。</p><p>2、数组元素的定位查找:Arrays.binarySearch(a,8);//二分查找法</p><p>3、数组的打印:Arrays.toString(a);//String 前的a和括号中的a均表示数组名称</p><p>4、 查看数组中是否有特定的值:Arrays.asList(a).contains(1)</p><h3 id="collections"><a class="markdownIt-Anchor" href="java1.8/集合_容器#collections"></a> Collections<a href="java1.8/集合_容器#collections"></a></h3><h4 id="排序操作"><a class="markdownIt-Anchor" href="java1.8/集合_容器#排序操作"></a> 排序操作<a href="java1.8/集合_容器#排序操作"></a></h4><ul><li>Collections提供以下方法对List进行排序操作</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span></span><br></pre></td></tr></table></div></figure><h4 id="查找替换操作"><a class="markdownIt-Anchor" href="java1.8/集合_容器#查找替换操作"></a> 查找/替换操作<a href="java1.8/集合_容器#查找替换操作"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span>,<span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用元素obj填充list中所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计targe在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span><span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></div></figure><h4 id="同步控制"><a class="markdownIt-Anchor" href="java1.8/集合_容器#同步控制"></a> 同步控制<a href="java1.8/集合_容器#同步控制"></a></h4><ul><li>Collections中几乎对每个集合都定义了同步控制方法, 这些方法，来将集合包装成线程安全的集合</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SynchronizedList(List);</span><br><span class="line">SynchronizedSet(Set;</span><br><span class="line">SynchronizedMap(Map);</span><br></pre></td></tr></table></div></figure><h2 id="collection"><a class="markdownIt-Anchor" href="java1.8/集合_容器#collection"></a> Collection<a href="java1.8/集合_容器#collection"></a></h2><ul><li>最基本的集合接口，一个Collection代表一组Object，即Collection的元素</li><li>Java SDK不提供直接继承自Collection的类， Java SDK提供的类都是继承自Collection的“子接口”如List和Set</li><li>所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的 Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection</li></ul><h3 id="遍历"><a class="markdownIt-Anchor" href="java1.8/集合_容器#遍历"></a> 遍历<a href="java1.8/集合_容器#遍历"></a></h3><ul><li>不论Collection的实际类型如何，它都支持一个iterator()的方法，该方法返回一个迭代子，使用该迭代子即可逐一访问Collection中每一个元素</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Iterator it = collection.iterator(); <span class="comment">// 获得一个迭代子</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    Object obj = it.next(); <span class="comment">// 得到下一个元素</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure><h3 id="框架"><a class="markdownIt-Anchor" href="java1.8/集合_容器#框架"></a> 框架<a href="java1.8/集合_容器#框架"></a></h3><p><img src="/Users/ng/Documents/java1.8/pictures/Collection%E6%8E%A5%E5%8F%A3%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.png" alt="Collection接口继承关系" class="article-img"></p><ul><li>Set(集)：元素是无序的且不可重复</li><li>List(列表)：元素是有序的且可重复</li><li>Queue(队列)：封装了数据结构中的队列</li></ul><h3 id="set"><a class="markdownIt-Anchor" href="java1.8/集合_容器#set"></a> Set<a href="java1.8/集合_容器#set"></a></h3><ul><li>Set利用Map实现，<strong>无序</strong>(存入和取出顺序有可能不一致)，<strong>允许重复元素</strong>（Map中的Key值唯一，可为null，最多有一个null元素）<ul><li>元素无放入顺序，但是元素在set中的位置是有该元素的HashCode决定的，其位置其实是固定的</li><li>加入Set的元素必须定义equals()方法以确保对象的唯一性</li></ul></li><li>具有与Collection完全一样的接口，因此没有任何额外的功能,只是行为不同</li></ul><h4 id="hashset"><a class="markdownIt-Anchor" href="java1.8/集合_容器#hashset"></a> HashSet<a href="java1.8/集合_容器#hashset"></a></h4><ul><li>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的</li><li>放入的对象必须重写equals和hashCode方法<ul><li>当元素的 hashCode 值相同时，才继续判断元素的 equals 是否为 true</li><li>如果 hashCode 值不同，那么不判断 equals，从而提高对象比较的速度</li></ul></li><li>不是同步的</li><li>存储取出都比较快</li></ul><h4 id="treeset"><a class="markdownIt-Anchor" href="java1.8/集合_容器#treeset"></a> TreeSet<a href="java1.8/集合_容器#treeset"></a></h4><ul><li>基于红黑树/TreeMap实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)</li><li>不能写入空数据</li><li>排序方式<ul><li><strong>自然排序：让元素自身具备比较性，需要元素对象实现Comparable接口，覆盖compareTo方法</strong><ul><li>在默认的compareTo方法中，需要将的两个的类型的对象的转换同一个类型，因此需要将的保证的加入到TreeSet中的数据类型是同一个类型，但是如果自己覆盖compareTo方法时，没有要求两个对象强制转换成同一个对象，是可以成功的添加treeSet中</li></ul></li><li><strong>定制排序：让集合自身具备比较性，需要定义一个实现了Comparator接口的比较器，并覆盖compare方法，并将该类对象作为实际参数传递给TreeSet集合的构造函数</strong></li></ul></li><li>额外增加的方法</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">first()<span class="comment">//返回第一个元素</span></span><br><span class="line">last()<span class="comment">//返回最后一个元素</span></span><br><span class="line">lower(Object o)<span class="comment">//返回指定元素之前的元素</span></span><br><span class="line">higher(Obect o)<span class="comment">//返回指定元素之后的元素</span></span><br><span class="line">subSet(fromElement, toElement)<span class="comment">//返回子集合</span></span><br></pre></td></tr></table></div></figure><h4 id="linkedhashset"><a class="markdownIt-Anchor" href="java1.8/集合_容器#linkedhashset"></a> LinkedHashSet<a href="java1.8/集合_容器#linkedhashset"></a></h4><ul><li><p>底层数据结构为LinkedHashMap</p></li><li><p>具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序</p><ul><li>LinkedHashSet在迭代访问Set中的全部元素时，性能比HashSet好，但是插入时性能稍微逊色于HashSet</li></ul></li><li><p>没有重写HashSet的方法</p></li></ul><h3 id="list"><a class="markdownIt-Anchor" href="java1.8/集合_容器#list"></a> List<a href="java1.8/集合_容器#list"></a></h3><ul><li>有序(元素存入集合的顺序和取出的顺序一致)</li><li>元素/特有方法都有索引</li><li>元素可以重复</li><li>除了Collection接口必备的iterator()方法外，List还提供一个listIterator()方法<ul><li>返回一个 ListIterator接口</li><li>和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历</li></ul></li></ul><h4 id="arraylist"><a class="markdownIt-Anchor" href="java1.8/集合_容器#arraylist"></a> ArrayList<a href="java1.8/集合_容器#arraylist"></a></h4><ul><li>基于动态数组实现，支持随机访问<ul><li>RandomAccess 接口标识着该类支持快速随机访问</li></ul></li><li>数组默认大小为10</li></ul><h5 id="扩容"><a class="markdownIt-Anchor" href="java1.8/集合_容器#扩容"></a> 扩容<a href="java1.8/集合_容器#扩容"></a></h5><ul><li>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容<ul><li>新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍</li></ul></li><li>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="删除"><a class="markdownIt-Anchor" href="java1.8/集合_容器#删除"></a> 删除<a href="java1.8/集合_容器#删除"></a></h5><ul><li>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="序列化"><a class="markdownIt-Anchor" href="java1.8/集合_容器#序列化"></a> 序列化<a href="java1.8/集合_容器#序列化"></a></h5><ul><li>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化</li><li>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</li><li>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容</li><li>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">oos.writeObject(list);</span><br></pre></td></tr></table></div></figure><h5 id="fail-fast机制"><a class="markdownIt-Anchor" href="java1.8/集合_容器#fail-fast机制"></a> Fail-Fast机制<a href="java1.8/集合_容器#fail-fast机制"></a></h5><ul><li>参数modCount用来记录 ArrayList 结构发生变化的次数<ul><li>结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</li></ul></li><li>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException</li><li>在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险</li></ul><h4 id="vector"><a class="markdownIt-Anchor" href="java1.8/集合_容器#vector"></a> Vector<a href="java1.8/集合_容器#vector"></a></h4><ul><li>和 ArrayList 类似，但它是线程安全的<ul><li>使用synchronized进行同步</li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    elementData[elementCount++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="扩容-2"><a class="markdownIt-Anchor" href="java1.8/集合_容器#扩容-2"></a> 扩容<a href="java1.8/集合_容器#扩容-2"></a></h5><ul><li>Vector 的构造函数可以传入 capacityIncrement 参数，它的作用是在扩容时使容量 capacity 增长 capacityIncrement</li><li>如果这个参数的值小于等于 0，扩容时每次都令 capacity 为原来的两倍<ul><li>调用没有 capacityIncrement 的构造函数时，capacityIncrement 值被设置为 0，也就是说默认情况下 Vector 每次扩容时容量都会翻倍</li></ul></li></ul><h5 id="替代方案"><a class="markdownIt-Anchor" href="java1.8/集合_容器#替代方案"></a> 替代方案<a href="java1.8/集合_容器#替代方案"></a></h5><ul><li>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;String&gt; synList = Collections.synchronizedList(list);</span><br></pre></td></tr></table></div></figure><h5 id="copyonwritearraylist"><a class="markdownIt-Anchor" href="java1.8/集合_容器#copyonwritearraylist"></a> CopyOnWriteArrayList<a href="java1.8/集合_容器#copyonwritearraylist"></a></h5><ul><li><p>在concurrent 并发包下</p></li><li><p><strong>读写分离</strong></p><ul><li>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响</li><li>写操作需要加锁，防止并发写入时导致写入数据丢失</li><li>写操作结束之后需要把原始数组指向新的复制数组</li></ul></li><li><p>适用场景</p><ul><li>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景</li></ul></li><li><p>缺点</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中</li></ul></li><li><p>CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景</p></li></ul><h4 id="linkedlist"><a class="markdownIt-Anchor" href="java1.8/集合_容器#linkedlist"></a> LinkedList<a href="java1.8/集合_容器#linkedlist"></a></h4><p><img src="/Users/ng/Documents/java1.8/pictures/LinkedList.png" alt="LinkedList" class="article-img"></p><ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列</li><li>使用 Node 存储链表节点信息<ul><li>每个链表存储了 first 和 last 指针</li></ul></li><li>线程不安全<ul><li>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 LinkedList</li></ul></li><li>可被用作堆栈（stack），队列（queue）或双向队列（deque）</li><li>允许null元素</li><li>使用foreach或迭代器来进行遍历操作</li></ul><h3 id="queue"><a class="markdownIt-Anchor" href="java1.8/集合_容器#queue"></a> Queue<a href="java1.8/集合_容器#queue"></a></h3><ul><li>Queue用于模拟队列这种数据结构，实现“FIFO”等数据结构</li><li>通常，队列不允许随机访问队列中的元素</li><li>Queue 接口并未定义阻塞队列的方法<ul><li>BlockingQueue 接口定义了那些等待元素出现或等待队列中有可用空间的方法，这些方法扩展了此接口</li></ul></li><li>Queue 实现通常不允许插入 null 元素，尽管某些实现（如 LinkedList）并不禁止插入 null<ul><li>即使在允许 null 的实现中，也不应该将 null 插入到 Queue 中，因为 null 也用作 poll 方法的一个特殊返回值，表明队列不包含元素</li></ul></li><li>相对于LinkedList，Queue添加了element、offer、peek、poll、remove方法</li><li>offer：在允许的情况下，将一个元素插入到队尾，或者返回false<ul><li>自动包装机制，会自动的把random.nextInt转化程Integer，把char转化成Character</li></ul></li><li>peek，element：在不移除的情况下返回队头，peek在队列为空返回null，element抛异常NoSuchElementException</li><li>poll,remove：移除并返回队头，poll当队列为空是返回null，remove抛出NoSuchElementException异常</li></ul><h4 id="deque"><a class="markdownIt-Anchor" href="java1.8/集合_容器#deque"></a> Deque<a href="java1.8/集合_容器#deque"></a></h4><ul><li>Deque是Queue的子接口,我们知道Queue是一种队列形式,而Deque则是双向队列,它支持从两个端点方向检索和插入元素,因此Deque既可以支持LIFO形式也可以支持LIFO形式</li></ul><h5 id="添加功能"><a class="markdownIt-Anchor" href="java1.8/集合_容器#添加功能"></a> 添加功能<a href="java1.8/集合_容器#添加功能"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(E)</span> <span class="comment">//向队列头部插入一个元素,失败时抛出异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E)</span> <span class="comment">//向队列头部插入一个元素,失败时抛出异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E)</span> <span class="comment">//向队列尾部插入一个元素,失败时抛出异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E)</span> <span class="comment">//向队列头部加入一个元素,失败时返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E)</span> <span class="comment">//向队列尾部加入一个元素,失败时返回false</span></span></span><br></pre></td></tr></table></div></figure><h5 id="获取功能"><a class="markdownIt-Anchor" href="java1.8/集合_容器#获取功能"></a> 获取功能<a href="java1.8/集合_容器#获取功能"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">()</span> <span class="comment">//获取队列头部元素,队列为空时抛出异常</span></span></span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">()</span> <span class="comment">//获取队列尾部元素,队列为空时抛出异常</span></span></span><br><span class="line"><span class="function">E <span class="title">peekFirst</span><span class="params">()</span> <span class="comment">//获取队列头部元素,队列为空时返回null</span></span></span><br><span class="line"><span class="function">E <span class="title">peekLast</span><span class="params">()</span> <span class="comment">//获取队列尾部元素,队列为空时返回null</span></span></span><br></pre></td></tr></table></div></figure><h5 id="删除功能"><a class="markdownIt-Anchor" href="java1.8/集合_容器#删除功能"></a> 删除功能<a href="java1.8/集合_容器#删除功能"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeFirstOccurrence</span><span class="params">(Object)</span> <span class="comment">//删除第一次出现的指定元素,不存在时返回false</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">removeLastOccurrence</span><span class="params">(Object)</span> <span class="comment">//删除最后一次出现的指定元素,不存在时返回false</span></span></span><br></pre></td></tr></table></div></figure><h5 id="弹出功能"><a class="markdownIt-Anchor" href="java1.8/集合_容器#弹出功能"></a> 弹出功能<a href="java1.8/集合_容器#弹出功能"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">pop</span><span class="params">()</span> <span class="comment">//弹出队列头部元素,队列为空时抛出异常</span></span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">()</span> <span class="comment">//弹出队列头部元素,队列为空时抛出异常</span></span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">()</span> <span class="comment">//弹出队列尾部元素,队列为空时抛出异常</span></span></span><br><span class="line"><span class="function">E <span class="title">pollFirst</span><span class="params">()</span> <span class="comment">//弹出队列头部元素,队列为空时返回null</span></span></span><br><span class="line"><span class="function">E <span class="title">pollLast</span><span class="params">()</span> <span class="comment">//弹出队列尾部元素,队列为空时返回null</span></span></span><br></pre></td></tr></table></div></figure><h5 id="迭代器"><a class="markdownIt-Anchor" href="java1.8/集合_容器#迭代器"></a> 迭代器<a href="java1.8/集合_容器#迭代器"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Iterator&lt;E&gt; <span class="title">descendingIterator</span><span class="params">()</span> <span class="comment">//返回队列反向迭代器</span></span></span><br></pre></td></tr></table></div></figure><h5 id="arraydeque"><a class="markdownIt-Anchor" href="java1.8/集合_容器#arraydeque"></a> ArrayDeque<a href="java1.8/集合_容器#arraydeque"></a></h5><ul><li>从效率来看,ArrayDeque要比LinkedList在两端增删元素上更为高效,因为没有在节点创建删除上的开销</li><li>总体ArrayDeque要比LinkedList更优越,在大队列的测试上有3倍与LinkedList的性能,最好的是给ArrayDeque一个较大的初始化大小,以避免底层数组扩容时数据拷贝的开销</li></ul><h5 id="linkedblockingdeque"><a class="markdownIt-Anchor" href="java1.8/集合_容器#linkedblockingdeque"></a> LinkedBlockingDeque<a href="java1.8/集合_容器#linkedblockingdeque"></a></h5><ul><li>LinkedBlockingDeque是Deque的并发实现,在队列为空的时候,它的takeFirst,takeLast会阻塞等待队列处于可用状态</li></ul><h2 id="map"><a class="markdownIt-Anchor" href="java1.8/集合_容器#map"></a> Map<a href="java1.8/集合_容器#map"></a></h2><ul><li>存储健值对，根据键得到值，因此不允许键重复，但允许值重复</li><li>底层是一个哈希表（数组+单向链表）：查询快，增删快, 是一个无序集合</li></ul><h3 id="常用方法-2"><a class="markdownIt-Anchor" href="java1.8/集合_容器#常用方法-2"></a> 常用方法<a href="java1.8/集合_容器#常用方法-2"></a></h3><ul><li>get(key)<ul><li>根据key值返回对应的value值，key值不存在则返回null</li></ul></li><li>put(key , value)<ul><li>往集合中添加元素（key和value）</li><li>添加的时候，如果key不存在，返回值null</li><li>如果Key已经存在的话，就会新值替换旧值，返回旧值</li></ul></li><li>remove(key)<ul><li>删除key值对应的键值对</li><li>如果key不存在，删除失败，返回值为null</li><li>如果key存在则删除成功，返回值为删除的value</li></ul></li><li>可以通过containsKey()和containsValue()来判断集合是否包含某个键或某个值</li></ul><h3 id="hashmap"><a class="markdownIt-Anchor" href="java1.8/集合_容器#hashmap"></a> HashMap<a href="java1.8/集合_容器#hashmap"></a></h3><ul><li>非线程安全，高效，支持null<ul><li>最多只允许一条记录的键为Null；允许多条记录的值为 Null</li><li>可以用 Collections的synchronizedMap() 方法使HashMap具有同步的能力</li></ul></li><li>HashMap里面存入的值在取出的时候是随机的，它根据键的HashCode来存储数据，根据键可以直接获取它的值，具有很快的访问速度。在Map中插入、删除和定位元素，HashMap 是最好的选择</li><li>采用拉链法解决冲突</li><li>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。原本Map.Entry接口的实现类Entry改名为了Node。转化为红黑树时改用另一种实现TreeNode</li></ul><h4 id="拉链法工作原理"><a class="markdownIt-Anchor" href="java1.8/集合_容器#拉链法工作原理"></a> 拉链法工作原理<a href="java1.8/集合_容器#拉链法工作原理"></a></h4><p><img src="/Users/ng/Documents/java1.8/pictures/HashMap%E6%8B%89%E9%93%BE%E6%B3%95.png" alt="HashMap拉链法" class="article-img"></p><ul><li>链表的插入是以头插法方式进行的</li></ul><h4 id="put操作"><a class="markdownIt-Anchor" href="java1.8/集合_容器#put操作"></a> put操作<a href="java1.8/集合_容器#put操作"></a></h4><ul><li>允许插入键为 null 的键值对，但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放<ul><li>HashMap 使用第 0 个桶存放键为 null 的键值对</li></ul></li><li>头插法</li></ul><h4 id="确定桶下标"><a class="markdownIt-Anchor" href="java1.8/集合_容器#确定桶下标"></a> 确定桶下标<a href="java1.8/集合_容器#确定桶下标"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hash = hash(key);</span><br><span class="line"><span class="keyword">int</span> i = indexFor(hash, table.length);</span><br></pre></td></tr></table></div></figure><ul><li>位运算的代价比求模运算小的多，因此在进行取模计算时用位运算的话能带来更高的性能</li><li>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算</li></ul><h4 id="扩容-3"><a class="markdownIt-Anchor" href="java1.8/集合_容器#扩容-3"></a> 扩容<a href="java1.8/集合_容器#扩容-3"></a></h4><ul><li><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此查找的复杂度为 O(N/M)</p></li><li><p>为了让查找的成本降低，应该使 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证</p></li><li><p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor</p></li></ul><div class="article-bounded"><div class="article-table"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>capacity</td><td>table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td></tr><tr><td>size</td><td>键值对数量。</td></tr><tr><td>threshold</td><td>size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td></tr><tr><td>loadFactor</td><td>装载因子，table 能够使用的比例，threshold = (int)(capacity* loadFactor)。</td></tr></tbody></table></div></div><ul><li>当需要扩容时，令 capacity 为原来的两倍</li><li>扩容使用 resize() 实现<ul><li>扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的</li></ul></li></ul><h5 id="扩容后重新计算桶下标"><a class="markdownIt-Anchor" href="java1.8/集合_容器#扩容后重新计算桶下标"></a> 扩容后重新计算桶下标<a href="java1.8/集合_容器#扩容后重新计算桶下标"></a></h5><ul><li>HashMap capacity 为 2 的 n 次方这一特点能够极大降低重新计算桶下标操作的复杂度</li></ul><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">capacity     : 00010000</span><br><span class="line">new capacity : 00100000</span><br></pre></td></tr></table></div></figure><p>对于一个 Key，它的哈希值 hash 在第 5 位：</p><ul><li>为 0，那么 hash%00010000 = hash%00100000，桶位置和原来一致</li><li>为 1，hash%00010000 = hash%00100000 + 16，桶位置是原位置 + 16</li></ul><h4 id="与hashtable的比较"><a class="markdownIt-Anchor" href="java1.8/集合_容器#与hashtable的比较"></a> 与HashTable的比较<a href="java1.8/集合_容器#与hashtable的比较"></a></h4><ul><li>Hashtable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ul><h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="java1.8/集合_容器#concurrenthashmap"></a> ConcurrentHashMap<a href="java1.8/集合_容器#concurrenthashmap"></a></h3><p><img src="/Users/ng/Documents/java1.8/pictures/HashMap%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="HashMap存储结构" class="article-img"></p><ul><li>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）<ul><li>Segment 继承自 ReentrantLock</li><li>默认的并发级别为 16，也就是说默认创建 16 个 Segment</li></ul></li></ul><h4 id="size操作"><a class="markdownIt-Anchor" href="java1.8/集合_容器#size操作"></a> size操作<a href="java1.8/集合_容器#size操作"></a></h4><ul><li>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数</li><li>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来</li><li>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的<ul><li>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3</li><li>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁</li></ul></li><li>JDK1.8使用了CAS操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized<ul><li>在链表过长时会转换为红黑树</li></ul></li></ul><h3 id="linkedhashmap"><a class="markdownIt-Anchor" href="java1.8/集合_容器#linkedhashmap"></a> LinkedHashMap<a href="java1.8/集合_容器#linkedhashmap"></a></h3><ul><li>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性</li><li>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序<ul><li>head和tail</li></ul></li><li>accessOrder 参数决定了顺序，默认为 false，此时维护的是插入顺序</li><li>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></div></figure><h4 id="afternodeaccess"><a class="markdownIt-Anchor" href="java1.8/集合_容器#afternodeaccess"></a> afterNodeAccess()<a href="java1.8/集合_容器#afternodeaccess"></a></h4><ul><li>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部</li><li>也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点</li></ul><h4 id="afternodeinsertion"><a class="markdownIt-Anchor" href="java1.8/集合_容器#afternodeinsertion"></a> afterNodeInsertion()<a href="java1.8/集合_容器#afternodeinsertion"></a></h4><ul><li>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first</li><li>evict 只有在构建 Map 的时候才为 false，在这里为 true</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</span><br><span class="line">        K key = first.key;</span><br><span class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p><h4 id="实现lru缓存"><a class="markdownIt-Anchor" href="java1.8/集合_容器#实现lru缓存"></a> 实现LRU缓存<a href="java1.8/集合_容器#实现lru缓存"></a></h4><ul><li>设定最大缓存空间 MAX_ENTRIES 为 3</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LRUCache() &#123;</span><br><span class="line">        <span class="keyword">super</span>(MAX_ENTRIES, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LRUCache&lt;Integer, String&gt; cache = <span class="keyword">new</span> LRUCache&lt;&gt;();</span><br><span class="line">    cache.put(<span class="number">1</span>, <span class="string">"a"</span>);</span><br><span class="line">    cache.put(<span class="number">2</span>, <span class="string">"b"</span>);</span><br><span class="line">    cache.put(<span class="number">3</span>, <span class="string">"c"</span>);</span><br><span class="line">    cache.get(<span class="number">1</span>);</span><br><span class="line">    cache.put(<span class="number">4</span>, <span class="string">"d"</span>);</span><br><span class="line">    System.out.println(cache.keySet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果为 [3,1,4]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></div></figure><h3 id="weakhashmap"><a class="markdownIt-Anchor" href="java1.8/集合_容器#weakhashmap"></a> WeakHashMap<a href="java1.8/集合_容器#weakhashmap"></a></h3><ul><li>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收</li><li>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</li></ul><h4 id="concurrentcache"><a class="markdownIt-Anchor" href="java1.8/集合_容器#concurrentcache"></a> ConcurrentCache<a href="java1.8/集合_容器#concurrentcache"></a></h4><ul><li>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</li><li>ConcurrentCache 采取的是分代缓存</li></ul><h5 id="分代缓存"><a class="markdownIt-Anchor" href="java1.8/集合_容器#分代缓存"></a> 分代缓存<a href="java1.8/集合_容器#分代缓存"></a></h5><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li><li>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;容器&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;java1.8/集合_容器#容器&quot;&gt;&lt;/a&gt; 容器&lt;a href=&quot;java1.8/集合_容器#容器&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;作用&quot;&gt;&lt;a class=&quot;markdownI
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java1.8/函数式编程</title>
    <link href="ilucia.github.io/java1.8/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>ilucia.github.io/java1.8/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</id>
    <published>2022-04-27T15:24:01.723Z</published>
    <updated>2022-04-27T15:24:01.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="java1.8/函数式编程#概述"></a> 概述<a href="java1.8/函数式编程#概述"></a></h2><h3 id="函数式编程简介"><a class="markdownIt-Anchor" href="java1.8/函数式编程#函数式编程简介"></a> 函数式编程简介<a href="java1.8/函数式编程#函数式编程简介"></a></h3><p>我们最常用的面向对象编程（Java）属于<strong>命令式编程</strong>（Imperative Programming）这种编程范式。常见的编程范式还有<strong>逻辑式编程</strong>（Logic Programming），<strong>函数式编程</strong>（Functional Programming）</p><p>函数式编程把计算过程当做是数学函数的求值，而避免更改状态和可变数据</p><p>什么是函数式编程？简单的回答：一切都是数学函数。函数式编程语言里也可以有对象，但通常这些对象都是恒定不变的 —— 要么是函数参数，要什么是函数返回值。函数式编程语言里没有 for/next 循环，因为这些逻辑意味着有状态的改变。相替代的是，这种循环逻辑在函数式编程语言里是通过递归、把函数当成参数传递的方式实现的</p><h3 id="lambda-表达式简介"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda-表达式简介"></a> Lambda 表达式简介<a href="java1.8/函数式编程#lambda-表达式简介"></a></h3><p>Java 8的最大变化是引入了Lambda（Lambda 是希腊字母 λ 的英文名称）表达式——一种紧凑的、传递行为的方式。</p><p>先看个例子：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"button clicked"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure><p>这段代码使用了匿名类。<code>ActionListener</code> 是一个接口，这里 new 了一个类实现了 <code>ActionListener</code> 接口，然后重写了 <code>actionPerformed</code> 方法。<code>actionPerformed</code> 方法接收 <code>ActionEvent</code> 类型参数，返回空。</p><p>这段代码我们其实只关心中间打印的语句，其他都是多余的。所以使用 Lambda 表达式，我们就可以简写为：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">button.addActionListener(event -&gt; System.out.println(<span class="string">"button clicked"</span>));</span><br></pre></td></tr></table></div></figure><h2 id="lambda-表达式"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda-表达式"></a> Lambda 表达式<a href="java1.8/函数式编程#lambda-表达式"></a></h2><h3 id="lambda-表达式的形式"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda-表达式的形式"></a> Lambda 表达式的形式<a href="java1.8/函数式编程#lambda-表达式的形式"></a></h3><p>Java 中 Lambda 表达式一共有五种基本形式，具体如下：</p><h5 id="1"><a class="markdownIt-Anchor" href="java1.8/函数式编程#1"></a> 1<a href="java1.8/函数式编程#1"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable noArguments = () -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br></pre></td></tr></table></div></figure><ul><li>不包含参数,使用空括号 () 表示没有参数</li><li>该 Lambda 表达式 实现了 Runnable 接口,该接口也只有一个 run 方法,没有参数,且返回类型为 void</li></ul><h5 id="2"><a class="markdownIt-Anchor" href="java1.8/函数式编程#2"></a> 2<a href="java1.8/函数式编程#2"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ActionListener oneArgument = event -&gt; System.out.println(<span class="string">"button clicked"</span>);</span><br></pre></td></tr></table></div></figure><ul><li>包含且只包含一个参数,可省略参数的括号</li></ul><h5 id="3"><a class="markdownIt-Anchor" href="java1.8/函数式编程#3"></a> 3<a href="java1.8/函数式编程#3"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Runnable multiStatement = () -&gt; &#123;</span><br><span class="line">System.out.print(<span class="string">"Hello"</span>);</span><br><span class="line">System.out.println(<span class="string">" World"</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><ul><li>Lambda 表达式的主体不仅可以是一个表达式,而且也可以是一段代码块,使用大括号 ({})将代码块括起来</li><li>该代码块和普通方法遵循的规则别无二致,可以用返 回或抛出异常来退出。只有一行代码的 Lambda 表达式也可使用大括号,用以明确 Lambda表达式从何处开始、到哪里结束</li></ul><h5 id="4"><a class="markdownIt-Anchor" href="java1.8/函数式编程#4"></a> 4<a href="java1.8/函数式编程#4"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; add = (x, y) -&gt; x + y;</span><br></pre></td></tr></table></div></figure><ul><li>表示包含多个参数的方法</li><li>代码阅读方法<ul><li>这行代码并不是将两个数字相加,而是创建了一个函数,用来计算 两个数字相加的结果</li><li>变量 add 的类型是 BinaryOperator,它不是两个数字的和, 而是将两个数字相加的那行代码</li></ul></li></ul><h5 id="5"><a class="markdownIt-Anchor" href="java1.8/函数式编程#5"></a> 5<a href="java1.8/函数式编程#5"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BinaryOperator&lt;Long&gt; addExplicit = (Long x, Long y) -&gt; x + y;</span><br></pre></td></tr></table></div></figure><ul><li><p>到目前为止,所有 Lambda 表达式中的参数类型都是由编译器推断得出的</p></li><li><p>可以显式声明参数类型,此时就需要使用小括号将参数括起来,多个参数的情况也是如此</p></li><li><p>Lambda 表达式都可以扩写为原始的“匿名类”形式</p><ul><li>Lambda 表达式很复杂不容易理解的时候，不妨把它扩写为“匿名类”形式来看</li></ul></li></ul><h3 id="闭包"><a class="markdownIt-Anchor" href="java1.8/函数式编程#闭包"></a> 闭包<a href="java1.8/函数式编程#闭包"></a></h3><ul><li>匿名内部类所在方法里的变量，必须声明为 <code>final</code></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String name = getUserName();</span><br><span class="line">button.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent event)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"hi "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure><ul><li>Java 8放松了这一限制，可以不必再把变量声明为 <code>final</code>，但其实该变量实际上仍然是 <code>final</code> 的</li><li>虽然无需将变量声明为 final，但在 Lambda 表达式中，也无法用作非终态变量<ul><li>如果坚持用作非终态变量（即改变变量的值），编译器就会报错</li></ul></li></ul><h3 id="函数接口"><a class="markdownIt-Anchor" href="java1.8/函数式编程#函数接口"></a> 函数接口<a href="java1.8/函数式编程#函数接口"></a></h3><p>上面例子里提到了 <code>ActionListener</code> 接口，我们看一下它的代码：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ActionListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invoked when an action occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li><code>ActionListener</code> 只有一个抽象方法：<code>actionPerformed</code>，被用来表示行为:接受一个参数，返回空</li><li>由于 <code>actionPerformed</code> 定义在一个接口里，因此 <code>abstract</code> 关键字不是必需的</li><li>该接口也继承自一个不具有任何方法的父接口：<code>EventListener</code><ul><li>我们把这种接口就叫做函数接口</li></ul></li></ul><h4 id="jdk-8-常用核心函数接口"><a class="markdownIt-Anchor" href="java1.8/函数式编程#jdk-8-常用核心函数接口"></a> JDK 8 常用核心函数接口<a href="java1.8/函数式编程#jdk-8-常用核心函数接口"></a></h4><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">接口</th><th style="text-align:left">参数</th><th style="text-align:left">返回类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">Predicate<t></t></td><td style="text-align:left">T</td><td style="text-align:left">boolean</td><td style="text-align:left">用于判别一个对象。比如求一个人是否为男性</td></tr><tr><td style="text-align:left">Consumer<t></t></td><td style="text-align:left">T</td><td style="text-align:left">void</td><td style="text-align:left">用于接收一个对象进行处理但没有返回，比如接收一个人并打印他的名字</td></tr><tr><td style="text-align:left">Function&lt;T, R&gt;</td><td style="text-align:left">T</td><td style="text-align:left">R</td><td style="text-align:left">转换一个对象为不同类型的对象</td></tr><tr><td style="text-align:left">Supplier<t></t></td><td style="text-align:left">None</td><td style="text-align:left">T</td><td style="text-align:left">提供一个对象</td></tr><tr><td style="text-align:left">UnaryOperator<t></t></td><td style="text-align:left">T</td><td style="text-align:left">T</td><td style="text-align:left">接收对象并返回同类型的对象</td></tr><tr><td style="text-align:left">BinaryOperator<t></t></td><td style="text-align:left">(T, T)</td><td style="text-align:left">T</td><td style="text-align:left">接收两个同类型的对象，并返回一个原类型对象</td></tr></tbody></table></div></div><ul><li><code>Cosumer</code> 与 <code>Supplier</code> 对应，一个是消费者，一个是提供者</li><li><code>Predicate</code> 用于判断对象是否符合某个条件，经常被用来过滤对象</li><li><code>Function</code> 是将一个对象转换为另一个对象，比如说要装箱或者拆箱某个对象</li><li><code>UnaryOperator</code> 接收和返回同类型对象，一般用于对对象修改属性。<code>BinaryOperator</code> 则可以理解为合并对象</li></ul><h2 id="集合处理"><a class="markdownIt-Anchor" href="java1.8/函数式编程#集合处理"></a> 集合处理<a href="java1.8/函数式编程#集合处理"></a></h2><h3 id="lambda表达式"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda表达式"></a> lambda表达式<a href="java1.8/函数式编程#lambda表达式"></a></h3><h4 id="例-线程"><a class="markdownIt-Anchor" href="java1.8/函数式编程#例-线程"></a> 例 线程<a href="java1.8/函数式编程#例-线程"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Java7</span></span><br><span class="line">  <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java8</span></span><br><span class="line">  <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="使用场景"><a class="markdownIt-Anchor" href="java1.8/函数式编程#使用场景"></a> 使用场景<a href="java1.8/函数式编程#使用场景"></a></h4><h5 id="简化匿名类的编码"><a class="markdownIt-Anchor" href="java1.8/函数式编程#简化匿名类的编码"></a> 简化匿名类的编码<a href="java1.8/函数式编程#简化匿名类的编码"></a></h5><h5 id="减少不必要的方法创建"><a class="markdownIt-Anchor" href="java1.8/函数式编程#减少不必要的方法创建"></a> 减少不必要的方法创建<a href="java1.8/函数式编程#减少不必要的方法创建"></a></h5><ul><li>某个方法只会在某处使用且内部逻辑也很简单，在Java8之前我们通常都会创建一个方法，但是事实上我们经常会发现这样写着写着，一个类中的方法可能会变得非常庞杂，严重影响阅读体验，进而影响编码效率。但是如果使用lambda表达式，那么这个问题就可以很容易就解决</li><li>例：多次打印时间</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionMain</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TimeDemo timeDemo = <span class="keyword">new</span> TimeDemo();</span><br><span class="line">        timeDemo.createTime = System.currentTimeMillis();</span><br><span class="line">        timeDemo.updateTime = System.currentTimeMillis() + <span class="number">10000</span>;</span><br><span class="line">        outputTimeDemo(timeDemo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outputTimeDemo</span><span class="params">(TimeDemo timeDemo)</span> </span>&#123;</span><br><span class="line">        Function timestampToDate = timestamp -&gt; &#123;</span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">            <span class="keyword">return</span> df.format(<span class="keyword">new</span> Date(timestamp));</span><br><span class="line">        &#125;;</span><br><span class="line">     System.out.println(timestampToDate.apply(timeDemo.createTime));       System.out.println(timestampToDate.apply(timeDemo.updateTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">apply</span><span class="params">(<span class="keyword">long</span> timestamp)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">long</span> updateTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>在这段代码的outputTimeDemo中我们可以看到，对于时间戳转换的内容，我们并没有额外创建一个方法，而是类似于创建了一个变量来表达</li><li>不过，这个时候出现了另一个问题，虽然我们少创建了一个方法，但是我们却多创建了一个接口Function，总有种因小失大的感觉，不过这个问题，我们在后面的java.util.function包部分可以找到答案</li></ul><h5 id="事件处理回调"><a class="markdownIt-Anchor" href="java1.8/函数式编程#事件处理回调"></a> 事件处理(回调)<a href="java1.8/函数式编程#事件处理回调"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    execute(<span class="string">"hello world"</span>, () -&gt; System.out.println(<span class="string">"callback"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(String s, Callback callback)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    callback.callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>Callback多了一个注解@FunctionalInterface，这个注解主要用于编译期检查，如果我们的接口不符合函数式接口的要求，那编译的时候就会报错</li></ul><h4 id="javautilfunction包"><a class="markdownIt-Anchor" href="java1.8/函数式编程#javautilfunction包"></a> java.util.function包<a href="java1.8/函数式编程#javautilfunction包"></a></h4><ul><li>在之前的例子中，我们发现使用lambda表达式的时候，经常需要定义一些接口用来辅助我们的编码，这样就会使得本应轻量级的lambda表达式又变得重量级</li><li>其实Java8本身已经为我们提供了一些常见的函数式接口，就在java.util.function包下面</li></ul><div class="article-bounded"><div class="article-table"><table><thead><tr><th>接口</th><th>描述</th></tr></thead><tbody><tr><td>Function&lt;T,R&gt;</td><td>接受一个输入参数，返回一个结果</td></tr><tr><td>Supplier</td><td>无参数，返回一个结果</td></tr><tr><td>Consumer</td><td>接受一个输入参数，并且不返回任何结果</td></tr><tr><td>BiFunction&lt;T,U,R&gt;</td><td>接受两个输入参数的方法，并且返回一个结果</td></tr><tr><td>BiConsumer&lt;T,U&gt;</td><td>接受两个输入参数的操作，并且不返回任何结果</td></tr></tbody></table></div></div><ul><li>此处列出最基本的几个，其他的都是在这些的基础上做了一些简单的封装，例如IntFunction就是对Function&lt;T,R&gt;的封装<ul><li>如果有更复杂的情况，那就得自己定义接口了</li></ul></li><li>在java.util.function下没有无参数无返回结果的接口<ul><li>自己定义一个接口或者直接使用Runnable接口</li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">    System.out.println(f.apply(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;Integer, Integer, Integer&gt; g = (x, y) -&gt; x + y;</span><br><span class="line">    System.out.println(g.apply(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="lambda表达式和匿名类的区别"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda表达式和匿名类的区别"></a> lambda表达式和匿名类的区别<a href="java1.8/函数式编程#lambda表达式和匿名类的区别"></a></h3><h4 id="this指向不同"><a class="markdownIt-Anchor" href="java1.8/函数式编程#this指向不同"></a> this指向不同<a href="java1.8/函数式编程#this指向不同"></a></h4><ul><li>lambda表达式中使用this指向的是外部的类，而匿名类中使用this则指向的是匿名类本身</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String test = <span class="string">"test-main"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> FunctionMain().output();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Function f = () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"1:-----------------"</span>);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.test);</span><br><span class="line">        &#125;;</span><br><span class="line">        f.outputThis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Function() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">outputThis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"2:-----------------"</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.test);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.outputThis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line">        String test = <span class="string">"test-function"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">outputThis</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><img src="https://img-blog.csdnimg.cn/20190613150049342.png" alt="在这里插入图片描述" class="article-img"></p><ul><li>使用lambda表达式的同时去访问原类中的变量、方法的是做不到的</li></ul><h4 id="底层实现不同"><a class="markdownIt-Anchor" href="java1.8/函数式编程#底层实现不同"></a> 底层实现不同<a href="java1.8/函数式编程#底层实现不同"></a></h4><h5 id="编译"><a class="markdownIt-Anchor" href="java1.8/函数式编程#编译"></a> 编译<a href="java1.8/函数式编程#编译"></a></h5><ul><li>匿名类会生成额外的class文件，lambda不会<ul><li>ClassMain$1.class</li></ul></li></ul><h5 id="字节码"><a class="markdownIt-Anchor" href="java1.8/函数式编程#字节码"></a> 字节码<a href="java1.8/函数式编程#字节码"></a></h5><ul><li>匿名类通过new一个类来实现</li><li>lambda表达式被编译成一个lambda$main$0的静态方法，并通过invokedynamic的方式调用</li></ul><h5 id="替代条件"><a class="markdownIt-Anchor" href="java1.8/函数式编程#替代条件"></a> 替代条件<a href="java1.8/函数式编程#替代条件"></a></h5><ul><li>lambda表达式想要替代匿名类，需要匿名类实现的接口为函数式接口，即只有一个抽象方法</li></ul><h3 id="lambda的延迟执行"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda的延迟执行"></a> Lambda的延迟执行<a href="java1.8/函数式编程#lambda的延迟执行"></a></h3><p>有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好可以 作为解决方案，提升性能。</p><h4 id="性能浪费的日志案例"><a class="markdownIt-Anchor" href="java1.8/函数式编程#性能浪费的日志案例"></a> 性能浪费的日志案例<a href="java1.8/函数式编程#性能浪费的日志案例"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注：日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化。</span><br></pre></td></tr></table></div></figure><p>一种典型的场景就是对参数进行有条件使用，例如对日志消息进行拼接后，在满足条件的情况下进行打印输出：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msgA = <span class="string">"Hello "</span>;</span><br><span class="line">        String msgB = <span class="string">"World "</span>;</span><br><span class="line">        String msgC = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        log(<span class="number">1</span>, msgA + msgB + msgC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, String mgs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(mgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这段代码存在问题：无论级别 level 是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">备注：SLF4J是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行 字符串的拼接，而是将字符串的若干部分作</span><br><span class="line">为可变参数传入方法中，仅在日志级别满足要求的情况下才会进 行字符串拼接。例如: LOGGER.debug(&quot;变量&#123;&#125;的取值为&#123;&#125;。&quot;, &quot;os&quot;, &quot;macOS&quot;) ，</span><br><span class="line">其中的大括号 &#123;&#125; 为占位 符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置;否则不会进行字 符串拼接。这也是</span><br><span class="line">一种可行解决方案，但Lambda可以做到更好。</span><br></pre></td></tr></table></div></figure><h4 id="体验lambda的更优写法"><a class="markdownIt-Anchor" href="java1.8/函数式编程#体验lambda的更优写法"></a> 体验Lambda的更优写法<a href="java1.8/函数式编程#体验lambda的更优写法"></a></h4><p>使用Lambda必然需要一个函数式接口：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 信息生成器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 生成的信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">builderMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>然后对 log 方法进行改造：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msgA = <span class="string">"Hello "</span>;</span><br><span class="line">        String msgB = <span class="string">"World "</span>;</span><br><span class="line">        String msgC = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        log(<span class="number">1</span>, () -&gt; msgA + msgB + msgC);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder mb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(mb.builderMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>改造前后的对比：</p><p><a href="https://img2018.cnblogs.com/i-beta/1681961/202002/1681961-20200209012055355-450845081.png" target="_blank" rel="noopener"><img src="https://img2018.cnblogs.com/i-beta/1681961/202002/1681961-20200209012055355-450845081.png" alt="img"></a></p><p>这样一来，只有当级别满足要求的时候，才会进行三个字符串的拼接;否则三个字符串将不会进行拼接。</p><h4 id="证明lambda的延迟"><a class="markdownIt-Anchor" href="java1.8/函数式编程#证明lambda的延迟"></a> 证明Lambda的延迟<a href="java1.8/函数式编程#证明lambda的延迟"></a></h4><p>下面的代码可以通过结果进行验证：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msgA = <span class="string">"Hello "</span>;</span><br><span class="line">        String msgB = <span class="string">"World "</span>;</span><br><span class="line">        String msgC = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        log(<span class="number">2</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"Lambada 执行！"</span>);</span><br><span class="line">            <span class="keyword">return</span> msgA + msgB + msgC;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder mb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(mb.builderMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里只是在调用 log 方法的时候，将传入的Lambda稍作修改，</p><p>当传入的 level = 1 的时候，控制台输出：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lambada 执行！</span><br><span class="line">Hello World Java</span><br></pre></td></tr></table></div></figure><p>当传入的 level != 1 的时候，控制台没有输出。</p><p>从结果中可以看出，在不符合级别要求的情况下，Lambda将不会执行。从而达到节省性能的效果。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">扩展：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另外一个对象当中通过调用方法来完成。而是否调</span><br><span class="line">用其所在方法是在条件判断之后才执行的。</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04Logger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msgA = <span class="string">"Hello "</span>;</span><br><span class="line">        String msgB = <span class="string">"World "</span>;</span><br><span class="line">        String msgC = <span class="string">"Java"</span>;</span><br><span class="line"></span><br><span class="line">        log(<span class="number">1</span>, <span class="keyword">new</span> MessageBuilder() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">builderMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Lambada 执行！"</span>);</span><br><span class="line">                <span class="keyword">return</span> msgA + msgB + msgC;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder mb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(mb.builderMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="使用lambda作为参数和返回值"><a class="markdownIt-Anchor" href="java1.8/函数式编程#使用lambda作为参数和返回值"></a> 使用Lambda作为参数和返回值<a href="java1.8/函数式编程#使用lambda作为参数和返回值"></a></h3><p>如果抛开实现原理不说，Java中的Lambda表达式可以被当作是匿名内部类的替代品。如果方法的参数是一个函数式接口类型，那么就可以使用Lambda表达式进行替代。使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。</p><h4 id="lambda作为参数"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda作为参数"></a> Lambda作为参数<a href="java1.8/函数式编程#lambda作为参数"></a></h4><p>例如 java.lang.Runnable 接口就是一个函数式接口，假设有一个 startThread 方法使用该接口作为参数，那么就可以使用Lambda进行传参。这种情况其实和 Thread 类的构造方法参数为 Runnable 没有本质区别。</p><h5 id="匿名内部类作为参数创建新的线程并执行"><a class="markdownIt-Anchor" href="java1.8/函数式编程#匿名内部类作为参数创建新的线程并执行"></a> 匿名内部类作为参数，创建新的线程并执行<a href="java1.8/函数式编程#匿名内部类作为参数创建新的线程并执行"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        startThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程任务执行!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的线程，赋予任务，然后开启线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 传入Thread类的接口，实现创建新线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>运行程序，控制台输出：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程任务执行!</span><br></pre></td></tr></table></div></figure><h5 id="lambda作为参数创建新的线程并执行"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda作为参数创建新的线程并执行"></a> Lambda作为参数，创建新的线程并执行<a href="java1.8/函数式编程#lambda作为参数创建新的线程并执行"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        startThread(</span><br><span class="line">                () -&gt; System.out.println(<span class="string">"线程任务执行!"</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个新的线程，赋予任务，然后开启线程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable 传入Thread类的接口，实现创建新线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(runnable).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>运行程序，控制台输出：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">线程任务执行!</span><br></pre></td></tr></table></div></figure><h4 id="lambda作为返回值"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda作为返回值"></a> Lambda作为返回值<a href="java1.8/函数式编程#lambda作为返回值"></a></h4><p>类似地，如果一个方法的返回值类型是一个函数式接口，那么就可以直接返回一个Lambda表达式。当需要通过一个方法来获取一个 java.util.Comparator 接口类型的对象作为排序器时,就可以调该方法获取。</p><h5 id="lambda作为返回值字符串的长短比较"><a class="markdownIt-Anchor" href="java1.8/函数式编程#lambda作为返回值字符串的长短比较"></a> Lambda作为返回值，字符串的长短比较<a href="java1.8/函数式编程#lambda作为返回值字符串的长短比较"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = &#123; <span class="string">"abc"</span>, <span class="string">"ab"</span>, <span class="string">"a"</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">"使用比较器比较之前："</span> + Arrays.toString(array));</span><br><span class="line">        Arrays.sort(array, newComparator());</span><br><span class="line">        System.out.println(<span class="string">"使用比较器比较之后："</span> + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串a、b的长短比较，自己定义比较器规则，生序排序，字符串长的排在后面。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 布尔值，</span></span><br><span class="line"><span class="comment">     *         a.length() - b.length() &lt; 0 返回 false，</span></span><br><span class="line"><span class="comment">     *         a.length() - b.length() &gt; 0 返回 true，</span></span><br><span class="line"><span class="comment">     *         a.length() = b.length() 返回 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">newComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a, b) -&gt; a.length() - b.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="匿名内部类作为返回值字符串的长短比较"><a class="markdownIt-Anchor" href="java1.8/函数式编程#匿名内部类作为返回值字符串的长短比较"></a> 匿名内部类作为返回值，字符串的长短比较<a href="java1.8/函数式编程#匿名内部类作为返回值字符串的长短比较"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] array = &#123; <span class="string">"abc"</span>, <span class="string">"ab"</span>, <span class="string">"a"</span> &#125;;</span><br><span class="line">        System.out.println(<span class="string">"使用比较器比较之前："</span> + Arrays.toString(array));</span><br><span class="line">        Arrays.sort(array, newComparator());</span><br><span class="line">        System.out.println(<span class="string">"使用比较器比较之后："</span> + Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Comparator&lt;String&gt; <span class="title">newComparator1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.length() - o2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>运行程序，控制台输出一样：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用比较器比较之前：[abc, ab, a]</span><br><span class="line">使用比较器比较之后：[a, ab, abc]</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;java1.8/函数式编程#概述&quot;&gt;&lt;/a&gt; 概述&lt;a href=&quot;java1.8/函数式编程#概述&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;函数式编程简介&quot;&gt;&lt;a class=&quot;mark
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java1.8/多线程</title>
    <link href="ilucia.github.io/java1.8/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>ilucia.github.io/java1.8/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-04-27T15:24:01.723Z</published>
    <updated>2022-04-27T15:24:01.727Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用线程"><a class="markdownIt-Anchor" href="java1.8/多线程#使用线程"></a> 使用线程<a href="java1.8/多线程#使用线程"></a></h1><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h2 id="实现-runnable-接口"><a class="markdownIt-Anchor" href="java1.8/多线程#实现-runnable-接口"></a> 实现 Runnable 接口<a href="java1.8/多线程#实现-runnable-接口"></a></h2><p>需要实现接口中的 run() 方法。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="实现-callable-接口"><a class="markdownIt-Anchor" href="java1.8/多线程#实现-callable-接口"></a> 实现 Callable 接口<a href="java1.8/多线程#实现-callable-接口"></a></h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="继承-thread-类"><a class="markdownIt-Anchor" href="java1.8/多线程#继承-thread-类"></a> 继承 Thread 类<a href="java1.8/多线程#继承-thread-类"></a></h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="实现接口-vs-继承-thread"><a class="markdownIt-Anchor" href="java1.8/多线程#实现接口-vs-继承-thread"></a> 实现接口 VS 继承 Thread<a href="java1.8/多线程#实现接口-vs-继承-thread"></a></h2><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h1 id="基础线程机制"><a class="markdownIt-Anchor" href="java1.8/多线程#基础线程机制"></a> 基础线程机制<a href="java1.8/多线程#基础线程机制"></a></h1><h2 id="executor"><a class="markdownIt-Anchor" href="java1.8/多线程#executor"></a> Executor<a href="java1.8/多线程#executor"></a></h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="daemon"><a class="markdownIt-Anchor" href="java1.8/多线程#daemon"></a> Daemon<a href="java1.8/多线程#daemon"></a></h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">    thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="sleep"><a class="markdownIt-Anchor" href="java1.8/多线程#sleep"></a> sleep()<a href="java1.8/多线程#sleep"></a></h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="yield"><a class="markdownIt-Anchor" href="java1.8/多线程#yield"></a> yield()<a href="java1.8/多线程#yield"></a></h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="中断"><a class="markdownIt-Anchor" href="java1.8/多线程#中断"></a> 中断<a href="java1.8/多线程#中断"></a></h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h2 id="interruptedexception"><a class="markdownIt-Anchor" href="java1.8/多线程#interruptedexception"></a> InterruptedException<a href="java1.8/多线程#interruptedexception"></a></h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> MyThread1();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$<span class="number">0</span>(InterruptExample.java:<span class="number">5</span>)</span><br><span class="line">    at InterruptExample$$Lambda$<span class="number">1</span>/<span class="number">713338599</span>.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></div></figure><h2 id="interrupted"><a class="markdownIt-Anchor" href="java1.8/多线程#interrupted"></a> interrupted()<a href="java1.8/多线程#interrupted"></a></h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> MyThread2();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br><span class="line">Thread end</span><br></pre></td></tr></table></div></figure><h2 id="executor-的中断操作"><a class="markdownIt-Anchor" href="java1.8/多线程#executor-的中断操作"></a> Executor 的中断操作<a href="java1.8/多线程#executor-的中断操作"></a></h2><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">"Thread run"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">"Main run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$<span class="number">0</span>(ExecutorInterruptExample.java:<span class="number">9</span>)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$<span class="number">1</span>/<span class="number">1160460865</span>.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1142</span>)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">617</span>)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:<span class="number">745</span>)</span><br></pre></td></tr></table></div></figure><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="keyword">true</span>);</span><br></pre></td></tr></table></div></figure><h1 id="互斥同步"><a class="markdownIt-Anchor" href="java1.8/多线程#互斥同步"></a> 互斥同步<a href="java1.8/多线程#互斥同步"></a></h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2 id="synchronized"><a class="markdownIt-Anchor" href="java1.8/多线程#synchronized"></a> synchronized<a href="java1.8/多线程#synchronized"></a></h2><p><strong>1. 同步一个代码块</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></div></figure><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func1());</span><br><span class="line">    executorService.execute(() -&gt; e2.func1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">5</span> <span class="number">5</span> <span class="number">6</span> <span class="number">6</span> <span class="number">7</span> <span class="number">7</span> <span class="number">8</span> <span class="number">8</span> <span class="number">9</span> <span class="number">9</span></span><br></pre></td></tr></table></div></figure><p><strong>2. 同步一个方法</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>它和同步代码块一样，作用于同一个对象。</p><p><strong>3. 同步一个类</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    SynchronizedExample e1 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    SynchronizedExample e2 = <span class="keyword">new</span> SynchronizedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; e1.func2());</span><br><span class="line">    executorService.execute(() -&gt; e2.func2());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></div></figure><p><strong>4. 同步一个静态方法</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>作用于整个类。</p><h2 id="reentrantlock"><a class="markdownIt-Anchor" href="java1.8/多线程#reentrantlock"></a> ReentrantLock<a href="java1.8/多线程#reentrantlock"></a></h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">// 确保释放锁，从而避免发生死锁。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    LockExample lockExample = <span class="keyword">new</span> LockExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">    executorService.execute(() -&gt; lockExample.func());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">​```java</span><br><span class="line"></span><br><span class="line">## 比较</span><br><span class="line"></span><br><span class="line">**<span class="number">1</span>. 锁的实现**</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>. 性能**</span><br><span class="line"></span><br><span class="line">新版本 Java 对 <span class="keyword">synchronized</span> 进行了很多优化，例如自旋锁等，<span class="keyword">synchronized</span> 与 ReentrantLock 大致相同。</span><br><span class="line"></span><br><span class="line">**<span class="number">3</span>. 等待可中断**</span><br><span class="line"></span><br><span class="line">当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</span><br><span class="line"></span><br><span class="line">ReentrantLock 可中断，而 <span class="keyword">synchronized</span> 不行。</span><br><span class="line"></span><br><span class="line">**<span class="number">4</span>. 公平锁**</span><br><span class="line"></span><br><span class="line">公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</span><br><span class="line"></span><br><span class="line">**<span class="number">5</span>. 锁绑定多个条件**</span><br><span class="line"></span><br><span class="line">一个 ReentrantLock 可以同时绑定多个 Condition 对象。</span><br><span class="line"></span><br><span class="line">## 使用选择</span><br><span class="line"></span><br><span class="line">除非需要使用 ReentrantLock 的高级功能，否则优先使用 <span class="keyword">synchronized</span>。这是因为 <span class="keyword">synchronized</span> 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 <span class="keyword">synchronized</span> 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</span><br><span class="line"></span><br><span class="line"># 五、线程之间的协作</span><br><span class="line"></span><br><span class="line">当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</span><br><span class="line"></span><br><span class="line">## join()</span><br><span class="line"></span><br><span class="line">在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</span><br><span class="line"></span><br><span class="line">对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</span><br><span class="line"></span><br><span class="line">​```java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">        B(A a) &#123;</span><br><span class="line">            <span class="keyword">this</span>.a = a;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                a.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B(a);</span><br><span class="line">        b.start();</span><br><span class="line">        a.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JoinExample example = <span class="keyword">new</span> JoinExample();</span><br><span class="line">    example.test();</span><br><span class="line">&#125;</span><br><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></div></figure><h2 id="wait-notify-notifyall"><a class="markdownIt-Anchor" href="java1.8/多线程#wait-notify-notifyall"></a> wait() notify() notifyAll()<a href="java1.8/多线程#wait-notify-notifyall"></a></h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNotifyExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    WaitNotifyExample example = <span class="keyword">new</span> WaitNotifyExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></div></figure><p><strong>wait() 和 sleep() 的区别</strong></p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2 id="await-signal-signalall"><a class="markdownIt-Anchor" href="java1.8/多线程#await-signal-signalall"></a> await() signal() signalAll()<a href="java1.8/多线程#await-signal-signalall"></a></h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">    executorService.execute(() -&gt; example.after());</span><br><span class="line">    executorService.execute(() -&gt; example.before());</span><br><span class="line">&#125;</span><br><span class="line">before</span><br><span class="line">after</span><br></pre></td></tr></table></div></figure><h1 id="线程状态"><a class="markdownIt-Anchor" href="java1.8/多线程#线程状态"></a> 线程状态<a href="java1.8/多线程#线程状态"></a></h1><p>一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。</p><h2 id="新建new"><a class="markdownIt-Anchor" href="java1.8/多线程#新建new"></a> 新建（NEW）<a href="java1.8/多线程#新建new"></a></h2><p>创建后尚未启动。</p><h2 id="可运行runable"><a class="markdownIt-Anchor" href="java1.8/多线程#可运行runable"></a> 可运行（RUNABLE）<a href="java1.8/多线程#可运行runable"></a></h2><p>正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。</p><h2 id="阻塞blocked"><a class="markdownIt-Anchor" href="java1.8/多线程#阻塞blocked"></a> 阻塞（BLOCKED）<a href="java1.8/多线程#阻塞blocked"></a></h2><p>请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。</p><h2 id="无限期等待waiting"><a class="markdownIt-Anchor" href="java1.8/多线程#无限期等待waiting"></a> 无限期等待（WAITING）<a href="java1.8/多线程#无限期等待waiting"></a></h2><p>等待其它线程显式地唤醒。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>没有设置 Timeout 参数的 Object.wait() 方法</td><td>Object.notify() / Object.notifyAll()</td></tr><tr><td>没有设置 Timeout 参数的 Thread.join() 方法</td><td>被调用的线程执行完毕</td></tr><tr><td>LockSupport.park() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></div></div><h2 id="限期等待timed_waiting"><a class="markdownIt-Anchor" href="java1.8/多线程#限期等待timed_waiting"></a> 限期等待（TIMED_WAITING）<a href="java1.8/多线程#限期等待timed_waiting"></a></h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th>进入方法</th><th>退出方法</th></tr></thead><tbody><tr><td>Thread.sleep() 方法</td><td>时间结束</td></tr><tr><td>设置了 Timeout 参数的 Object.wait() 方法</td><td>时间结束 / Object.notify() / Object.notifyAll()</td></tr><tr><td>设置了 Timeout 参数的 Thread.join() 方法</td><td>时间结束 / 被调用的线程执行完毕</td></tr><tr><td>LockSupport.parkNanos() 方法</td><td>LockSupport.unpark(Thread)</td></tr><tr><td>LockSupport.parkUntil() 方法</td><td>LockSupport.unpark(Thread)</td></tr></tbody></table></div></div><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><h2 id="死亡terminated"><a class="markdownIt-Anchor" href="java1.8/多线程#死亡terminated"></a> 死亡（TERMINATED）<a href="java1.8/多线程#死亡terminated"></a></h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h1 id="juc-aqs"><a class="markdownIt-Anchor" href="java1.8/多线程#juc-aqs"></a> J.U.C - AQS<a href="java1.8/多线程#juc-aqs"></a></h1><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2 id="countdownlatch"><a class="markdownIt-Anchor" href="java1.8/多线程#countdownlatch"></a> CountDownLatch<a href="java1.8/多线程#countdownlatch"></a></h2><p>用来控制一个或者多个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><p><img src="/Users/ng/Documents/java1.8/pictures/CountDownLatch.png" alt="CountDownLatch" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"run.."</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">run..run..run..run..run..run..run..run..run..run..end</span><br></pre></td></tr></table></div></figure><h2 id="cyclicbarrier"><a class="markdownIt-Anchor" href="java1.8/多线程#cyclicbarrier"></a> CyclicBarrier<a href="java1.8/多线程#cyclicbarrier"></a></h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><img src="/Users/ng/Documents/java1.8/pictures/CyclicBarrier.png" alt="CyclicBarrier" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalThread = <span class="number">10</span>;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(totalThread);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalThread; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                System.out.print(<span class="string">"before.."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(<span class="string">"after.."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..</span><br></pre></td></tr></table></div></figure><h2 id="semaphore"><a class="markdownIt-Anchor" href="java1.8/多线程#semaphore"></a> Semaphore<a href="java1.8/多线程#semaphore"></a></h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> clientCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> totalRequestCount = <span class="number">10</span>;</span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(clientCount);</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalRequestCount; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt;&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                    System.out.print(semaphore.availablePermits() + <span class="string">" "</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></div></figure><h1 id="juc-其它组件"><a class="markdownIt-Anchor" href="java1.8/多线程#juc-其它组件"></a> J.U.C - 其它组件<a href="java1.8/多线程#juc-其它组件"></a></h1><h2 id="futuretask"><a class="markdownIt-Anchor" href="java1.8/多线程#futuretask"></a> FutureTask<a href="java1.8/多线程#futuretask"></a></h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></div></figure><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    result += i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread computeThread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        computeThread.start();</span><br><span class="line"></span><br><span class="line">        Thread otherThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"other task is running..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        otherThread.start();</span><br><span class="line">        System.out.println(futureTask.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">other task is running...</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></div></figure><h2 id="blockingqueue"><a class="markdownIt-Anchor" href="java1.8/多线程#blockingqueue"></a> BlockingQueue<a href="java1.8/多线程#blockingqueue"></a></h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li><strong>FIFO 队列</strong> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li><strong>优先级队列</strong> ：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><strong>使用 BlockingQueue 实现生产者消费者问题</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(<span class="string">"product"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"produce.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String product = queue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"consume.."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        Consumer consumer = <span class="keyword">new</span> Consumer();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        producer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..</span><br></pre></td></tr></table></div></figure><h2 id="forkjoin"><a class="markdownIt-Anchor" href="java1.8/多线程#forkjoin"></a> ForkJoin<a href="java1.8/多线程#forkjoin"></a></h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinExample</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> first;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> last;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinExample</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.last = last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (last - first &lt;= threshold) &#123;</span><br><span class="line">            <span class="comment">// 任务足够小则直接计算</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt;= last; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拆分成小任务</span></span><br><span class="line">            <span class="keyword">int</span> middle = first + (last - first) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinExample leftTask = <span class="keyword">new</span> ForkJoinExample(first, middle);</span><br><span class="line">            ForkJoinExample rightTask = <span class="keyword">new</span> ForkJoinExample(middle + <span class="number">1</span>, last);</span><br><span class="line">            leftTask.fork();</span><br><span class="line">            rightTask.fork();</span><br><span class="line">            result = leftTask.join() + rightTask.join();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ForkJoinExample example = <span class="keyword">new</span> ForkJoinExample(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    Future result = forkJoinPool.submit(example);</span><br><span class="line">    System.out.println(result.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span></span></span><br></pre></td></tr></table></div></figure><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><p><img src="/Users/ng/Documents/java1.8/pictures/ForkJoinPool.png" alt="ForkJoinPool" class="article-img"></p><h1 id="线程不安全示例"><a class="markdownIt-Anchor" href="java1.8/多线程#线程不安全示例"></a> 线程不安全示例<a href="java1.8/多线程#线程不安全示例"></a></h1><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadUnsafeExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    ThreadUnsafeExample example = <span class="keyword">new</span> ThreadUnsafeExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">997</span></span><br></pre></td></tr></table></div></figure><h1 id="java-内存模型"><a class="markdownIt-Anchor" href="java1.8/多线程#java-内存模型"></a> Java 内存模型<a href="java1.8/多线程#java-内存模型"></a></h1><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h2 id="主内存与工作内存"><a class="markdownIt-Anchor" href="java1.8/多线程#主内存与工作内存"></a> 主内存与工作内存<a href="java1.8/多线程#主内存与工作内存"></a></h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png" alt="主内存和工作内存" class="article-img"></p><h2 id="内存间交互操作"><a class="markdownIt-Anchor" href="java1.8/多线程#内存间交互操作"></a> 内存间交互操作<a href="java1.8/多线程#内存间交互操作"></a></h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C.png" alt="内存间交互操作" class="article-img"></p><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h2 id="内存模型三大特性"><a class="markdownIt-Anchor" href="java1.8/多线程#内存模型三大特性"></a> 内存模型三大特性<a href="java1.8/多线程#内存模型三大特性"></a></h2><h3 id="1-原子性"><a class="markdownIt-Anchor" href="java1.8/多线程#1-原子性"></a> 1. 原子性<a href="java1.8/多线程#1-原子性"></a></h3><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><p><img src="/Users/ng/Documents/java1.8/pictures/int%E5%8E%9F%E5%AD%90%E6%80%A7.jpeg" alt="int原子性" class="article-img"></p><p>AtomicInteger 能保证多个线程修改的原子性。</p><p><img src="/Users/ng/Documents/java1.8/pictures/AtomicInteger.jpeg" alt="AtomicInteger" class="article-img"></p><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicExample example = <span class="keyword">new</span> AtomicExample(); <span class="comment">// 只修改这条语句</span></span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></div></figure><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicSynchronizedExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> threadSize = <span class="number">1000</span>;</span><br><span class="line">    AtomicSynchronizedExample example = <span class="keyword">new</span> AtomicSynchronizedExample();</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadSize);</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadSize; i++) &#123;</span><br><span class="line">        executorService.execute(() -&gt; &#123;</span><br><span class="line">            example.add();</span><br><span class="line">            countDownLatch.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    System.out.println(example.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></div></figure><h3 id="2-可见性"><a class="markdownIt-Anchor" href="java1.8/多线程#2-可见性"></a> 2. 可见性<a href="java1.8/多线程#2-可见性"></a></h3><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><h3 id="3-有序性"><a class="markdownIt-Anchor" href="java1.8/多线程#3-有序性"></a> 3. 有序性<a href="java1.8/多线程#3-有序性"></a></h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h2 id="先行发生原则"><a class="markdownIt-Anchor" href="java1.8/多线程#先行发生原则"></a> 先行发生原则<a href="java1.8/多线程#先行发生原则"></a></h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h3 id="1-单一线程原则"><a class="markdownIt-Anchor" href="java1.8/多线程#1-单一线程原则"></a> 1. 单一线程原则<a href="java1.8/多线程#1-单一线程原则"></a></h3><blockquote><p>Single Thread rule</p></blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><h3 id="2-管程锁定规则"><a class="markdownIt-Anchor" href="java1.8/多线程#2-管程锁定规则"></a> 2. 管程锁定规则<a href="java1.8/多线程#2-管程锁定规则"></a></h3><blockquote><p>Monitor Lock Rule</p></blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><h3 id="3-volatile-变量规则"><a class="markdownIt-Anchor" href="java1.8/多线程#3-volatile-变量规则"></a> 3. volatile 变量规则<a href="java1.8/多线程#3-volatile-变量规则"></a></h3><blockquote><p>Volatile Variable Rule</p></blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><h3 id="4-线程启动规则"><a class="markdownIt-Anchor" href="java1.8/多线程#4-线程启动规则"></a> 4. 线程启动规则<a href="java1.8/多线程#4-线程启动规则"></a></h3><blockquote><p>Thread Start Rule</p></blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><h3 id="5-线程加入规则"><a class="markdownIt-Anchor" href="java1.8/多线程#5-线程加入规则"></a> 5. 线程加入规则<a href="java1.8/多线程#5-线程加入规则"></a></h3><blockquote><p>Thread Join Rule</p></blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><p><img src="/Users/ng/Documents/java1.8/pictures/join%E6%96%B9%E6%B3%95.png" alt="join方法" class="article-img"></p><h3 id="6-线程中断规则"><a class="markdownIt-Anchor" href="java1.8/多线程#6-线程中断规则"></a> 6. 线程中断规则<a href="java1.8/多线程#6-线程中断规则"></a></h3><blockquote><p>Thread Interruption Rule</p></blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h3 id="7-对象终结规则"><a class="markdownIt-Anchor" href="java1.8/多线程#7-对象终结规则"></a> 7. 对象终结规则<a href="java1.8/多线程#7-对象终结规则"></a></h3><blockquote><p>Finalizer Rule</p></blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><h3 id="8-传递性"><a class="markdownIt-Anchor" href="java1.8/多线程#8-传递性"></a> 8. 传递性<a href="java1.8/多线程#8-传递性"></a></h3><blockquote><p>Transitivity</p></blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h1 id="线程安全"><a class="markdownIt-Anchor" href="java1.8/多线程#线程安全"></a> 线程安全<a href="java1.8/多线程#线程安全"></a></h1><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><h2 id="不可变"><a class="markdownIt-Anchor" href="java1.8/多线程#不可变"></a> 不可变<a href="java1.8/多线程#不可变"></a></h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map);</span><br><span class="line">        unmodifiableMap.put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException</span><br><span class="line">    at java.util.Collections$UnmodifiableMap.put(Collections.java:<span class="number">1457</span>)</span><br><span class="line">    at ImmutableExample.main(ImmutableExample.java:<span class="number">9</span>)</span><br></pre></td></tr></table></div></figure><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="互斥同步-2"><a class="markdownIt-Anchor" href="java1.8/多线程#互斥同步-2"></a> 互斥同步<a href="java1.8/多线程#互斥同步-2"></a></h2><p>synchronized 和 ReentrantLock。</p><h2 id="非阻塞同步"><a class="markdownIt-Anchor" href="java1.8/多线程#非阻塞同步"></a> 非阻塞同步<a href="java1.8/多线程#非阻塞同步"></a></h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><h3 id="cas"><a class="markdownIt-Anchor" href="java1.8/多线程#cas"></a> CAS<a href="java1.8/多线程#cas"></a></h3><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h3 id="atomicinteger"><a class="markdownIt-Anchor" href="java1.8/多线程#atomicinteger"></a> AtomicInteger<a href="java1.8/多线程#atomicinteger"></a></h3><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger cnt = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cnt.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="aba"><a class="markdownIt-Anchor" href="java1.8/多线程#aba"></a> ABA<a href="java1.8/多线程#aba"></a></h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h2 id="无同步方案"><a class="markdownIt-Anchor" href="java1.8/多线程#无同步方案"></a> 无同步方案<a href="java1.8/多线程#无同步方案"></a></h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h3 id="栈封闭"><a class="markdownIt-Anchor" href="java1.8/多线程#栈封闭"></a> 栈封闭<a href="java1.8/多线程#栈封闭"></a></h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackClosedExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add100</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    StackClosedExample example = <span class="keyword">new</span> StackClosedExample();</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.execute(() -&gt; example.add100());</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></div></figure><h3 id="线程本地存储thread-local-storage"><a class="markdownIt-Anchor" href="java1.8/多线程#线程本地存储thread-local-storage"></a> 线程本地存储（Thread Local Storage）<a href="java1.8/多线程#线程本地存储thread-local-storage"></a></h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal.remove();</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></div></figure><p>为了理解 ThreadLocal，先看以下代码：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal threadLocal1 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        ThreadLocal threadLocal2 = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">1</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            threadLocal1.set(<span class="number">2</span>);</span><br><span class="line">            threadLocal2.set(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>它所对应的底层结构图为：</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8.png" alt="线程本地存储" class="article-img"></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></div></figure><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>get() 方法类似。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h3 id="可重入代码reentrant-code"><a class="markdownIt-Anchor" href="java1.8/多线程#可重入代码reentrant-code"></a> 可重入代码（Reentrant Code）<a href="java1.8/多线程#可重入代码reentrant-code"></a></h3><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h1 id="锁优化"><a class="markdownIt-Anchor" href="java1.8/多线程#锁优化"></a> 锁优化<a href="java1.8/多线程#锁优化"></a></h1><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h2 id="自旋锁"><a class="markdownIt-Anchor" href="java1.8/多线程#自旋锁"></a> 自旋锁<a href="java1.8/多线程#自旋锁"></a></h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a class="markdownIt-Anchor" href="java1.8/多线程#锁消除"></a> 锁消除<a href="java1.8/多线程#锁消除"></a></h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h2 id="锁粗化"><a class="markdownIt-Anchor" href="java1.8/多线程#锁粗化"></a> 锁粗化<a href="java1.8/多线程#锁粗化"></a></h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h2 id="轻量级锁"><a class="markdownIt-Anchor" href="java1.8/多线程#轻量级锁"></a> 轻量级锁<a href="java1.8/多线程#轻量级锁"></a></h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><p><img src="/Users/ng/Documents/java1.8/pictures/MarkWord.png" alt="" class="article-img"></p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><p><img src="/Users/ng/Documents/java1.8/pictures/LockRecord.png" alt="LockRecord" class="article-img"></p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81.png" alt="轻量级锁" class="article-img"></p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h2 id="偏向锁"><a class="markdownIt-Anchor" href="java1.8/多线程#偏向锁"></a> 偏向锁<a href="java1.8/多线程#偏向锁"></a></h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E5%81%8F%E5%90%91%E9%94%81.jpeg" alt="偏向锁" class="article-img"></p><h1 id="多线程开发良好的实践"><a class="markdownIt-Anchor" href="java1.8/多线程#多线程开发良好的实践"></a> 多线程开发良好的实践<a href="java1.8/多线程#多线程开发良好的实践"></a></h1><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;java1.8/多线程#使用线程&quot;&gt;&lt;/a&gt; 使用线程&lt;a href=&quot;java1.8/多线程#使用线程&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;有三种使用线程的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java1.8/pictures/周会</title>
    <link href="ilucia.github.io/java1.8/pictures/%E5%91%A8%E4%BC%9A/"/>
    <id>ilucia.github.io/java1.8/pictures/%E5%91%A8%E4%BC%9A/</id>
    <published>2022-04-27T15:24:01.723Z</published>
    <updated>2022-04-27T15:24:01.723Z</updated>
    
    <content type="html"><![CDATA[<p>周会</p><p>方案-&gt;评审-&gt;代码</p><p>终端和后端同步</p><p>PDA套用自贩机</p><p>自动化测试</p><p>后端报告风险/工作</p><p>拼团开发阶段</p><p>提交代码按功能提交</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周会&lt;/p&gt;
&lt;p&gt;方案-&amp;gt;评审-&amp;gt;代码&lt;/p&gt;
&lt;p&gt;终端和后端同步&lt;/p&gt;
&lt;p&gt;PDA套用自贩机&lt;/p&gt;
&lt;p&gt;自动化测试&lt;/p&gt;
&lt;p&gt;后端报告风险/工作&lt;/p&gt;
&lt;p&gt;拼团开发阶段&lt;/p&gt;
&lt;p&gt;提交代码按功能提交&lt;/p&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java1.8/ATM修改方案</title>
    <link href="ilucia.github.io/java1.8/ATM%E4%BF%AE%E6%94%B9%E6%96%B9%E6%A1%88/"/>
    <id>ilucia.github.io/java1.8/ATM%E4%BF%AE%E6%94%B9%E6%96%B9%E6%A1%88/</id>
    <published>2022-04-27T15:24:01.719Z</published>
    <updated>2022-04-27T15:24:01.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="atm修改方案"><a class="markdownIt-Anchor" href="java1.8/ATM修改方案#atm修改方案"></a> ATM修改方案<a href="java1.8/ATM修改方案#atm修改方案"></a></h2><ol><li>使用NIO进行连接，构造主线程</li><li>使用线程池进行读写</li><li>数组改为其他集合类</li><li>按钮监听器改为函数式编程方式实现</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;atm修改方案&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;java1.8/ATM修改方案#atm修改方案&quot;&gt;&lt;/a&gt; ATM修改方案&lt;a href=&quot;java1.8/ATM修改方案#atm修改方案&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java1.8/IO-NIO</title>
    <link href="ilucia.github.io/java1.8/IO-NIO/"/>
    <id>ilucia.github.io/java1.8/IO-NIO/</id>
    <published>2022-04-27T15:24:01.719Z</published>
    <updated>2022-04-27T15:24:01.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="io"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#io"></a> I/O<a href="java1.8/IO-NIO#io"></a></h2><p>![Java IO](/Users/ng/Documents/java1.8/pictures/Java IO.jpg)</p><ul><li>Java 的 I/O 大概可以分成以下几类：<ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>NIO</li></ul></li></ul><h3 id="磁盘操作"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#磁盘操作"></a> 磁盘操作<a href="java1.8/IO-NIO#磁盘操作"></a></h3><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p><p>递归地列出一个目录下所有文件：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFiles</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dir == <span class="keyword">null</span> || !dir.exists()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dir.isFile()) &#123;</span><br><span class="line">        System.out.println(dir.getName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File file : dir.listFiles()) &#123;</span><br><span class="line">        listAllFiles(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p><h3 id="字节操作"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#字节操作"></a> 字节操作<a href="java1.8/IO-NIO#字节操作"></a></h3><h4 id="实现文件复制"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#实现文件复制"></a> 实现文件复制<a href="java1.8/IO-NIO#实现文件复制"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileInputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read() 最多读取 buffer.length 个字节</span></span><br><span class="line">    <span class="comment">// 返回的是实际读取的个数</span></span><br><span class="line">    <span class="comment">// 返回 -1 的时候表示读到 eof，即文件尾</span></span><br><span class="line">    <span class="keyword">while</span> ((cnt = in.read(buffer, <span class="number">0</span>, buffer.length)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        out.write(buffer, <span class="number">0</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.close();</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="装饰者模式"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#装饰者模式"></a> 装饰者模式<a href="java1.8/IO-NIO#装饰者模式"></a></h4><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p><ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><p><img src="/Users/ng/Documents/java1.8/pictures/InputStream%E6%A1%86%E6%9E%B6.png" alt="InputStream框架" class="article-img"></p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(filePath);</span><br><span class="line">BufferedInputStream bufferedInputStream = <span class="keyword">new</span> BufferedInputStream(fileInputStream);</span><br></pre></td></tr></table></div></figure><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h3 id="字符操作"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#字符操作"></a> 字符操作<a href="java1.8/IO-NIO#字符操作"></a></h3><h4 id="编码与解码"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#编码与解码"></a> 编码与解码<a href="java1.8/IO-NIO#编码与解码"></a></h4><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p><p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p><h4 id="string-的编码方式"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#string-的编码方式"></a> String 的编码方式<a href="java1.8/IO-NIO#string-的编码方式"></a></h4><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"中文"</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line">String str2 = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></div></figure><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = str1.getBytes();</span><br></pre></td></tr></table></div></figure><h4 id="reader-与-writer"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#reader-与-writer"></a> Reader 与 Writer<a href="java1.8/IO-NIO#reader-与-writer"></a></h4><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p><ul><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h4 id="实现逐行输出文本文件的内容"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#实现逐行输出文本文件的内容"></a> 实现逐行输出文本文件的内容<a href="java1.8/IO-NIO#实现逐行输出文本文件的内容"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFileContent</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    FileReader fileReader = <span class="keyword">new</span> FileReader(filePath);</span><br><span class="line">    BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(fileReader);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象</span></span><br><span class="line">    <span class="comment">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法</span></span><br><span class="line">    <span class="comment">// 因此只要一个 close() 调用即可</span></span><br><span class="line">    bufferedReader.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="对象操作"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#对象操作"></a> 对象操作<a href="java1.8/IO-NIO#对象操作"></a></h3><h4 id="序列化"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#序列化"></a> 序列化<a href="java1.8/IO-NIO#序列化"></a></h4><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化：ObjectOutputStream.writeObject()</li><li>反序列化：ObjectInputStream.readObject()</li></ul><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p><h4 id="serializable"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#serializable"></a> Serializable<a href="java1.8/IO-NIO#serializable"></a></h4><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    A a1 = <span class="keyword">new</span> A(<span class="number">123</span>, <span class="string">"abc"</span>);</span><br><span class="line">    String objectFile = <span class="string">"file/a1"</span>;</span><br><span class="line"></span><br><span class="line">    ObjectOutputStream objectOutputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(objectFile));</span><br><span class="line">    objectOutputStream.writeObject(a1);</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line"></span><br><span class="line">    ObjectInputStream objectInputStream = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(objectFile));</span><br><span class="line">    A a2 = (A) objectInputStream.readObject();</span><br><span class="line">    objectInputStream.close();</span><br><span class="line">    System.out.println(a2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> String y;</span><br><span class="line"></span><br><span class="line">    A(<span class="keyword">int</span> x, String y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"x = "</span> + x + <span class="string">"  "</span> + <span class="string">"y = "</span> + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="transient"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#transient"></a> transient<a href="java1.8/IO-NIO#transient"></a></h4><p>transient 关键字可以使一些属性不会被序列化。</p><p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></div></figure><h3 id="网络操作"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#网络操作"></a> 网络操作<a href="java1.8/IO-NIO#网络操作"></a></h3><p>Java 中的网络支持：</p><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h4 id="inetaddress"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#inetaddress"></a> InetAddress<a href="java1.8/IO-NIO#inetaddress"></a></h4><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InetAddress.getByName(String host);</span><br><span class="line">InetAddress.getByAddress(<span class="keyword">byte</span>[] address);</span><br></pre></td></tr></table></div></figure><h4 id="url"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#url"></a> URL<a href="java1.8/IO-NIO#url"></a></h4><p>可以直接从 URL 中读取字节流数据。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字节流 */</span></span><br><span class="line">    InputStream is = url.openStream();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 字符流 */</span></span><br><span class="line">    InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 提供缓存功能 */</span></span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    br.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="sockets"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#sockets"></a> Sockets<a href="java1.8/IO-NIO#sockets"></a></h4><ul><li>ServerSocket：服务器端类</li><li>Socket：客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><p><img src="/Users/ng/Documents/java1.8/pictures/Socket.png" alt="Socket" class="article-img"></p><h4 id="datagram"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#datagram"></a> Datagram<a href="java1.8/IO-NIO#datagram"></a></h4><ul><li>DatagramSocket：通信类</li><li>DatagramPacket：数据包类</li></ul><h2 id="nio"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#nio"></a> NIO<a href="java1.8/IO-NIO#nio"></a></h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p><h3 id="流与块"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#流与块"></a> 流与块<a href="java1.8/IO-NIO#流与块"></a></h3><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p><p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><p>I/O 包和 NIO 已经很好地集成了，<a href="http://java.io" target="_blank" rel="noopener">java.io</a>.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，<a href="http://java.io" target="_blank" rel="noopener">java.io</a>.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h3 id="通道与缓冲区"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#通道与缓冲区"></a> 通道与缓冲区<a href="java1.8/IO-NIO#通道与缓冲区"></a></h3><h4 id="通道"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#通道"></a> 通道<a href="java1.8/IO-NIO#通道"></a></h4><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p><p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>通道包括以下类型：</p><ul><li>FileChannel：从文件中读写数据；</li><li>DatagramChannel：通过 UDP 读写网络中数据；</li><li>SocketChannel：通过 TCP 读写网络中数据；</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h4 id="缓冲区"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#缓冲区"></a> 缓冲区<a href="java1.8/IO-NIO#缓冲区"></a></h4><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h5 id="缓冲区状态变量"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#缓冲区状态变量"></a> 缓冲区状态变量<a href="java1.8/IO-NIO#缓冲区状态变量"></a></h5><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F1.png" alt="状态变量1" class="article-img"></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F2.png" alt="状态变量2" class="article-img"></p><p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F3.png" alt="状态变量3" class="article-img"></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F4.png" alt="状态变量4" class="article-img"></p><p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p><p><img src="/Users/ng/Documents/java1.8/pictures/%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F5.png" alt="状态变量5" class="article-img"></p><h2 id="文件-nio-实例"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#文件-nio-实例"></a> 文件 NIO 实例<a href="java1.8/IO-NIO#文件-nio-实例"></a></h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fastCopy</span><span class="params">(String src, String dist)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获得源文件的输入字节流 */</span></span><br><span class="line">    FileInputStream fin = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输入字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcin = fin.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取目标文件的输出字节流 */</span></span><br><span class="line">    FileOutputStream fout = <span class="keyword">new</span> FileOutputStream(dist);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取输出字节流的文件通道 */</span></span><br><span class="line">    FileChannel fcout = fout.getChannel();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 为缓冲区分配 1024 个字节 */</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从输入通道中读取数据到缓冲区中 */</span></span><br><span class="line">        <span class="keyword">int</span> r = fcin.read(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* read() 返回 -1 表示 EOF */</span></span><br><span class="line">        <span class="keyword">if</span> (r == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 切换读写 */</span></span><br><span class="line">        buffer.flip();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 把缓冲区的内容写入输出文件中 */</span></span><br><span class="line">        fcout.write(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 清空缓冲区 */</span></span><br><span class="line">        buffer.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="选择器"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#选择器"></a> 选择器<a href="java1.8/IO-NIO#选择器"></a></h2><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p><p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><p><img src="/Users/ng/Documents/java1.8/pictures/NIO%E9%80%89%E6%8B%A9%E5%99%A8.png" alt="NIO选择器" class="article-img"></p><h3 id="1-创建选择器"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#1-创建选择器"></a> 1. 创建选择器<a href="java1.8/IO-NIO#1-创建选择器"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></div></figure><h3 id="2-将通道注册到选择器上"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#2-将通道注册到选择器上"></a> 2. 将通道注册到选择器上<a href="java1.8/IO-NIO#2-将通道注册到选择器上"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></div></figure><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>它们在 SelectionKey 的定义如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></div></figure><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></div></figure><h3 id="3-监听事件"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#3-监听事件"></a> 3. 监听事件<a href="java1.8/IO-NIO#3-监听事件"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = selector.select();</span><br></pre></td></tr></table></div></figure><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p><h3 id="4-获取到达的事件"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#4-获取到达的事件"></a> 4. 获取到达的事件<a href="java1.8/IO-NIO#4-获取到达的事件"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"><span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="5-事件循环"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#5-事件循环"></a> 5. 事件循环<a href="java1.8/IO-NIO#5-事件循环"></a></h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> num = selector.select();</span><br><span class="line">    Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">    Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line">    <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">        SelectionKey key = keyIterator.next();</span><br><span class="line">        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        keyIterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="套接字-nio-实例"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#套接字-nio-实例"></a> 套接字 NIO 实例<a href="java1.8/IO-NIO#套接字-nio-实例"></a></h2><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel ssChannel = ServerSocketChannel.open();</span><br><span class="line">        ssChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        ssChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = ssChannel.socket();</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = keys.iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line"></span><br><span class="line">                    ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 服务器会为每个新连接创建一个 SocketChannel</span></span><br><span class="line">                    SocketChannel sChannel = ssChannel1.accept();</span><br><span class="line">                    sChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这个新连接主要用于从客户端读取数据</span></span><br><span class="line">                    sChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketChannel sChannel = (SocketChannel) key.channel();</span><br><span class="line">                    System.out.println(readDataFromSocketChannel(sChannel));</span><br><span class="line">                    sChannel.close();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readDataFromSocketChannel</span><span class="params">(SocketChannel sChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            buffer.clear();</span><br><span class="line">            <span class="keyword">int</span> n = sChannel.read(buffer);</span><br><span class="line">            <span class="keyword">if</span> (n == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="keyword">int</span> limit = buffer.limit();</span><br><span class="line">            <span class="keyword">char</span>[] dst = <span class="keyword">new</span> <span class="keyword">char</span>[limit];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; limit; i++) &#123;</span><br><span class="line">                dst[i] = (<span class="keyword">char</span>) buffer.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            data.append(dst);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream out = socket.getOutputStream();</span><br><span class="line">        String s = <span class="string">"hello world"</span>;</span><br><span class="line">        out.write(s.getBytes());</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="内存映射文件"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#内存映射文件"></a> 内存映射文件<a href="java1.8/IO-NIO#内存映射文件"></a></h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p><p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p><p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">1024</span>);</span><br></pre></td></tr></table></div></figure><h2 id="对比"><a class="markdownIt-Anchor" href="java1.8/IO-NIO#对比"></a> 对比<a href="java1.8/IO-NIO#对比"></a></h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p><ul><li>NIO 是非阻塞的；</li><li>NIO 面向块，I/O 面向流。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;io&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;java1.8/IO-NIO#io&quot;&gt;&lt;/a&gt; I/O&lt;a href=&quot;java1.8/IO-NIO#io&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;![Java IO](/Users/ng/Docu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>java1.8/Stream</title>
    <link href="ilucia.github.io/java1.8/Stream/"/>
    <id>ilucia.github.io/java1.8/Stream/</id>
    <published>2022-04-27T15:24:01.719Z</published>
    <updated>2022-04-27T15:24:01.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="stream-简介"><a class="markdownIt-Anchor" href="java1.8/Stream#stream-简介"></a> Stream 简介<a href="java1.8/Stream#stream-简介"></a></h3><ul><li>Java 8 中，引入了流（Stream）的概念，这个流和以前我们使用的 IO 中的流并不太相同</li><li>所有继承自 <code>Collection</code> 的接口都可以转换为 <code>Stream</code></li></ul><h4 id="例"><a class="markdownIt-Anchor" href="java1.8/Stream#例"></a> 例<a href="java1.8/Stream#例"></a></h4><p>假设我们有一个 <code>List</code> 包含一系列的 <code>Person</code>，<code>Person</code> 有姓名 <code>name</code> 和年龄 <code>age</code> 连个字段。现要求这个列表中年龄大于 20 的人数</p><p>通常按照以前我们可能会这么写：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (Person p : persons) &#123;</span><br><span class="line"><span class="keyword">if</span> (p.getAge() &gt; <span class="number">20</span>) &#123;</span><br><span class="line">count ++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>但如果使用 <code>stream</code> 的话，则会简单很多:</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = persons.stream()</span><br><span class="line">.filter(person -&gt; person.getAge() &gt; <span class="number">20</span>)</span><br><span class="line"> .count();</span><br></pre></td></tr></table></div></figure><p>这只是 <code>stream</code> 的很简单的一个用法。现在链式调用方法算是一个主流，这样写也更利于阅读和理解编写者的意图，一步方法做一件事</p><h3 id="stream-常用操作"><a class="markdownIt-Anchor" href="java1.8/Stream#stream-常用操作"></a> Stream 常用操作<a href="java1.8/Stream#stream-常用操作"></a></h3><ul><li><code>Stream</code> 的方法分为两类。一类叫惰性求值，一类叫及早求值。</li><li>如果返回值是 Stream，那么是惰性求值<ul><li>如果调用惰性求值方法，<code>Stream</code> 只是记录下了这个惰性求值方法的过程，并没有去计算，等到调用及早求值方法后，就连同前面的一系列惰性求值方法顺序进行计算，返回结果</li></ul></li></ul><p>通用形式为：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.惰性求值.惰性求值. ... .惰性求值.及早求值</span><br></pre></td></tr></table></div></figure><p>整个过程和建造者模式有共通之处。建造者模式使用一系列操作设置属性和配置，最后调 用一个 build 方法，这时，对象才被真正创建</p><h4 id="collecttolist"><a class="markdownIt-Anchor" href="java1.8/Stream#collecttolist"></a> collect(toList())<a href="java1.8/Stream#collecttolist"></a></h4><p><code>collect(toList())</code> 方法由 <code>Stream</code> 里的值生成一个列表，是一个及早求值操作，可以理解为 <code>Stream</code> 向 <code>Collection</code> 的转换</p><blockquote><p>注意这边的 <code>toList()</code> 其实是 <code>Collectors.toList()</code>，因为采用了静态倒入，看起来显得简洁。</p></blockquote><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br><span class="line">   .collect(Collectors.toList());</span><br><span class="line">assertEquals(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>), collected);</span><br></pre></td></tr></table></div></figure><h4 id="map"><a class="markdownIt-Anchor" href="java1.8/Stream#map"></a> map<a href="java1.8/Stream#map"></a></h4><p>如果有一个函数可以将一种类型的值转换成另外一种类型，<code>map</code> 操作就可以使用该函数，将一个流中的值转换成一个新的流。</p><p><img src="https://images2015.cnblogs.com/blog/1046505/201610/1046505-20161020160120326-1422995090.png" alt="img" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; collected = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"hello"</span>)</span><br><span class="line">   .map(string -&gt; string.toUpperCase())</span><br><span class="line">   .collect(toList());</span><br><span class="line">assertEquals(asList(<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"HELLO"</span>), collected);</span><br></pre></td></tr></table></div></figure><p><code>map</code> 方法就是接受的一个 <code>Function</code> 的匿名函数类，进行的转换。</p><p><img src="https://images2015.cnblogs.com/blog/1046505/201610/1046505-20161020160134904-1768291565.png" alt="img" class="article-img"></p><h4 id="filter"><a class="markdownIt-Anchor" href="java1.8/Stream#filter"></a> filter<a href="java1.8/Stream#filter"></a></h4><p>遍历数据并检查其中的元素时，可尝试使用 <code>Stream</code> 中提供的新方法 <code>filter</code>。</p><p><img src="https://images2015.cnblogs.com/blog/1046505/201610/1046505-20161020160150935-2057482897.png" alt="img" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; beginningWithNumbers = </span><br><span class="line">Stream.of(<span class="string">"a"</span>, <span class="string">"1abc"</span>, <span class="string">"abc1"</span>)</span><br><span class="line">  .filter(value -&gt; isDigit(value.charAt(<span class="number">0</span>)))</span><br><span class="line">  .collect(toList());</span><br><span class="line">assertEquals(asList(<span class="string">"1abc"</span>), beginningWithNumbers);</span><br></pre></td></tr></table></div></figure><p><code>filter</code> 方法就是接受的一个 <code>Predicate</code> 的匿名函数类，判断对象是否符合条件，符合条件的才保留下来。</p><p><img src="https://images2015.cnblogs.com/blog/1046505/201610/1046505-20161020160211779-1658294349.png" alt="img" class="article-img"></p><h4 id="flatmap"><a class="markdownIt-Anchor" href="java1.8/Stream#flatmap"></a> flatMap<a href="java1.8/Stream#flatmap"></a></h4><p><code>flatMap</code> 方法可用 <code>Stream</code> 替换值，然后将多个 <code>Stream</code> 连接成一个 <code>Stream</code>。</p><p><img src="https://images2015.cnblogs.com/blog/1046505/201610/1046505-20161020160225482-436563893.png" alt="img" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; together = Stream.of(asList(<span class="number">1</span>, <span class="number">2</span>), asList(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">   .flatMap(numbers -&gt; numbers.stream())</span><br><span class="line">   .collect(toList());</span><br><span class="line">assertEquals(asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), together);</span><br></pre></td></tr></table></div></figure><p><code>flatMap</code> 最常用的操作就是合并多个 <code>Collection</code>。</p><h4 id="max和min"><a class="markdownIt-Anchor" href="java1.8/Stream#max和min"></a> max和min<a href="java1.8/Stream#max和min"></a></h4><p><code>Stream</code> 上常用的操作之一是求最大值和最小值。Stream API 中的 <code>max</code> 和 <code>min</code> 操作足以解决这一问题。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> maxInt = list.stream()</span><br><span class="line"> .max(Integer::compareTo)</span><br><span class="line"> .get();</span><br><span class="line"><span class="keyword">int</span> minInt = list.stream()</span><br><span class="line"> .min(Integer::compareTo)</span><br><span class="line"> .get();</span><br><span class="line">assertEquals(maxInt, <span class="number">9</span>);</span><br><span class="line">assertEquals(minInt, <span class="number">1</span>);</span><br></pre></td></tr></table></div></figure><p>这里有 2 个要点需要注意：</p><ol><li><code>max</code> 和 <code>min</code> 方法返回的是一个 <code>Optional</code> 对象（和 Google Guava 里的 Optional 对象是一样的）。<code>Optional</code> 对象封装的就是实际的值，可能为空，所以保险起见，可以先用 <code>isPresent()</code> 方法判断一下。<code>Optional</code> 的引入就是为了解决方法返回 <code>null</code> 的问题。</li><li><code>Integer::compareTo</code> 也是属于 Java 8 引入的新特性，叫做 <strong>方法引用（Method References）</strong>。在这边，其实就是 <code>(int1, int2) -&gt; int1.compareTo(int2)</code> 的简写，可以自己查阅了解，这里不再多做赘述。</li></ol><h4 id="reduce"><a class="markdownIt-Anchor" href="java1.8/Stream#reduce"></a> reduce<a href="java1.8/Stream#reduce"></a></h4><p><code>reduce</code> 操作可以实现从一组值中生成一个值。在上述例子中用到的 <code>count</code>、<code>min</code> 和 <code>max</code> 方法,因为常用而被纳入标准库中。事实上，这些方法都是 <code>reduce</code> 操作。</p><p><img src="https://images2015.cnblogs.com/blog/1046505/201610/1046505-20161020160243217-1836446247.png" alt="img" class="article-img"></p><p>上图展示了 <code>reduce</code> 进行累加的一个过程。具体的代码如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">   .reduce(<span class="number">0</span>, (acc, element) -&gt; acc + element);</span><br><span class="line">assertEquals(<span class="number">10</span>, result);</span><br></pre></td></tr></table></div></figure><p>注意 <code>reduce</code> 的第一个参数，这是一个初始值。<code>0 + 1 + 2 + 3 + 4 = 10</code>。</p><p>如果是累乘，则为：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">   .reduce(<span class="number">1</span>, (acc, element) -&gt; acc * element);</span><br><span class="line">assertEquals(<span class="number">24</span>, result);</span><br></pre></td></tr></table></div></figure><h3 id="数据并行化操作"><a class="markdownIt-Anchor" href="java1.8/Stream#数据并行化操作"></a> 数据并行化操作<a href="java1.8/Stream#数据并行化操作"></a></h3><p><code>Stream</code> 的并行化也是 Java 8 的一大亮点。数据并行化是指将数据分成块，为每块数据分配单独的处理单元。这样可以充分利用多核 CPU 的优势。</p><p>并行化操作流只需改变一个方法调用。如果已经有一个 <code>Stream</code> 对象，调用它的 <code>parallel()</code> 方法就能让其拥有并行操作的能力。如果想从一个集合类创建一个流，调用 <code>parallelStream()</code> 就能立即获得一个拥有并行能力的流。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sumSize = Stream.of(<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Orange"</span>, <span class="string">"Pear"</span>)</span><br><span class="line">.parallel()</span><br><span class="line">.map(s -&gt; s.length())</span><br><span class="line">.reduce(Integer::sum)</span><br><span class="line">.get();</span><br><span class="line">assertEquals(sumSize, <span class="number">21</span>);</span><br></pre></td></tr></table></div></figure><p>这里求的是一个字符串列表中各个字符串长度总和。</p><p><img src="https://images2015.cnblogs.com/blog/1046505/201610/1046505-20161020160307935-1086007264.png" alt="img" class="article-img"></p><p>如果你去计算这段代码所花的时间，很可能比不加上 <code>parallel()</code> 方法花的时间更长。这是因为数据并行化会先对数据进行分块，然后对每块数据开辟线程进行运算，这些地方会花费额外的时间。并行化操作只有在 <strong>数据规模比较大</strong> 或者 <strong>数据的处理时间比较长</strong> 的时候才能体现出有事，所以并不是每个地方都需要让数据并行化，应该具体问题具体分析。</p><h3 id="其他"><a class="markdownIt-Anchor" href="java1.8/Stream#其他"></a> 其他<a href="java1.8/Stream#其他"></a></h3><h4 id="收集器"><a class="markdownIt-Anchor" href="java1.8/Stream#收集器"></a> 收集器<a href="java1.8/Stream#收集器"></a></h4><p><code>Stream</code> 转换为 <code>List</code> 是很常用的操作，其他 <code>Collectors</code> 还有很多方法，可以将 <code>Stream</code> 转换为 <code>Set</code>, 或者将数据分组并转换为 <code>Map</code>，并对数据进行处理。也可以指定转换为具体类型，如 <code>ArrayList</code>, <code>LinkedList</code> 或者 <code>HashMap</code>。甚至可以自定义 <code>Collectors</code>，编写自己的收集器。</p><h4 id="元素顺序"><a class="markdownIt-Anchor" href="java1.8/Stream#元素顺序"></a> 元素顺序<a href="java1.8/Stream#元素顺序"></a></h4><p>另外一个尚未提及的关于集合类的内容是流中的元素以何种顺序排列。一些集合类型中的元素是按顺序排列的，比如 List；而另一些则是无序的，比如 HashSet。增加了流操作后，顺序问题变得更加复杂。</p><p>总之记住。如果集合本身就是无序的，由此生成的流也是无序的。一些中间操作会产生顺序，比如对值做映射时，映射后的值是有序的，这种顺序就会保留 下来。如果进来的流是无序的，出去的流也是无序的。</p><p>如果我们需要对流中的数据进行排序，可以调用 <code>sorted</code> 方法：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Lists.newArrayList(<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">List&lt;Integer&gt; sortedList = list.stream()</span><br><span class="line">   .sorted(Integer::compareTo)</span><br><span class="line">   .collect(Collectors.toList());</span><br><span class="line">assertEquals(sortedList, Lists.newArrayList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>));</span><br></pre></td></tr></table></div></figure><h4 id="functionalinterface"><a class="markdownIt-Anchor" href="java1.8/Stream#functionalinterface"></a> @FunctionalInterface<a href="java1.8/Stream#functionalinterface"></a></h4><p>我们讨论过函数接口定义的标准，但未提及 @FunctionalInterface 注释。事实上，每个用作函数接口的接口都应该添加这个注释。</p><p>但 Java 中有一些接口，虽然只含一个方法，但并不是为了使用 Lambda 表达式来实现的。比如，有些对象内部可能保存着某种状态，使用带有一个方法的接口可能纯属巧合。</p><p>该注释会强制 javac 检查一个接口是否符合函数接口的标准。如果该注释添加给一个枚举类型、类或另一个注释，或者接口包含不止一个抽象方法，javac 就会报错。重构代码时，使用它能很容易发现问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;stream-简介&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;java1.8/Stream#stream-简介&quot;&gt;&lt;/a&gt; Stream 简介&lt;a href=&quot;java1.8/Stream#stream-简介&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="ilucia.github.io/Redis/"/>
    <id>ilucia.github.io/Redis/</id>
    <published>2022-04-27T15:24:01.595Z</published>
    <updated>2022-04-27T15:24:01.595Z</updated>
    
    <content type="html"><![CDATA[<h1 id="redis"><a class="markdownIt-Anchor" href="Redis#redis"></a> Redis<a href="Redis#redis"></a></h1><h2 id="redis特性"><a class="markdownIt-Anchor" href="Redis#redis特性"></a> Redis特性<a href="Redis#redis特性"></a></h2><p>注意：Redis支持多个数据库，并且每个数据库的数据是隔离的不能共享，并且基于单机才有，如果是集群就没有数据库的概念。</p><p>Redis是一个字典结构的存储服务器，而实际上一个Redis实例提供了多个用来存储数据的字典，客户端可以指定将数据存储在哪个字典中。这与我们熟知的在一个关系数据库实例中可以创建多个数据库类似，所以可以将其中的每个字典都理解成一个独立的数据库。</p><p>每个数据库对外都是一个从0开始的递增数字命名，Redis默认支持16个数据库（可以通过配置文件支持更多，无上限），可以通过配置databases来修改这一数字。客户端与Redis建立连接后会自动选择0号数据库，不过可以随时使用SELECT命令更换数据库，如要选择1号数据库：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SELECT 1</span></span><br><span class="line">OK</span><br><span class="line">redis [1] &gt; GET foo</span><br><span class="line">(nil)</span><br></pre></td></tr></table></div></figure><p>然而这些以数字命名的数据库又与我们理解的数据库有所区别。首先Redis不支持自定义数据库的名字，每个数据库都以编号命名，开发者必须自己记录哪些数据库存储了哪些数据。另外Redis也不支持为每个数据库设置不同的访问密码，所以一个客户端要么可以访问全部数据库，要么连一个数据库也没有权限访问。最重要的一点是多个数据库之间并不是完全隔离的，比如FLUSHALL命令可以清空一个Redis实例中所有数据库中的数据。综上所述，这些数据库更像是一种命名空间，而不适宜存储不同应用程序的数据。比如可以使用0号数据库存储某个应用生产环境中的数据，使用1号数据库存储测试环境中的数据，但不适宜使用0号数据库存储A应用的数据而使用1号数据库B应用的数据，不同的应用应该使用不同的Redis实例存储数据。由于Redis非常轻量级，一个空Redis实例占用的内存只有1M左右，所以不用担心多个Redis实例会额外占用很多内存。</p><h2 id="redis配置"><a class="markdownIt-Anchor" href="Redis#redis配置"></a> Redis配置<a href="Redis#redis配置"></a></h2><h3 id="查看配置"><a class="markdownIt-Anchor" href="Redis#查看配置"></a> 查看配置<a href="Redis#查看配置"></a></h3><h5 id="语法"><a class="markdownIt-Anchor" href="Redis#语法"></a> 语法<a href="Redis#语法"></a></h5><p>Redis CONFIG 命令格式如下：<code>redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</code></p><h5 id="实例"><a class="markdownIt-Anchor" href="Redis#实例"></a> 实例<a href="Redis#实例"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET loglevel</span><br><span class="line"></span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br></pre></td></tr></table></div></figure><p>使用 ***** 号获取所有配置项</p><h3 id="编辑配置"><a class="markdownIt-Anchor" href="Redis#编辑配置"></a> 编辑配置<a href="Redis#编辑配置"></a></h3><p>你可以通过修改 redis.conf 文件或使用 <strong>CONFIG set</strong> 命令来修改配置。</p><h5 id="语法-2"><a class="markdownIt-Anchor" href="Redis#语法-2"></a> 语法<a href="Redis#语法-2"></a></h5><p><strong>CONFIG SET</strong> 命令基本语法：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></div></figure><h4 id="实例-2"><a class="markdownIt-Anchor" href="Redis#实例-2"></a> 实例<a href="Redis#实例-2"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET loglevel</span><br><span class="line"></span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br></pre></td></tr></table></div></figure><h2 id="参数说明"><a class="markdownIt-Anchor" href="Redis#参数说明"></a> 参数说明<a href="Redis#参数说明"></a></h2><p>redis.conf 配置项说明如下：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">配置项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><code>daemonize no</code></td><td style="text-align:left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><code>pidfile /var/run/redis.pid</code></td><td style="text-align:left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>port 6379</code></td><td style="text-align:left">指定 Redis 监听端口，默认端口为 6379，作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><code>bind 127.0.0.1</code></td><td style="text-align:left">绑定的主机地址</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>timeout 300</code></td><td style="text-align:left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><code>loglevel notice</code></td><td style="text-align:left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><code>logfile stdout</code></td><td style="text-align:left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><code>databases 16</code></td><td style="text-align:left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><code>save &lt;seconds&gt; &lt;changes&gt;</code>Redis 默认配置文件中提供了三个条件：<strong>save 900 1   save 300 10   save 60 10000</strong>分别表示 900 秒（15 分钟）内有 1 个更改，300ß 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td><td style="text-align:left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><code>rdbcompression yes</code></td><td style="text-align:left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><code>dbfilename dump.rdb</code></td><td style="text-align:left">指定本地数据库文件名，默认值为 dump.rdb</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><code>dir ./</code></td><td style="text-align:left">指定本地数据库存放目录</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></td><td style="text-align:left">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><code>masterauth &lt;master-password&gt;</code></td><td style="text-align:left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><code>requirepass foobared</code></td><td style="text-align:left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</password></td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><code>maxclients 128</code></td><td style="text-align:left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><code>maxmemory &lt;bytes&gt;</code></td><td style="text-align:left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><code>appendonly no</code></td><td style="text-align:left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><code>appendfilename appendonly.aof</code></td><td style="text-align:left">指定更新日志文件名，默认为 appendonly.aof</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left"><code>appendfsync everysec</code></td><td style="text-align:left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left"><code>vm-enabled no</code></td><td style="text-align:left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left"><code>vm-swap-file /tmp/redis.swap</code></td><td style="text-align:left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left"><code>vm-max-memory 0</code></td><td style="text-align:left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td></tr><tr><td style="text-align:left">24</td><td style="text-align:left"><code>vm-page-size 32</code></td><td style="text-align:left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td></tr><tr><td style="text-align:left">25</td><td style="text-align:left"><code>vm-pages 134217728</code></td><td style="text-align:left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td></tr><tr><td style="text-align:left">26</td><td style="text-align:left"><code>vm-max-threads 4</code></td><td style="text-align:left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td></tr><tr><td style="text-align:left">27</td><td style="text-align:left"><code>glueoutputbuf yes</code></td><td style="text-align:left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td></tr><tr><td style="text-align:left">28</td><td style="text-align:left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td><td style="text-align:left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td></tr><tr><td style="text-align:left">29</td><td style="text-align:left"><code>activerehashing yes</code></td><td style="text-align:left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td></tr><tr><td style="text-align:left">30</td><td style="text-align:left"><code>include /path/to/local.conf</code></td><td style="text-align:left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td></tr></tbody></table></div></div><h2 id="redis-数据类型"><a class="markdownIt-Anchor" href="Redis#redis-数据类型"></a> Redis 数据类型<a href="Redis#redis-数据类型"></a></h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><h3 id="string字符串"><a class="markdownIt-Anchor" href="Redis#string字符串"></a> String（字符串）<a href="Redis#string字符串"></a></h3><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><h4 id="实例-3"><a class="markdownIt-Anchor" href="Redis#实例-3"></a> 实例<a href="Redis#实例-3"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET runoob &quot;菜鸟教程&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET runoob</span><br><span class="line">&quot;菜鸟教程&quot;</span><br></pre></td></tr></table></div></figure><p>在以上实例中我们使用了 Redis 的 <strong>SET</strong> 和 <strong>GET</strong> 命令。键为 runoob，对应的值为 <strong>菜鸟教程</strong>。</p><p>**注意：**一个键最大能存储 512MB。</p><h3 id="hash哈希"><a class="markdownIt-Anchor" href="Redis#hash哈希"></a> Hash（哈希）<a href="Redis#hash哈希"></a></h3><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><h5 id="实例-4"><a class="markdownIt-Anchor" href="Redis#实例-4"></a> 实例<a href="Redis#实例-4"></a></h5><p><strong>DEL runoob</strong> 用于删除前面测试用过的 key，不然会报错：<strong>(error) WRONGTYPE Operation against a key holding the wrong kind of value</strong></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/B104156B-7270-4D03-8EB3-B72D4022ED78.jpg" alt="img" class="article-img"></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEL runoob</span><br><span class="line">redis 127.0.0.1:6379&gt; HMSET runoob field1 &quot;Hello&quot; field2 &quot;World&quot;</span><br><span class="line">&quot;OK&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HGET runoob field1</span><br><span class="line">&quot;Hello&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt; HGET runoob field2</span><br><span class="line">&quot;World&quot;</span><br></pre></td></tr></table></div></figure><p>实例中我们使用了 Redis <strong>HMSET, HGET</strong> 命令，<strong>HMSET</strong> 设置了两个 <strong>field=&gt;value</strong> 对, HGET 获取对应 <strong>field</strong> 对应的 <strong>value</strong>。</p><p>每个 hash 可以存储 2^32 -1 键值对（40多亿）。</p><h3 id="list列表"><a class="markdownIt-Anchor" href="Redis#list列表"></a> List（列表）<a href="Redis#list列表"></a></h3><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><h5 id="实例-5"><a class="markdownIt-Anchor" href="Redis#实例-5"></a> 实例<a href="Redis#实例-5"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEL runoob</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush runoob redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush runoob mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; lpush runoob rabitmq</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; lrange runoob 0 10</span><br><span class="line">1) &quot;rabitmq&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br><span class="line">redis 127.0.0.1:6379&gt;</span><br></pre></td></tr></table></div></figure><p>列表最多可存储 2^32 - 1 元素 (4294967295, 每个列表可存储40多亿)。</p><h3 id="set集合"><a class="markdownIt-Anchor" href="Redis#set集合"></a> Set（集合）<a href="Redis#set集合"></a></h3><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p><h5 id="sadd-命令"><a class="markdownIt-Anchor" href="Redis#sadd-命令"></a> sadd 命令<a href="Redis#sadd-命令"></a></h5><p>添加一个 string 元素到 key 对应的 set 集合中，成功返回 1，如果元素已经在集合中返回 0。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sadd key member</span><br></pre></td></tr></table></div></figure><h5 id="实例-6"><a class="markdownIt-Anchor" href="Redis#实例-6"></a> 实例<a href="Redis#实例-6"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEL runoob</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd runoob redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd runoob mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd runoob rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; sadd runoob rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; smembers runoob</span><br><span class="line"></span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;rabitmq&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br></pre></td></tr></table></div></figure><p>**注意：**以上实例中 rabitmq 添加了两次，但根据集合内元素的唯一性，第二次插入的元素将被忽略。</p><p>集合中最大的成员数为 232 - 1(4294967295, 每个集合可存储40多亿个成员)。</p><h3 id="zsetsorted-set有序集合"><a class="markdownIt-Anchor" href="Redis#zsetsorted-set有序集合"></a> zset(sorted set：有序集合)<a href="Redis#zsetsorted-set有序集合"></a></h3><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p><h5 id="zadd-命令"><a class="markdownIt-Anchor" href="Redis#zadd-命令"></a> zadd 命令<a href="Redis#zadd-命令"></a></h5><p>添加元素到集合，元素在集合中存在则更新对应score</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zadd key score member</span><br></pre></td></tr></table></div></figure><h5 id="实例-7"><a class="markdownIt-Anchor" href="Redis#实例-7"></a> 实例<a href="Redis#实例-7"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; DEL runoob</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; zadd runoob 0 rabitmq</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; &gt; ZRANGEBYSCORE runoob 0 1000</span><br><span class="line">1) &quot;mongodb&quot;</span><br><span class="line">2) &quot;rabitmq&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></div></figure><h3 id="各个数据类型应用场景"><a class="markdownIt-Anchor" href="Redis#各个数据类型应用场景"></a> 各个数据类型应用场景<a href="Redis#各个数据类型应用场景"></a></h3><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">简介</th><th style="text-align:left">特性</th><th style="text-align:left">场景</th></tr></thead><tbody><tr><td style="text-align:left">String(字符串)</td><td style="text-align:left">二进制安全</td><td style="text-align:left">可以包含任何数据,比如jpg图片或者序列化的对象,一个键最大能存储512M</td><td style="text-align:left">—</td></tr><tr><td style="text-align:left">Hash(字典)</td><td style="text-align:left">键值对集合,即编程语言中的Map类型</td><td style="text-align:left">适合存储对象,并且可以像数据库中update一个属性一样只修改某一项属性值(Memcached中需要取出整个字符串反序列化成对象修改完再序列化存回去)</td><td style="text-align:left">存储、读取、修改用户属性</td></tr><tr><td style="text-align:left">List(列表)</td><td style="text-align:left">链表(双向链表)</td><td style="text-align:left">增删快,提供了操作某一段元素的API</td><td style="text-align:left">1,最新消息排行等功能(比如朋友圈的时间线) 2,消息队列</td></tr><tr><td style="text-align:left">Set(集合)</td><td style="text-align:left">哈希表实现,元素不重复</td><td style="text-align:left">1、添加、删除,查找的复杂度都是O(1) 2、为集合提供了求交集、并集、差集等操作</td><td style="text-align:left">1、共同好友 2、利用唯一性,统计访问网站的所有独立ip 3、好友推荐时,根据tag求交集,大于某个阈值就可以推荐</td></tr><tr><td style="text-align:left">Sorted Set(有序集合)</td><td style="text-align:left">将Set中的元素增加一个权重参数score,元素按score有序排列</td><td style="text-align:left">数据插入集合时,已经进行天然排序</td><td style="text-align:left">1、排行榜 2、带权重的消息队列</td></tr></tbody></table></div></div><h2 id="redis命令"><a class="markdownIt-Anchor" href="Redis#redis命令"></a> Redis命令<a href="Redis#redis命令"></a></h2><h3 id="客户端命令"><a class="markdownIt-Anchor" href="Redis#客户端命令"></a> 客户端命令<a href="Redis#客户端命令"></a></h3><ul><li>启动客户端<code>redis-cli --raw</code><ul><li><code>--raw</code>用于防止中文乱码</li></ul></li></ul><h5 id="远程服务"><a class="markdownIt-Anchor" href="Redis#远程服务"></a> 远程服务<a href="Redis#远程服务"></a></h5><ul><li><code>redis-cli -h host -p port -a password</code></li></ul><h3 id="键命令"><a class="markdownIt-Anchor" href="Redis#键命令"></a> 键命令<a href="Redis#键命令"></a></h3><h5 id="语法-3"><a class="markdownIt-Anchor" href="Redis#语法-3"></a> 语法<a href="Redis#语法-3"></a></h5><p>Redis 键命令的基本语法如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></div></figure><h5 id="实例-8"><a class="markdownIt-Anchor" href="Redis#实例-8"></a> 实例<a href="Redis#实例-8"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET runoobkey redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; DEL runoobkey</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></div></figure><p>在以上实例中 <strong>DEL</strong> 是一个命令， <strong>runoobkey</strong> 是一个键。 如果键被删除成功，命令执行后输出 <strong>(integer) 1</strong>，否则将输出 <strong>(integer) 0</strong></p><p>下表给出了与 Redis 键相关的基本命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-del.html" target="_blank" rel="noopener">DEL key</a> 该命令用于在 key 存在时删除 key。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-dump.html" target="_blank" rel="noopener">DUMP key</a> 序列化给定 key ，并返回被序列化的值。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-exists.html" target="_blank" rel="noopener">EXISTS key</a> 检查给定 key 是否存在。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-expire.html" target="_blank" rel="noopener">EXPIRE key</a> seconds 为给定 key 设置过期时间，以秒计。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-expireat.html" target="_blank" rel="noopener">EXPIREAT key timestamp</a> EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-pexpire.html" target="_blank" rel="noopener">PEXPIRE key milliseconds</a> 设置 key 的过期时间以毫秒计。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-pexpireat.html" target="_blank" rel="noopener">PEXPIREAT key milliseconds-timestamp</a> 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-keys.html" target="_blank" rel="noopener">KEYS pattern</a> 查找所有符合给定模式( pattern)的 key 。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/redis/keys-move.html" target="_blank" rel="noopener">MOVE key db</a> 将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr></tbody></table></div></div><h3 id="字符串命令"><a class="markdownIt-Anchor" href="Redis#字符串命令"></a> 字符串命令<a href="Redis#字符串命令"></a></h3><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p><h4 id="语法-4"><a class="markdownIt-Anchor" href="Redis#语法-4"></a> 语法<a href="Redis#语法-4"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</span><br></pre></td></tr></table></div></figure><h4 id="实例-9"><a class="markdownIt-Anchor" href="Redis#实例-9"></a> 实例<a href="Redis#实例-9"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SET runoobkey redis</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; GET runoobkey</span><br><span class="line">&quot;redis&quot;</span><br></pre></td></tr></table></div></figure><p>在以上实例中我们使用了 <strong>SET</strong> 和 <strong>GET</strong> 命令，键为 <strong>runoobkey</strong>。</p><p>下表列出了常用的 redis 字符串命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-set.html" target="_blank" rel="noopener">SET key value</a> 设置指定 key 的值</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-get.html" target="_blank" rel="noopener">GET key</a> 获取指定 key 的值。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-getrange.html" target="_blank" rel="noopener">GETRANGE key start end</a> 返回 key 中字符串值的子字符</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-getset.html" target="_blank" rel="noopener">GETSET key value</a> 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-getbit.html" target="_blank" rel="noopener">GETBIT key offset</a> 对 key 所储存的字符串值，获取指定偏移量上的位(bit)。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">[MGET key1 <a href="https://www.runoob.com/redis/strings-mget.html" target="_blank" rel="noopener">key2…]</a> 获取所有(一个或多个)给定 key 的值。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-setbit.html" target="_blank" rel="noopener">SETBIT key offset value</a> 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-setex.html" target="_blank" rel="noopener">SETEX key seconds value</a> 将值 value 关联到 key ，并将 key 的过期时间设为 seconds (以秒为单位)。</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-setnx.html" target="_blank" rel="noopener">SETNX key value</a> 只有在 key 不存在时设置 key 的值。</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-setrange.html" target="_blank" rel="noopener">SETRANGE key offset value</a> 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-strlen.html" target="_blank" rel="noopener">STRLEN key</a> 返回 key 所储存的字符串值的长度。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">[MSET key value <a href="https://www.runoob.com/redis/strings-mset.html" target="_blank" rel="noopener">key value …]</a> 同时设置一个或多个 key-value 对。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>MSETNX key value \[key value ...\]</code>同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-psetex.html" target="_blank" rel="noopener">PSETEX key milliseconds value</a> 这个命令和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，而不是像 SETEX 命令那样，以秒为单位。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-incr.html" target="_blank" rel="noopener">INCR key</a> 将 key 中储存的数字值增一。</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-incrby.html" target="_blank" rel="noopener">INCRBY key increment</a> 将 key 所储存的值加上给定的增量值（increment） 。</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-incrbyfloat.html" target="_blank" rel="noopener">INCRBYFLOAT key increment</a> 将 key 所储存的值加上给定的浮点增量值（increment） 。</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-decr.html" target="_blank" rel="noopener">DECR key</a> 将 key 中储存的数字值减一。</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-decrby.html" target="_blank" rel="noopener">DECRBY key decrement</a> key 所储存的值减去给定的减量值（decrement） 。</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left"><a href="https://www.runoob.com/redis/strings-append.html" target="_blank" rel="noopener">APPEND key value</a> 如果 key 已经存在并且是一个字符串， APPEND 命令将指定的 value 追加到该 key 原来值（value）的末尾。</td></tr></tbody></table></div></div><h3 id="哈希命令"><a class="markdownIt-Anchor" href="Redis#哈希命令"></a> 哈希命令<a href="Redis#哈希命令"></a></h3><p>Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。</p><p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p><h5 id="实例-10"><a class="markdownIt-Anchor" href="Redis#实例-10"></a> 实例<a href="Redis#实例-10"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt;  HMSET runoobkey name &quot;redis tutorial&quot; description &quot;redis basic commands for caching&quot; likes 20 visitors 23000</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;  HGETALL runoobkey</span><br><span class="line">1) &quot;name&quot;</span><br><span class="line">2) &quot;redis tutorial&quot;</span><br><span class="line">3) &quot;description&quot;</span><br><span class="line">4) &quot;redis basic commands for caching&quot;</span><br><span class="line">5) &quot;likes&quot;</span><br><span class="line">6) &quot;20&quot;</span><br><span class="line">7) &quot;visitors&quot;</span><br><span class="line">8) &quot;23000&quot;</span><br></pre></td></tr></table></div></figure><p>在以上实例中，我们设置了 redis 的一些描述信息(name, description, likes, visitors) 到哈希表的 <strong>runoobkey</strong> 中。</p><p>下表列出了 redis hash 基本的相关命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">[HDEL key field1 <a href="https://www.runoob.com/redis/hashes-hdel.html" target="_blank" rel="noopener">field2]</a> 删除一个或多个哈希表字段</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hexists.html" target="_blank" rel="noopener">HEXISTS key field</a> 查看哈希表 key 中，指定的字段是否存在。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hget.html" target="_blank" rel="noopener">HGET key field</a> 获取存储在哈希表中指定字段的值。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hgetall.html" target="_blank" rel="noopener">HGETALL key</a> 获取在哈希表中指定 key 的所有字段和值</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hincrby.html" target="_blank" rel="noopener">HINCRBY key field increment</a> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hincrbyfloat.html" target="_blank" rel="noopener">HINCRBYFLOAT key field increment</a> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hkeys.html" target="_blank" rel="noopener">HKEYS key</a> 获取所有哈希表中的字段</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hlen.html" target="_blank" rel="noopener">HLEN key</a> 获取哈希表中字段的数量</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">[HMGET key field1 <a href="https://www.runoob.com/redis/hashes-hmget.html" target="_blank" rel="noopener">field2]</a> 获取所有给定字段的值</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">[HMSET key field1 value1 <a href="https://www.runoob.com/redis/hashes-hmset.html" target="_blank" rel="noopener">field2 value2 ]</a> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hset.html" target="_blank" rel="noopener">HSET key field value</a> 将哈希表 key 中的字段 field 的值设为 value 。</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hsetnx.html" target="_blank" rel="noopener">HSETNX key field value</a> 只有在字段 field 不存在时，设置哈希表字段的值。</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hashes-hvals.html" target="_blank" rel="noopener">HVALS key</a> 获取哈希表中所有值。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">[HSCAN key cursor <a href="https://www.runoob.com/redis/hashes-hscan.html" target="_blank" rel="noopener">MATCH pattern] [COUNT count]</a> 迭代哈希表中的键值对。</td></tr></tbody></table></div></div><h3 id="列表命令"><a class="markdownIt-Anchor" href="Redis#列表命令"></a> 列表命令<a href="Redis#列表命令"></a></h3><p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）</p><p>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><h5 id="实例-11"><a class="markdownIt-Anchor" href="Redis#实例-11"></a> 实例<a href="Redis#实例-11"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey mongodb</span><br><span class="line">(integer) 2</span><br><span class="line">redis 127.0.0.1:6379&gt; LPUSH runoobkey mysql</span><br><span class="line">(integer) 3</span><br><span class="line">redis 127.0.0.1:6379&gt; LRANGE runoobkey 0 10</span><br><span class="line"></span><br><span class="line">1) &quot;mysql&quot;</span><br><span class="line">2) &quot;mongodb&quot;</span><br><span class="line">3) &quot;redis&quot;</span><br></pre></td></tr></table></div></figure><p>在以上实例中我们使用了 <strong>LPUSH</strong> 将三个值插入了名为 <strong>runoobkey</strong> 的列表当中。</p><p>下表列出了列表相关的基本命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">[BLPOP key1 <a href="https://www.runoob.com/redis/lists-blpop.html" target="_blank" rel="noopener">key2 ] timeout</a> 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">[BRPOP key1 <a href="https://www.runoob.com/redis/lists-brpop.html" target="_blank" rel="noopener">key2 ] timeout</a> 移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-brpoplpush.html" target="_blank" rel="noopener">BRPOPLPUSH source destination timeout</a> 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-lindex.html" target="_blank" rel="noopener">LINDEX key index</a> 通过索引获取列表中的元素</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-linsert.html" target="_blank" rel="noopener">LINSERT key BEFORE|AFTER pivot value</a> 在列表的元素前或者后插入元素</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-llen.html" target="_blank" rel="noopener">LLEN key</a> 获取列表长度</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-lpop.html" target="_blank" rel="noopener">LPOP key</a> 移出并获取列表的第一个元素</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-lpush.html" target="_blank" rel="noopener">LPUSH key value1 value2]</a> 将一个或多个值插入到列表头部</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-lpushx.html" target="_blank" rel="noopener">LPUSHX key value</a> 将一个值插入到已存在的列表头部</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-lrange.html" target="_blank" rel="noopener">LRANGE key start stop</a> 获取列表指定范围内的元素</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-lrem.html" target="_blank" rel="noopener">LREM key count value</a> 移除列表元素</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-lset.html" target="_blank" rel="noopener">LSET key index value</a> 通过索引设置列表元素的值</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-ltrim.html" target="_blank" rel="noopener">LTRIM key start stop</a> 对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-rpop.html" target="_blank" rel="noopener">RPOP key</a> 移除列表的最后一个元素，返回值为移除的元素。</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-rpoplpush.html" target="_blank" rel="noopener">RPOPLPUSH source destination</a> 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left">[RPUSH key value1 <a href="https://www.runoob.com/redis/lists-rpush.html" target="_blank" rel="noopener">value2]</a> 在列表中添加一个或多个值</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><a href="https://www.runoob.com/redis/lists-rpushx.html" target="_blank" rel="noopener">RPUSHX key value</a> 为已存在的列表添加值</td></tr></tbody></table></div></div><h3 id="集合命令"><a class="markdownIt-Anchor" href="Redis#集合命令"></a> 集合命令<a href="Redis#集合命令"></a></h3><p>Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p><p>Redis 中集合是通过哈希表实现的</p><p>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><h5 id="实例-12"><a class="markdownIt-Anchor" href="Redis#实例-12"></a> 实例<a href="Redis#实例-12"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; SADD runoobkey mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS runoobkey</span><br><span class="line"></span><br><span class="line">1) "mysql"</span><br><span class="line">2) "mongodb"</span><br><span class="line">3) "redis"</span><br></pre></td></tr></table></div></figure><p>在以上实例中我们通过 <strong>SADD</strong> 命令向名为 <strong>runoobkey</strong> 的集合插入的三个元素。</p><p>下表列出了 Redis 集合基本命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">[SADD key member1 <a href="https://www.runoob.com/redis/sets-sadd.html" target="_blank" rel="noopener">member2]</a> 向集合添加一个或多个成员</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sets-scard.html" target="_blank" rel="noopener">SCARD key</a> 获取集合的成员数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">[SDIFF key1 <a href="https://www.runoob.com/redis/sets-sdiff.html" target="_blank" rel="noopener">key2]</a> 返回给定所有集合的差集</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">[SDIFFSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sdiffstore.html" target="_blank" rel="noopener">key2]</a> 返回给定所有集合的差集并存储在 destination 中</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">[SINTER key1 <a href="https://www.runoob.com/redis/sets-sinter.html" target="_blank" rel="noopener">key2]</a> 返回给定所有集合的交集</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">[SINTERSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sinterstore.html" target="_blank" rel="noopener">key2]</a> 返回给定所有集合的交集并存储在 destination 中</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sets-sismember.html" target="_blank" rel="noopener">SISMEMBER key member</a> 判断 member 元素是否是集合 key 的成员</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sets-smembers.html" target="_blank" rel="noopener">SMEMBERS key</a> 返回集合中的所有成员</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sets-smove.html" target="_blank" rel="noopener">SMOVE source destination member</a> 将 member 元素从 source 集合移动到 destination 集合</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sets-spop.html" target="_blank" rel="noopener">SPOP key</a> 移除并返回集合中的一个随机元素</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">[SRANDMEMBER key <a href="https://www.runoob.com/redis/sets-srandmember.html" target="_blank" rel="noopener">count]</a> 返回集合中一个或多个随机数</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">[SREM key member1 <a href="https://www.runoob.com/redis/sets-srem.html" target="_blank" rel="noopener">member2]</a> 移除集合中一个或多个成员</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">[SUNION key1 <a href="https://www.runoob.com/redis/sets-sunion.html" target="_blank" rel="noopener">key2]</a> 返回所有给定集合的并集</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">[SUNIONSTORE destination key1 <a href="https://www.runoob.com/redis/sets-sunionstore.html" target="_blank" rel="noopener">key2]</a> 所有给定集合的并集存储在 destination 集合中</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">[SSCAN key cursor <a href="https://www.runoob.com/redis/sets-sscan.html" target="_blank" rel="noopener">MATCH pattern] [COUNT count]</a> 迭代集合中的元素</td></tr></tbody></table></div></div><h3 id="有序集合"><a class="markdownIt-Anchor" href="Redis#有序集合"></a> 有序集合<a href="Redis#有序集合"></a></h3><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><h5 id="tips"><a class="markdownIt-Anchor" href="Redis#tips"></a> tips<a href="Redis#tips"></a></h5><p>在redis sorted sets里面当<strong>items内容大于64的时候</strong>同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知：</p><ul><li><strong>添加和删除</strong>都需要修改skiplist，所以复杂度为<strong>O(log(n))</strong>。</li><li>但是如果仅仅是<strong>查找</strong>元素的话可以直接使用hash，其复杂度为<strong>O(1)</strong></li><li>其他的<strong>range操作</strong>复杂度一般为<strong>O(log(n))</strong></li><li>当然如果是<strong>小于64的时候</strong>，因为是采用了ziplist的设计，其时间复杂度为<strong>O(n)</strong></li></ul><h5 id="实例-13"><a class="markdownIt-Anchor" href="Redis#实例-13"></a> 实例<a href="Redis#实例-13"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 1 redis</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 2 mongodb</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 1</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 3 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZADD runoobkey 4 mysql</span><br><span class="line">(integer) 0</span><br><span class="line">redis 127.0.0.1:6379&gt; ZRANGE runoobkey 0 10 WITHSCORES</span><br><span class="line"></span><br><span class="line">1) &quot;redis&quot;</span><br><span class="line">2) &quot;1&quot;</span><br><span class="line">3) &quot;mongodb&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;mysql&quot;</span><br><span class="line">6) &quot;4&quot;</span><br></pre></td></tr></table></div></figure><p>在以上实例中我们通过命令 <strong>ZADD</strong> 向 redis 的有序集合中添加了三个值并关联上分数。</p><p>下表列出了 redis 有序集合的基本命令:</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">[ZADD key score1 member1 <a href="https://www.runoob.com/redis/sorted-sets-zadd.html" target="_blank" rel="noopener">score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zcard.html" target="_blank" rel="noopener">ZCARD key</a> 获取有序集合的成员数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zcount.html" target="_blank" rel="noopener">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zincrby.html" target="_blank" rel="noopener">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">[ZINTERSTORE destination numkeys key <a href="https://www.runoob.com/redis/sorted-sets-zinterstore.html" target="_blank" rel="noopener">key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zlexcount.html" target="_blank" rel="noopener">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">[ZRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrange.html" target="_blank" rel="noopener">WITHSCORES]</a> 通过索引区间返回有序集合指定区间内的成员</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">[ZRANGEBYLEX key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebylex.html" target="_blank" rel="noopener">LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">[ZRANGEBYSCORE key min max <a href="https://www.runoob.com/redis/sorted-sets-zrangebyscore.html" target="_blank" rel="noopener">WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zrank.html" target="_blank" rel="noopener">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">[ZREM key member <a href="https://www.runoob.com/redis/sorted-sets-zrem.html" target="_blank" rel="noopener">member …]</a> 移除有序集合中的一个或多个成员</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebylex.html" target="_blank" rel="noopener">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyrank.html" target="_blank" rel="noopener">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zremrangebyscore.html" target="_blank" rel="noopener">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">[ZREVRANGE key start stop <a href="https://www.runoob.com/redis/sorted-sets-zrevrange.html" target="_blank" rel="noopener">WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><code>ZREVRANGEBYSCORE key max min \[WITHSCORES\]</code>返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zrevrank.html" target="_blank" rel="noopener">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><a href="https://www.runoob.com/redis/sorted-sets-zscore.html" target="_blank" rel="noopener">ZSCORE key member</a> 返回有序集中，成员的分数值</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><code>ZUNIONSTORE destination numkeys key \[key ...\]</code>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left">[ZSCAN key cursor <a href="https://www.runoob.com/redis/sorted-sets-zscan.html" target="_blank" rel="noopener">MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table></div></div><h3 id="hyperloglog"><a class="markdownIt-Anchor" href="Redis#hyperloglog"></a> HyperLogLog<a href="Redis#hyperloglog"></a></h3><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><h5 id="什么是基数"><a class="markdownIt-Anchor" href="Redis#什么是基数"></a> 什么是基数?<a href="Redis#什么是基数"></a></h5><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><h5 id="实例-14"><a class="markdownIt-Anchor" href="Redis#实例-14"></a> 实例<a href="Redis#实例-14"></a></h5><p>以下实例演示了 HyperLogLog 的工作过程：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PFADD runoobkey "redis"</span><br><span class="line">1) (integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD runoobkey "mongodb"</span><br><span class="line">1) (integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PFADD runoobkey "mysql"</span><br><span class="line">1) (integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PFCOUNT runoobkey</span><br><span class="line">(integer) 3</span><br></pre></td></tr></table></div></figure><p>下表列出了 redis HyperLogLog 的基本命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/redis/hyperloglog-pfadd.html" target="_blank" rel="noopener">PFADD key element element …</a> 添加指定元素到 HyperLogLog 中。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">[PFCOUNT key <a href="https://www.runoob.com/redis/hyperloglog-pfcount.html" target="_blank" rel="noopener">key …]</a> 返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">[PFMERGE destkey sourcekey <a href="https://www.runoob.com/redis/hyperloglog-pfmerge.html" target="_blank" rel="noopener">sourcekey …]</a> 将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table></div></div><h3 id="发布订阅"><a class="markdownIt-Anchor" href="Redis#发布订阅"></a> 发布订阅<a href="Redis#发布订阅"></a></h3><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p><p>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub1.png" alt="img" class="article-img"></p><p>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/11/pubsub2.png" alt="img" class="article-img"></p><h5 id="实例-15"><a class="markdownIt-Anchor" href="Redis#实例-15"></a> 实例<a href="Redis#实例-15"></a></h5><p>以下实例演示了发布订阅是如何工作的。在我们实例中我们创建了订阅频道名为 <strong>redisChat</strong>:</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat</span><br><span class="line"></span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) "subscribe"</span><br><span class="line">2) "redisChat"</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></div></figure><p>现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat "Redis is a great caching technique"</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; PUBLISH redisChat "Learn redis by runoob.com"</span><br><span class="line"></span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 订阅者的客户端会显示如下消息</span></span><br><span class="line">1) "message"</span><br><span class="line">2) "redisChat"</span><br><span class="line">3) "Redis is a great caching technique"</span><br><span class="line">1) "message"</span><br><span class="line">2) "redisChat"</span><br><span class="line">3) "Learn redis by runoob.com"</span><br></pre></td></tr></table></div></figure><p>下表列出了 redis 发布订阅常用命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">PSUBSCRIBE pattern [pattern …]订阅一个或多个符合给定模式的频道。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">[PUBSUB subcommand <a href="https://www.runoob.com/redis/pub-sub-pubsub.html" target="_blank" rel="noopener">argument [argument …]]</a> 查看订阅与发布系统状态。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/pub-sub-publish.html" target="_blank" rel="noopener">PUBLISH channel message</a> 将信息发送到指定的频道。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">[PUNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-punsubscribe.html" target="_blank" rel="noopener">pattern [pattern …]]</a> 退订所有给定模式的频道。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">SUBSCRIBE channel [channel …]订阅给定的一个或多个频道的信息。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">[UNSUBSCRIBE <a href="https://www.runoob.com/redis/pub-sub-unsubscribe.html" target="_blank" rel="noopener">channel [channel …]]</a> 退订给定的频道。</td></tr></tbody></table></div></div><h3 id="事务"><a class="markdownIt-Anchor" href="Redis#事务"></a> 事务<a href="Redis#事务"></a></h3><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量操作在发送 EXEC 命令前被放入队列缓存。</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul><p>一个事务从开始到执行会经历以下三个阶段：</p><ul><li>开始事务。</li><li>命令入队。</li><li>执行事务。</li></ul><h5 id="实例-16"><a class="markdownIt-Anchor" href="Redis#实例-16"></a> 实例<a href="Redis#实例-16"></a></h5><p>以下是一个事务的例子， 它先以 <strong>MULTI</strong> 开始一个事务， 然后将多个命令入队到事务中， 最后由 <strong>EXEC</strong> 命令触发事务， 一并执行事务中的所有命令：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SET book-name &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; GET book-name</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SADD tag &quot;C++&quot; &quot;Programming&quot; &quot;Mastering Series&quot;</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; SMEMBERS tag</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis 127.0.0.1:6379&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Mastering C++ in 21 days&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">4) 1) &quot;Mastering Series&quot;</span><br><span class="line">   2) &quot;C++&quot;</span><br><span class="line">   3) &quot;Programming&quot;</span><br></pre></td></tr></table></div></figure><p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p><p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p><blockquote><p><strong>这是官网上的说明 From redis docs on <a href="http://redis.io/topics/transactions" target="_blank" rel="noopener">transactions</a>:</strong></p><p>It’s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands.</p></blockquote><p>比如：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:7000&gt; multi</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:7000&gt; set a aaa</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; set b bbb</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; set c ccc</span><br><span class="line">QUEUED</span><br><span class="line">redis 127.0.0.1:7000&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br></pre></td></tr></table></div></figure><p>如果在 set b bbb 处失败，set a 已成功不会回滚，set c 还会继续执行。</p><h5 id="redis-事务命令"><a class="markdownIt-Anchor" href="Redis#redis-事务命令"></a> Redis 事务命令<a href="Redis#redis-事务命令"></a></h5><p>下表列出了 redis 事务的相关命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/redis/transactions-discard.html" target="_blank" rel="noopener">DISCARD</a> 取消事务，放弃执行事务块内的所有命令。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/transactions-exec.html" target="_blank" rel="noopener">EXEC</a> 执行所有事务块内的命令。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/transactions-multi.html" target="_blank" rel="noopener">MULTI</a> 标记一个事务块的开始。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/transactions-unwatch.html" target="_blank" rel="noopener">UNWATCH</a> 取消 WATCH 命令对所有 key 的监视。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><code>WATCH key \[key ...\]</code> 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr></tbody></table></div></div><h3 id="脚本"><a class="markdownIt-Anchor" href="Redis#脚本"></a> 脚本<a href="Redis#脚本"></a></h3><p>Redis 脚本使用 Lua 解释器来执行脚本。 Redis 2.6 版本通过内嵌支持 Lua 环境。执行脚本的常用命令为 <strong>EVAL</strong>。</p><h5 id="语法-5"><a class="markdownIt-Anchor" href="Redis#语法-5"></a> 语法<a href="Redis#语法-5"></a></h5><p>Eval 命令的基本语法如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL script numkeys key [key ...] arg [arg ...]</span><br></pre></td></tr></table></div></figure><h5 id="实例-17"><a class="markdownIt-Anchor" href="Redis#实例-17"></a> 实例<a href="Redis#实例-17"></a></h5><p>以下实例演示了 redis 脚本工作过程：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; EVAL &quot;return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;&quot; 2 key1 key2 first second</span><br><span class="line"></span><br><span class="line">1) &quot;key1&quot;</span><br><span class="line">2) &quot;key2&quot;</span><br><span class="line">3) &quot;first&quot;</span><br><span class="line">4) &quot;second&quot;</span><br></pre></td></tr></table></div></figure><h5 id="redis-脚本命令"><a class="markdownIt-Anchor" href="Redis#redis-脚本命令"></a> Redis 脚本命令<a href="Redis#redis-脚本命令"></a></h5><p>下表列出了 redis 脚本常用命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">[EVAL script numkeys key <a href="https://www.runoob.com/redis/scripting-eval.html" target="_blank" rel="noopener">key …] arg [arg …]</a> 执行 Lua 脚本。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">[EVALSHA sha1 numkeys key <a href="https://www.runoob.com/redis/scripting-evalsha.html" target="_blank" rel="noopener">key …] arg [arg …]</a> 执行 Lua 脚本。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><code>SCRIPT EXISTS script \[script ...\]</code>查看指定的脚本是否已经被保存在缓存当中。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/scripting-script-flush.html" target="_blank" rel="noopener">SCRIPT FLUSH</a> 从脚本缓存中移除所有脚本。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/redis/scripting-script-kill.html" target="_blank" rel="noopener">SCRIPT KILL</a> 杀死当前正在运行的 Lua 脚本。</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/redis/scripting-script-load.html" target="_blank" rel="noopener">SCRIPT LOAD script</a> 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td></tr></tbody></table></div></div><h3 id="连接"><a class="markdownIt-Anchor" href="Redis#连接"></a> 连接<a href="Redis#连接"></a></h3><p>Redis 连接命令主要是用于连接 redis 服务。</p><h5 id="实例-18"><a class="markdownIt-Anchor" href="Redis#实例-18"></a> 实例<a href="Redis#实例-18"></a></h5><p>以下实例演示了客户端如何通过密码验证连接到 redis 服务，并检测服务是否在运行：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; AUTH &quot;password&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; PING</span><br><span class="line">PONG</span><br></pre></td></tr></table></div></figure><h5 id="redis-连接命令"><a class="markdownIt-Anchor" href="Redis#redis-连接命令"></a> Redis 连接命令<a href="Redis#redis-连接命令"></a></h5><p>下表列出了 redis 连接的基本命令：</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/redis/connection-auth.html" target="_blank" rel="noopener">AUTH password</a> 验证密码是否正确</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/connection-echo.html" target="_blank" rel="noopener">ECHO message</a> 打印字符串</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.runoob.com/redis/connection-ping.html" target="_blank" rel="noopener">PING</a> 查看服务是否运行</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/connection-quit.html" target="_blank" rel="noopener">QUIT</a> 关闭当前连接</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/redis/connection-select.html" target="_blank" rel="noopener">SELECT index</a> 切换到指定的数据库</td></tr></tbody></table></div></div><h3 id="服务器"><a class="markdownIt-Anchor" href="Redis#服务器"></a> 服务器<a href="Redis#服务器"></a></h3><p>Redis 服务器命令主要是用于管理 redis 服务。</p><h5 id="实例-19"><a class="markdownIt-Anchor" href="Redis#实例-19"></a> 实例<a href="Redis#实例-19"></a></h5><p>以下实例演示了如何获取 redis 服务器的统计信息：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; INFO</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Server</span></span><br><span class="line">redis_version:2.8.13</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:c2238b38b1edb0e2</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Linux 3.5.0-48-generic x86_64</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">gcc_version:4.7.2</span><br><span class="line">process_id:3856</span><br><span class="line">run_id:0e61abd297771de3fe812a3c21027732ac9f41fe</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:11554</span><br><span class="line">uptime_in_days:0</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:16651447</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client-longest_output_list:0</span><br><span class="line">client-biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Memory</span></span><br><span class="line">used_memory:589016</span><br><span class="line">used_memory_human:575.21K</span><br><span class="line">used_memory_rss:2461696</span><br><span class="line">used_memory_peak:667312</span><br><span class="line">used_memory_peak_human:651.67K</span><br><span class="line">used_memory_lua:33792</span><br><span class="line">mem_fragmentation_ratio:4.18</span><br><span class="line">mem_allocator:jemalloc-3.6.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:3</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1409158561</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:0</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Stats</span></span><br><span class="line">total_connections_received:24</span><br><span class="line">total_commands_processed:294</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:41</span><br><span class="line">keyspace_misses:82</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:264</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> CPU</span></span><br><span class="line">used_cpu_sys:10.49</span><br><span class="line">used_cpu_user:4.96</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.01</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Keyspace</span></span><br><span class="line">db0:keys=94,expires=1,avg_ttl=41638810</span><br><span class="line">db1:keys=1,expires=0,avg_ttl=0</span><br><span class="line">db3:keys=1,expires=0,avg_ttl=0</span><br></pre></td></tr></table></div></figure><h5 id="redis-服务器命令"><a class="markdownIt-Anchor" href="Redis#redis-服务器命令"></a> Redis 服务器命令<a href="Redis#redis-服务器命令"></a></h5><p>下表列出了 redis 服务器的相关命令:</p><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-bgrewriteaof.html" target="_blank" rel="noopener">BGREWRITEAOF</a> 异步执行一个 AOF（AppendOnly File） 文件重写操作</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-bgsave.html" target="_blank" rel="noopener">BGSAVE</a> 在后台异步保存当前数据库的数据到磁盘</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">[CLIENT KILL <a href="https://www.runoob.com/redis/server-client-kill.html" target="_blank" rel="noopener">ip:port] [ID client-id]</a> 关闭客户端连接</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-client-list.html" target="_blank" rel="noopener">CLIENT LIST</a> 获取连接到服务器的客户端连接列表</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-client-getname.html" target="_blank" rel="noopener">CLIENT GETNAME</a> 获取连接的名称</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-client-pause.html" target="_blank" rel="noopener">CLIENT PAUSE timeout</a> 在指定时间内终止运行来自客户端的命令</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-client-setname.html" target="_blank" rel="noopener">CLIENT SETNAME connection-name</a> 设置当前连接的名称</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-cluster-slots.html" target="_blank" rel="noopener">CLUSTER SLOTS</a> 获取集群节点的映射数组</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-command.html" target="_blank" rel="noopener">COMMAND</a> 获取 Redis 命令详情数组</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-command-count.html" target="_blank" rel="noopener">COMMAND COUNT</a> 获取 Redis 命令总数</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-command-getkeys.html" target="_blank" rel="noopener">COMMAND GETKEYS</a> 获取给定命令的所有键</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-time.html" target="_blank" rel="noopener">TIME</a> 返回当前服务器时间</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><code>COMMAND INFO command-name \[command-name ...\]</code>获取指定 Redis 命令描述的数组</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-config-get.html" target="_blank" rel="noopener">CONFIG GET parameter</a> 获取指定配置参数的值</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-config-rewrite.html" target="_blank" rel="noopener">CONFIG REWRITE</a> 对启动 Redis 服务器时所指定的 redis.conf 配置文件进行改写</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-config-set.html" target="_blank" rel="noopener">CONFIG SET parameter value</a> 修改 redis 配置参数，无需重启</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-config-resetstat.html" target="_blank" rel="noopener">CONFIG RESETSTAT</a> 重置 INFO 命令中的某些统计数据</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-dbsize.html" target="_blank" rel="noopener">DBSIZE</a> 返回当前数据库的 key 的数量</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-debug-object.html" target="_blank" rel="noopener">DEBUG OBJECT key</a> 获取 key 的调试信息</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-debug-segfault.html" target="_blank" rel="noopener">DEBUG SEGFAULT</a> 让 Redis 服务崩溃</td></tr><tr><td style="text-align:left">21</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-flushall.html" target="_blank" rel="noopener">FLUSHALL</a> 删除所有数据库的所有key</td></tr><tr><td style="text-align:left">22</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-flushdb.html" target="_blank" rel="noopener">FLUSHDB</a> 删除当前数据库的所有key</td></tr><tr><td style="text-align:left">23</td><td style="text-align:left"><code>INFO \[section\]</code>获取 Redis 服务器的各种信息和统计数值</td></tr><tr><td style="text-align:left">24</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-lastsave.html" target="_blank" rel="noopener">LASTSAVE</a> 返回最近一次 Redis 成功将数据保存到磁盘上的时间，以 UNIX 时间戳格式表示</td></tr><tr><td style="text-align:left">25</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-monitor.html" target="_blank" rel="noopener">MONITOR</a> 实时打印出 Redis 服务器接收到的命令，调试用</td></tr><tr><td style="text-align:left">26</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-role.html" target="_blank" rel="noopener">ROLE</a> 返回主从实例所属的角色</td></tr><tr><td style="text-align:left">27</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-save.html" target="_blank" rel="noopener">SAVE</a> 同步保存数据到硬盘</td></tr><tr><td style="text-align:left">28</td><td style="text-align:left">[SHUTDOWN <a href="https://www.runoob.com/redis/server-shutdown.html" target="_blank" rel="noopener">NOSAVE] [SAVE]</a> 异步保存数据到硬盘，并关闭服务器</td></tr><tr><td style="text-align:left">29</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-slaveof.html" target="_blank" rel="noopener">SLAVEOF host port</a> 将当前服务器转变为指定服务器的从属服务器(slave server)</td></tr><tr><td style="text-align:left">30</td><td style="text-align:left"><code>SLOWLOG subcommand \[argument\]</code> 管理 redis 的慢日志</td></tr><tr><td style="text-align:left">31</td><td style="text-align:left"><a href="https://www.runoob.com/redis/server-sync.html" target="_blank" rel="noopener">SYNC</a> 用于复制功能(replication)的内部命令</td></tr></tbody></table></div></div><h3 id="geo"><a class="markdownIt-Anchor" href="Redis#geo"></a> GEO<a href="Redis#geo"></a></h3><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p><p>Redis GEO 操作方法有：</p><ul><li>geoadd：添加地理位置的坐标。</li><li>geopos：获取地理位置的坐标。</li><li>geodist：计算两个位置之间的距离。</li><li>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li><li>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</li><li>geohash：返回一个或多个位置对象的 geohash 值。</li></ul><h5 id="geoadd"><a class="markdownIt-Anchor" href="Redis#geoadd"></a> geoadd<a href="Redis#geoadd"></a></h5><p>geoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</p><p>geoadd 语法格式如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></div></figure><p>以下实例中 key 为 Sicily、Catania 为位置名称 ：</p><h5 id="实例-20"><a class="markdownIt-Anchor" href="Redis#实例-20"></a> 实例<a href="Redis#实例-20"></a></h5><p>redis**&gt;** GEOADD Sicily 13.361389 38.115556 “Palermo” 15.087269 37.502669 “Catania”<br><strong>(<strong>integer</strong>)</strong> 2<br>redis**&gt;** GEODIST Sicily Palermo Catania<br>“166274.1516”<br>redis**&gt;** GEORADIUS Sicily 15 37 100 km<br>1**)** “Catania”<br>redis**&gt;** GEORADIUS Sicily 15 37 200 km<br>1**)** “Palermo”<br>2**)** “Catania”<br>redis**&gt;**</p><h4 id="geopos"><a class="markdownIt-Anchor" href="Redis#geopos"></a> geopos<a href="Redis#geopos"></a></h4><p>geopos 用于从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</p><p>geopos 语法格式如下：</p><h5 id="实例-21"><a class="markdownIt-Anchor" href="Redis#实例-21"></a> 实例<a href="Redis#实例-21"></a></h5><p>redis**&gt;** GEOADD Sicily 13.361389 38.115556 “Palermo” 15.087269 37.502669 “Catania”<br><strong>(<strong>integer</strong>)</strong> 2<br>redis**&gt;** GEOPOS Sicily Palermo Catania NonExisting<br>1**)** 1**)** “13.36138933897018433”<br>2**)** “38.11555639549629859”<br>2**)** 1**)** “15.08726745843887329”<br>2**)** “37.50266842333162032”<br>3**)** <strong>(<strong>nil</strong>)</strong><br>redis**&gt;**</p><h4 id="geodist"><a class="markdownIt-Anchor" href="Redis#geodist"></a> geodist<a href="Redis#geodist"></a></h4><p>geodist 用于返回两个给定位置之间的距离。</p><p>geodist 语法格式如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEODIST key member1 member2 [m|km|ft|mi]</span><br></pre></td></tr></table></div></figure><p>member1 member2 为两个地理位置。</p><p>最后一个距离单位参数说明：</p><ul><li><p>m ：米，默认单位。</p></li><li><p>km ：千米。</p></li><li><p>mi ：英里。</p></li><li><p>ft ：英尺。</p></li><li><p>&gt; 计算 Palermo 与 Catania 之间的距离：实例</p></li><li><p>redis**&gt;** GEOADD Sicily 13.361389 38.115556 “Palermo” 15.087269 37.502669 “Catania”<br><strong>(<strong>integer</strong>)</strong> 2<br>redis**&gt;** GEODIST Sicily Palermo Catania<br>“166274.1516”<br>redis**&gt;** GEODIST Sicily Palermo Catania km<br>“166.2742”<br>redis**&gt;** GEODIST Sicily Palermo Catania mi<br>“103.3182”<br>redis**&gt;** GEODIST Sicily Foo Bar<br><strong>(<strong>nil</strong>)</strong><br>redis**&gt;**</p></li></ul><h3 id="georadius-georadiusbymember"><a class="markdownIt-Anchor" href="Redis#georadius-georadiusbymember"></a> georadius、georadiusbymember<a href="Redis#georadius-georadiusbymember"></a></h3><p>georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p><p>georadiusbymember 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点。</p><p>georadius 与 georadiusbymember 语法格式如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line">GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></div></figure><p>参数说明：</p><ul><li>m ：米，默认单位。<ul><li>km ：千米。</li><li>mi ：英里。</li><li>ft ：英尺。</li><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</li><li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li></ul></li><li>COUNT 限定返回的记录数。<ul><li>ASC: 查找结果根据距离从近到远排序。</li><li>DESC: 查找结果根据从远到近排序。</li></ul></li></ul><h5 id="georadius-实例"><a class="markdownIt-Anchor" href="Redis#georadius-实例"></a> georadius 实例<a href="Redis#georadius-实例"></a></h5><p>redis**&gt;** GEOADD Sicily 13.361389 38.115556 “Palermo” 15.087269 37.502669 “Catania”<br><strong>(<strong>integer</strong>)</strong> 2<br>redis**&gt;** GEORADIUS Sicily 15 37 200 km WITHDIST<br>1**)** 1**)** “Palermo”<br>2**)** “190.4424”<br>2**)** 1**)** “Catania”<br>2**)** “56.4413”<br>redis**&gt;** GEORADIUS Sicily 15 37 200 km WITHCOORD<br>1**)** 1**)** “Palermo”<br>2**)** 1**)** “13.36138933897018433”<br>2**)** “38.11555639549629859”<br>2**)** 1**)** “Catania”<br>2**)** 1**)** “15.08726745843887329”<br>2**)** “37.50266842333162032”<br>redis**&gt;** GEORADIUS Sicily 15 37 200 km WITHDIST WITHCOORD<br>1**)** 1**)** “Palermo”<br>2**)** “190.4424”<br>3**)** 1**)** “13.36138933897018433”<br>2**)** “38.11555639549629859”<br>2**)** 1**)** “Catania”<br>2**)** “56.4413”<br>3**)** 1**)** “15.08726745843887329”<br>2**)** “37.50266842333162032”<br>redis**&gt;**</p><h5 id="georadiusbymember-实例"><a class="markdownIt-Anchor" href="Redis#georadiusbymember-实例"></a> georadiusbymember 实例<a href="Redis#georadiusbymember-实例"></a></h5><ul><li>redis**&gt;** GEOADD Sicily 13.583333 37.316667 “Agrigento”<br><strong>(<strong>integer</strong>)</strong> 1<br>redis**&gt;** GEOADD Sicily 13.361389 38.115556 “Palermo” 15.087269 37.502669 “Catania”<br><strong>(<strong>integer</strong>)</strong> 2<br>redis**&gt;** GEORADIUSBYMEMBER Sicily Agrigento 100 km<br>1**)** “Agrigento”<br>2**)** “Palermo”<br>redis**&gt;**</li></ul><h4 id="geohash"><a class="markdownIt-Anchor" href="Redis#geohash"></a> geohash<a href="Redis#geohash"></a></h4><ul><li><p>Redis GEO 使用 geohash 来保存地理位置的坐标。</p></li><li><p>geohash 用于获取一个或多个位置元素的 geohash 值。</p></li><li><p>geohash 语法格式如下：</p></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOHASH key member [member ...]</span><br></pre></td></tr></table></div></figure><h5 id="实例-22"><a class="markdownIt-Anchor" href="Redis#实例-22"></a> 实例<a href="Redis#实例-22"></a></h5><p>redis**&gt;** GEOADD Sicily 13.361389 38.115556 “Palermo” 15.087269 37.502669 “Catania”<br><strong>(<strong>integer</strong>)</strong> 2<br>redis**&gt;** GEOHASH Sicily Palermo Catania<br>1**)** “sqc8b49rny0”<br>2**)** “sqdtr74hyu0”<br>redis**&gt;**</p><h2 id="redistemplate"><a class="markdownIt-Anchor" href="Redis#redistemplate"></a> RedisTemplate<a href="Redis#redistemplate"></a></h2><h5 id="引入依赖"><a class="markdownIt-Anchor" href="Redis#引入依赖"></a> 引入依赖<a href="Redis#引入依赖"></a></h5><p>Spring Boot提供的数据访问框架Spring Data Redis基于Jedis。可以通过引入<code>spring-boot-starter-redis</code>来配置依赖关系。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure><blockquote><p>注意不同版本的spring boot下，redis的starter依赖名略有不同，如果上面的不行，可以尝试<code>spring-boot-starter-data-redis</code><strong>（养生堂使用的是这个）</strong></p></blockquote><h5 id="参数配置"><a class="markdownIt-Anchor" href="Redis#参数配置"></a> 参数配置<a href="Redis#参数配置"></a></h5><p>按照惯例在<code>application.properties</code>中加入Redis服务端的相关配置，具体说明如下：</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># REDIS (RedisProperties)</span></span><br><span class="line"><span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">localhost</span></span><br><span class="line"><span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string"></span></span><br><span class="line"><span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-active</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.max-idle</span>=<span class="string">8</span></span><br><span class="line"><span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.pool.min-idle</span>=<span class="string">0</span></span><br><span class="line"><span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">0</span></span><br></pre></td></tr></table></div></figure><p><strong>其中spring.redis.database的配置通常使用0即可，Redis在配置的时候可以设置数据库数量，默认为16，可以理解为数据库的schema</strong></p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  redis:</span></span><br><span class="line"><span class="attr">    database:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">      timeout:</span> <span class="number">0</span></span><br><span class="line">      <span class="comment"># Redis服务器地址</span></span><br><span class="line"><span class="attr">      host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="comment"># Redis服务器连接端口</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">root</span></span><br><span class="line">      <span class="comment"># 连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">      pool:</span></span><br><span class="line"><span class="attr">      max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line"><span class="attr">        max-wait:</span> <span class="bullet">-1</span></span><br><span class="line">        <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line"><span class="attr">        max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="comment"># 连接池中的最小空闲连接</span></span><br><span class="line"><span class="attr">        min-idle:</span> <span class="number">0</span></span><br></pre></td></tr></table></div></figure><h5 id="redis-server设置"><a class="markdownIt-Anchor" href="Redis#redis-server设置"></a> redis-server设置<a href="Redis#redis-server设置"></a></h5><ul><li>protected 改为 no</li><li>daemonize 改为 no</li></ul><h5 id="测试访问"><a class="markdownIt-Anchor" href="Redis#测试访问"></a> 测试访问<a href="Redis#测试访问"></a></h5><p>通过编写测试用例，举例说明如何访问Redis。</p><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ng.redis.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 保存字符串</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">"aaa"</span>, <span class="string">"111"</span>);</span><br><span class="line">Assert.assertEquals(<span class="string">"111"</span>, stringRedisTemplate.opsForValue().get(<span class="string">"aaa"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>通过上面这段极为简单的测试案例演示了如何通过自动配置的<code>StringRedisTemplate</code>对象进行Redis的读写操作，该对象从命名中就可注意到支持的是String类型。如果有使用过spring-data-redis的开发者一定熟悉<code>RedisTemplate&lt;K, V&gt;</code>接口，<code>StringRedisTemplate</code>就相当于<code>RedisTemplate&lt;String, String&gt;</code>的实现。</p><p>除了String类型，实战中我们还经常会在Redis中存储对象，这时候我们就会想是否可以使用类似<code>RedisTemplate&lt;String, User&gt;</code>来初始化并进行操作。但是Spring Boot并不支持直接使用，需要我们自己实现<code>RedisSerializer&lt;T&gt;</code>接口来对传入对象进行序列化和反序列化，下面我们通过一个实例来完成对象的读写操作。</p><ul><li>创建要存储的对象：User</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> niu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/28 上午9:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String username, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>实现对象的序列化接口</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ng.redis.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.serializer.support.DeserializingConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.serializer.support.SerializingConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.SerializationException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> niu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/28 上午9:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisObjectSerializer</span> <span class="keyword">implements</span> <span class="title">RedisSerializer</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Converter&lt;Object, <span class="keyword">byte</span>[]&gt; serializer = <span class="keyword">new</span> SerializingConverter();</span><br><span class="line">    <span class="keyword">private</span> Converter&lt;<span class="keyword">byte</span>[], Object&gt; deserializer = <span class="keyword">new</span> DeserializingConverter();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] EMPTY_ARRAY = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty(bytes)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> deserializer.convert(bytes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">"Cannot deserialize"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) &#123;</span><br><span class="line">        <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> serializer.convert(object);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> EMPTY_ARRAY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">byte</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (data == <span class="keyword">null</span> || data.length == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>配置针对User的RedisTemplate实例</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ng.redis.entity.User;</span><br><span class="line"><span class="keyword">import</span> ng.redis.util.RedisObjectSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.jedis.JedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.RedisSerializer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> niu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/7/28 上午9:51</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RedisOperations.class)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(RedisProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  @Bean</span></span><br><span class="line"><span class="comment">//  JedisConnectionFactory jedisConnectionFactory() &#123;</span></span><br><span class="line"><span class="comment">//      return new JedisConnectionFactory();</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span>(StringRedisTemplate.class)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(<span class="string">"redisTemplate"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        JedisConnectionFactory jedisConnectionFactory = <span class="keyword">new</span> JedisConnectionFactory();</span><br><span class="line">        jedisConnectionFactory.afterPropertiesSet();</span><br><span class="line">        template.setConnectionFactory(jedisConnectionFactory);</span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> RedisObjectSerializer());</span><br><span class="line">    template.setHashValueSerializer(<span class="keyword">new</span> RedisObjectSerializer());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>完成了配置工作后，编写测试用例实验效果</li></ul><h5 id="redisutil工具类"><a class="markdownIt-Anchor" href="Redis#redisutil工具类"></a> RedisUtil工具类<a href="Redis#redisutil工具类"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">keys</span><span class="params">(String keys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.keys(keys);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">expire</span><span class="params">(String key, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getExpire</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(String... key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="keyword">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="keyword">null</span> ? <span class="keyword">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">set</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">incr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"递增因子必须大于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">decr</span><span class="params">(String key, <span class="keyword">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"递减因子必须大于0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">hget</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title">hmget</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hset</span><span class="params">(String key, String item, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hdel</span><span class="params">(String key, Object... item)</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hHasKey</span><span class="params">(String key, String item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hincr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">hdecr</span><span class="params">(String key, String item, <span class="keyword">double</span> by)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">sGet</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sHasKey</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSet</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sSetAndTime</span><span class="params">(String key, <span class="keyword">long</span> time, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sGetSetSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">setRemove</span><span class="params">(String key, Object... values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long count = redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">lGet</span><span class="params">(String key, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lGetListSize</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lGetIndex</span><span class="params">(String key, <span class="keyword">long</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, Object value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>)</span><br><span class="line">                expire(key, time);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lUpdateIndex</span><span class="params">(String key, <span class="keyword">long</span> index, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">lRemove</span><span class="params">(String key, <span class="keyword">long</span> count, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long remove = redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="测试"><a class="markdownIt-Anchor" href="Redis#测试"></a> 测试<a href="Redis#测试"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ng.redis.entity.User;</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisApplicationTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, User&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">"super"</span>, <span class="number">20</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line"></span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">"bat"</span>, <span class="number">30</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line"></span><br><span class="line">        user = <span class="keyword">new</span> User(<span class="string">"spider"</span>, <span class="number">40</span>);</span><br><span class="line">        redisTemplate.opsForValue().set(user.getUsername(), user);</span><br><span class="line"></span><br><span class="line">        System.out.println(redisTemplate.opsForValue().get(<span class="string">"super"</span>).getAge().longValue());</span><br><span class="line"><span class="comment">//        Assert.assertEquals(30, redisTemplate.opsForValue().get("蝙蝠侠").getAge().longValue());</span></span><br><span class="line"><span class="comment">//        Assert.assertEquals(40, redisTemplate.opsForValue().get("蜘蛛侠").getAge().longValue());</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="json"><a class="markdownIt-Anchor" href="Redis#json"></a> Json<a href="Redis#json"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"redisTemplate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">    RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">    <span class="comment">//使用fastjson序列化</span></span><br><span class="line">    FastJsonRedisSerializer fastJsonRedisSerializer = <span class="keyword">new</span> FastJsonRedisSerializer(Object.class);</span><br><span class="line">    <span class="comment">// value值的序列化采用fastJsonRedisSerializer</span></span><br><span class="line">    template.setValueSerializer(fastJsonRedisSerializer);</span><br><span class="line">    template.setHashValueSerializer(fastJsonRedisSerializer);</span><br><span class="line">    <span class="comment">// key的序列化采用StringRedisSerializer</span></span><br><span class="line">    template.setKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    template.setHashKeySerializer(<span class="keyword">new</span> StringRedisSerializer());</span><br><span class="line">    template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>json使用</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(((JSONObject) redisTemplate.opsForValue().get(<span class="string">"zhx"</span>)).getInteger(<span class="string">"age"</span>));</span><br></pre></td></tr></table></div></figure><ul><li>所需依赖</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;redis&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;Redis#redis&quot;&gt;&lt;/a&gt; Redis&lt;a href=&quot;Redis#redis&quot;&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id=&quot;redis特性&quot;&gt;&lt;a class=&quot;markdown
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Excel生成工具类</title>
    <link href="ilucia.github.io/Excel%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>ilucia.github.io/Excel%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2022-04-27T15:24:01.559Z</published>
    <updated>2022-04-27T15:24:01.559Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一次性excel导出"><a class="markdownIt-Anchor" href="Excel生成工具类#一次性excel导出"></a> 一次性excel导出<a href="Excel生成工具类#一次性excel导出"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportProductExcel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"product.txt"</span>);</span><br><span class="line">    StringBuilder resultString = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(file));<span class="comment">//构造一个BufferedReader类来读取文件</span></span><br><span class="line">        String s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>((s = br.readLine())!=<span class="keyword">null</span>)&#123;<span class="comment">//使用readLine方法，一次读一行</span></span><br><span class="line">            resultString.append(System.lineSeparator()+s);</span><br><span class="line">        &#125;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    JSONObject result = JSONObject.parseObject(resultString.toString());</span><br><span class="line">    System.out.println(resultString);</span><br><span class="line">    JSONArray productList = result.getJSONArray(<span class="string">"data"</span>);</span><br><span class="line">    HSSFWorkbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">    <span class="comment">//创建excel文档</span></span><br><span class="line">    HSSFSheet sheet = workbook.createSheet(<span class="string">"商品表"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义列的宽度</span></span><br><span class="line">    sheet.setColumnWidth(<span class="number">0</span>, <span class="number">20</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">1</span>, <span class="number">15</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">2</span>, <span class="number">20</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">3</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">4</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">5</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">6</span>, <span class="number">20</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">7</span>, <span class="number">30</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">8</span>, <span class="number">30</span> * <span class="number">256</span>);</span><br><span class="line">    <span class="comment">//设置表头</span></span><br><span class="line">    HSSFRow headerRow = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">0</span>).setCellValue(<span class="string">"商品编码"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">1</span>).setCellValue(<span class="string">"外部商品编码"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">2</span>).setCellValue(<span class="string">"商品名称"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">3</span>).setCellValue(<span class="string">"大类"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">4</span>).setCellValue(<span class="string">"中类"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">5</span>).setCellValue(<span class="string">"小类"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">6</span>).setCellValue(<span class="string">"品牌"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">7</span>).setCellValue(<span class="string">"售卖机型"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">8</span>).setCellValue(<span class="string">"标签"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; productList.size();i++)&#123;</span><br><span class="line">        JSONObject product = productList.getJSONObject(i);</span><br><span class="line">        HSSFRow row = sheet.createRow(i+<span class="number">1</span>);</span><br><span class="line">        row.createCell(<span class="number">0</span>).setCellValue(product.getString(<span class="string">"skuCode"</span>));</span><br><span class="line">        row.createCell(<span class="number">1</span>).setCellValue(product.getString(<span class="string">"externalSkuId"</span>));</span><br><span class="line">        row.createCell(<span class="number">2</span>).setCellValue(product.getString(<span class="string">"name"</span>));</span><br><span class="line">        row.createCell(<span class="number">3</span>).setCellValue(product.getString(<span class="string">"bigLevelSpuName"</span>));</span><br><span class="line">        row.createCell(<span class="number">4</span>).setCellValue(product.getString(<span class="string">"mediumLevelSpuName"</span>));</span><br><span class="line">        row.createCell(<span class="number">5</span>).setCellValue(product.getString(<span class="string">"productSpuName"</span>));</span><br><span class="line">        row.createCell(<span class="number">6</span>).setCellValue(product.getString(<span class="string">"product_brand_cn"</span>));</span><br><span class="line">        row.createCell(<span class="number">7</span>).setCellValue(product.getString(<span class="string">"machine_type_names"</span>));</span><br><span class="line">        JSONArray productTagList = product.getJSONArray(<span class="string">"productTagVOList"</span>);</span><br><span class="line">        StringBuilder tags = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(productTagList != <span class="keyword">null</span> &amp;&amp; !productTagList.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; productTagList.size();j++) &#123;</span><br><span class="line">                JSONObject tag = productTagList.getJSONObject(j);</span><br><span class="line">                tags.append(<span class="string">" "</span>).append(tag.getString(<span class="string">"tagName"</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tags.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            row.createCell(<span class="number">8</span>).setCellValue(tags.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            row.createCell(<span class="number">8</span>).setCellValue(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将excel写入到ByteArrayOutStream中</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"商品列表.xls"</span>);</span><br><span class="line">    workbook.write(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="excel导出"><a class="markdownIt-Anchor" href="Excel生成工具类#excel导出"></a> excel导出<a href="Excel生成工具类#excel导出"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportProductExcel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PageResultVO result = productSkuController.getProductSkuByPage(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>, <span class="number">900</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;VemProductSkuResultMap&gt; productList = (List&lt;VemProductSkuResultMap&gt;) result.getData();</span><br><span class="line">    HSSFWorkbook workbook = <span class="keyword">new</span> HSSFWorkbook();</span><br><span class="line">    <span class="comment">//创建excel文档</span></span><br><span class="line">    HSSFSheet sheet = workbook.createSheet(<span class="string">"商品表"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义列的宽度</span></span><br><span class="line">    sheet.setColumnWidth(<span class="number">0</span>, <span class="number">5</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">1</span>, <span class="number">5</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">2</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">3</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">4</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">5</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">6</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">7</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    sheet.setColumnWidth(<span class="number">8</span>, <span class="number">10</span> * <span class="number">256</span>);</span><br><span class="line">    <span class="comment">//设置表头</span></span><br><span class="line">    HSSFRow headerRow = sheet.createRow(<span class="number">0</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">0</span>).setCellValue(<span class="string">"商品编码"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">1</span>).setCellValue(<span class="string">"外部商品编码"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">2</span>).setCellValue(<span class="string">"商品名称"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">3</span>).setCellValue(<span class="string">"大类"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">4</span>).setCellValue(<span class="string">"中类"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">5</span>).setCellValue(<span class="string">"小类"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">6</span>).setCellValue(<span class="string">"品牌"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">7</span>).setCellValue(<span class="string">"售卖机型"</span>);</span><br><span class="line">    headerRow.createCell(<span class="number">8</span>).setCellValue(<span class="string">"标签"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; productList.size();i++)&#123;</span><br><span class="line">        VemProductSkuResultMap product = productList.get(i);</span><br><span class="line">        HSSFRow row = sheet.createRow(i+<span class="number">1</span>);</span><br><span class="line">        row.createCell(<span class="number">0</span>).setCellValue(product.getId());</span><br><span class="line">        row.createCell(<span class="number">1</span>).setCellValue(product.getExternalSkuId());</span><br><span class="line">        row.createCell(<span class="number">2</span>).setCellValue(product.getName());</span><br><span class="line">        row.createCell(<span class="number">3</span>).setCellValue(product.getBigLevelSpuName());</span><br><span class="line">        row.createCell(<span class="number">4</span>).setCellValue(product.getMediumLevelSpuName());</span><br><span class="line">        row.createCell(<span class="number">5</span>).setCellValue(product.getProductSpuName());</span><br><span class="line">        String cn = DictConsts.UNMATCH_VALUE;</span><br><span class="line">        SkuBrandFacade skuBrandFacade = SpringContextUtil.getBean(<span class="string">"skuBrandFacade"</span>);</span><br><span class="line">        VemSkuBrand skuBrand = skuBrandFacade.getSkuBrand(product.getBrandCode());</span><br><span class="line">        <span class="keyword">if</span>(!Objects.isNull(skuBrand))&#123;</span><br><span class="line">            cn = skuBrand.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        row.createCell(<span class="number">6</span>).setCellValue(cn);</span><br><span class="line">        List&lt;VemProductSkuMachineType&gt; skuMachineTypes = product.getMachineTypeList();</span><br><span class="line">        StringBuilder typeNames = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(skuMachineTypes))&#123;</span><br><span class="line">            DictService dictService= SpringContextUtil.getBean(<span class="string">"dictServiceImpl"</span>);</span><br><span class="line">            List&lt;VemDict&gt; dictList=dictService.listVemDictByDictGroupId(DictConsts.MACHINE_TYPE);</span><br><span class="line">            <span class="keyword">if</span>(CollectionUtils.isNotEmpty(dictList))&#123;</span><br><span class="line">                <span class="keyword">for</span>(VemDict dict : dictList)&#123;</span><br><span class="line">                    String value = String.valueOf(dict.getDictCode());</span><br><span class="line">                    <span class="keyword">for</span>(VemProductSkuMachineType type : skuMachineTypes)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(value.equals(type.getMachineType()))&#123;</span><br><span class="line">                            typeNames.append(<span class="string">","</span>).append(dict.getDictName());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(typeNames.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            row.createCell(<span class="number">7</span>).setCellValue(typeNames.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            row.createCell(<span class="number">7</span>).setCellValue(DictConsts.UNMATCH_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;ProductTagVO&gt; productTagList = product.getProductTagVOList();</span><br><span class="line">        StringBuilder tags = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(productTagList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (ProductTagVO tag : productTagList) &#123;</span><br><span class="line">                tags.append(<span class="string">" "</span>).append(tag.getTagName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tags.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            row.createCell(<span class="number">8</span>).setCellValue(tags.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            row.createCell(<span class="number">8</span>).setCellValue(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将excel写入到ByteArrayOutStream中</span></span><br><span class="line">    FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"商品列表.xls"</span>);</span><br><span class="line">    workbook.write(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"商品编码"</span>, <span class="string">"商品Id"</span>, <span class="string">"商品名称"</span>, <span class="string">"商品别名"</span>, <span class="string">"外部商品编码"</span>, <span class="string">"市场指导价(元)"</span>, <span class="string">"类目"</span>, <span class="string">"品牌"</span>, <span class="string">"建议售价(元)"</span>, <span class="string">"计量单位"</span>, <span class="string">"规格"</span>, <span class="string">"厚度(mm)"</span>, <span class="string">"重量(g)"</span>, <span class="string">"图片"</span>, <span class="string">"保质期(天)"</span>, <span class="string">"售卖机型"</span>, <span class="string">"标签"</span>, <span class="string">"是否原材料"</span>, <span class="string">"是否组合商品"</span>, <span class="string">"是否返信用"</span>, <span class="string">"是否非专卖"</span>, <span class="string">"批次来源"</span>, <span class="string">"定时折扣"</span>, <span class="string">"折扣模板"</span>, <span class="string">"修改时间"</span>, <span class="string">"修改人"</span>&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.nfsq.vem.admin.entity.dto;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> niu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/11/24 下午5:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductExcelModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String skuCode;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nameAlias;</span><br><span class="line">    <span class="keyword">private</span> String externalSkuId;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal marketPrice;</span><br><span class="line">    <span class="keyword">private</span> String productSpuLevelName;</span><br><span class="line">    <span class="keyword">private</span> String productBrand;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal guidePrice;</span><br><span class="line">    <span class="keyword">private</span> String measurementUnit;</span><br><span class="line">    <span class="keyword">private</span> String specification;</span><br><span class="line">    <span class="keyword">private</span> Integer thickness;</span><br><span class="line">    <span class="keyword">private</span> Integer weight;</span><br><span class="line">    <span class="keyword">private</span> String imageUrl;</span><br><span class="line">    <span class="keyword">private</span> Integer guaranteePeriod;</span><br><span class="line">    <span class="keyword">private</span> String machineTypeNames;</span><br><span class="line">    <span class="keyword">private</span> String tags;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="keyword">private</span> String isOrigin;</span><br><span class="line">    <span class="keyword">private</span> String isGroupSkuCnName;</span><br><span class="line">    <span class="keyword">private</span> String isReturnCreditCnName;</span><br><span class="line">    <span class="keyword">private</span> String ifNonMonopolyCnName;</span><br><span class="line">    <span class="keyword">private</span> String ifBatchNoCnName;</span><br><span class="line">    <span class="keyword">private</span> Date updateDate;</span><br><span class="line">    <span class="keyword">private</span> String updatePerson;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出商品品项列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/exportProductSkuExcel"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportProductExcel</span><span class="params">(@RequestParam(required = <span class="keyword">false</span>)</span> String brandCode,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String spuId,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String productName,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String nameAlias,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> Integer tagId,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String machineType,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> Boolean isMaterialProduct,</span></span><br><span class="line"><span class="function">                               HttpServletResponse response) <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    PageResultVO result = getProductSkuByPage(brandCode, spuId, productName, nameAlias, tagId, machineType, <span class="keyword">null</span>, <span class="keyword">null</span>, isMaterialProduct);</span><br><span class="line">    List&lt;VemProductSkuResultMap&gt; productList = (List&lt;VemProductSkuResultMap&gt;) result.getData();</span><br><span class="line"></span><br><span class="line">    PoiExcelExport poiExcelExport = <span class="keyword">new</span> PoiExcelExport(response, <span class="string">"商品品项"</span>, <span class="string">"商品品项"</span>);</span><br><span class="line">    <span class="comment">// 列名</span></span><br><span class="line">    String[] columnNames = &#123;<span class="string">"商品编码"</span>, <span class="string">"商品Id"</span>, <span class="string">"商品名称"</span>, <span class="string">"商品别名"</span>, <span class="string">"外部商品编码"</span>, <span class="string">"市场指导价(元)"</span>, <span class="string">"类目"</span>, <span class="string">"品牌"</span>, <span class="string">"建议售价(元)"</span>, <span class="string">"计量单位"</span>, <span class="string">"规格"</span>, <span class="string">"厚度(mm)"</span>, <span class="string">"重量(g)"</span>, <span class="string">"图片"</span>, <span class="string">"保质期(天)"</span>, <span class="string">"售卖机型"</span>, <span class="string">"标签"</span>, <span class="string">"描述"</span>, <span class="string">"是否原材料"</span>, <span class="string">"是否组合商品"</span>, <span class="string">"是否返信用"</span>, <span class="string">"是否非专卖"</span>, <span class="string">"批次来源"</span>, <span class="string">"修改时间"</span>, <span class="string">"修改人"</span>&#125;;</span><br><span class="line">    <span class="comment">// map中的key</span></span><br><span class="line">    String[] keys = &#123; <span class="string">"skuCode"</span>, <span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"nameAlias"</span>, <span class="string">"externalSkuId"</span>,</span><br><span class="line">            <span class="string">"marketPrice"</span>, <span class="string">"productSpuLevelName"</span>, <span class="string">"productBrand"</span>, <span class="string">"guidePrice"</span>, <span class="string">"measurementUnit"</span>,</span><br><span class="line">            <span class="string">"specification"</span>, <span class="string">"thickness"</span>, <span class="string">"weight"</span>, <span class="string">"imageUrl"</span>, <span class="string">"guaranteePeriod"</span>,</span><br><span class="line">            <span class="string">"machineTypeNames"</span>, <span class="string">"tags"</span>, <span class="string">"description"</span>, <span class="string">"isOrigin"</span>, <span class="string">"isGroupSkuCnName"</span>,</span><br><span class="line">            <span class="string">"isReturnCreditCnName"</span>, <span class="string">"ifNonMonopolyCnName"</span>, <span class="string">"ifBatchNoCnName"</span>, <span class="string">"updateDate"</span>, <span class="string">"updatePerson"</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] titleSize = &#123; <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;ProductExcelModel&gt; models = constructProductExcelModel(productList);</span><br><span class="line">    poiExcelExport.writeExcelBaseMethod(<span class="string">"商品品项"</span>, keys, columnNames, titleSize, models);</span><br><span class="line">    poiExcelExport.writeExcelMultiSheet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ProductExcelModel&gt; <span class="title">constructProductExcelModel</span><span class="params">(List&lt;VemProductSkuResultMap&gt; productSkuResultMaps)</span> </span>&#123;</span><br><span class="line">    List&lt;ProductExcelModel&gt; models = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (VemProductSkuResultMap product : productSkuResultMaps) &#123;</span><br><span class="line">        ProductExcelModel model = <span class="keyword">new</span> ProductExcelModel();</span><br><span class="line">        model.setSkuCode(product.getSkuCode());</span><br><span class="line">        model.setId(product.getId());</span><br><span class="line">        model.setName(product.getName());</span><br><span class="line">        model.setNameAlias(product.getNameAlias());</span><br><span class="line">        model.setExternalSkuId(product.getExternalSkuId());</span><br><span class="line">        model.setMarketPrice(product.getMarketPrice());</span><br><span class="line">        model.setProductSpuLevelName(product.getProductSpuLevelName());</span><br><span class="line">        String cn = DictConsts.UNMATCH_VALUE;</span><br><span class="line">        SkuBrandFacade skuBrandFacade = SpringContextUtil.getBean(<span class="string">"skuBrandFacade"</span>);</span><br><span class="line">        VemSkuBrand skuBrand = skuBrandFacade.getSkuBrand(product.getBrandCode());</span><br><span class="line">        <span class="keyword">if</span>(!Objects.isNull(skuBrand))&#123;</span><br><span class="line">            cn = skuBrand.getName();</span><br><span class="line">        &#125;</span><br><span class="line">        model.setProductBrand(cn);</span><br><span class="line">        model.setGuidePrice(product.getGuidePrice());</span><br><span class="line">        model.setMeasurementUnit(product.getMeasurementUnit());</span><br><span class="line">        model.setSpecification(product.getSpecification());</span><br><span class="line">        model.setThickness(product.getThickness());</span><br><span class="line">        model.setWeight(product.getWeight());</span><br><span class="line">        model.setImageUrl(product.getImageUrl());</span><br><span class="line">        model.setGuaranteePeriod(product.getGuaranteePeriod());</span><br><span class="line">        List&lt;VemProductSkuMachineType&gt; skuMachineTypes = product.getMachineTypeList();</span><br><span class="line">        StringBuilder typeNames = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(skuMachineTypes))&#123;</span><br><span class="line">            DictService dictService= SpringContextUtil.getBean(<span class="string">"dictServiceImpl"</span>);</span><br><span class="line">            List&lt;VemDict&gt; dictList=dictService.listVemDictByDictGroupId(DictConsts.MACHINE_TYPE);</span><br><span class="line">            <span class="keyword">if</span>(CollectionUtils.isNotEmpty(dictList))&#123;</span><br><span class="line">                <span class="keyword">for</span>(VemDict dict : dictList)&#123;</span><br><span class="line">                    String value = String.valueOf(dict.getDictCode());</span><br><span class="line">                    <span class="keyword">for</span>(VemProductSkuMachineType type : skuMachineTypes)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(value.equals(type.getMachineType()))&#123;</span><br><span class="line">                            typeNames.append(<span class="string">","</span>).append(dict.getDictName());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(typeNames.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            model.setMachineTypeNames(typeNames.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            model.setMachineTypeNames(DictConsts.UNMATCH_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ProductTagVO&gt; productTagList = product.getProductTagVOList();</span><br><span class="line">        StringBuilder tags = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(productTagList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (ProductTagVO tag : productTagList) &#123;</span><br><span class="line">                tags.append(<span class="string">" "</span>).append(tag.getTagName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tags.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            model.setTags(tags.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            model.setTags(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        model.setDescription(product.getDescription());</span><br><span class="line">        model.setIsOrigin((<span class="string">"2"</span>.equals(product.getProductType())) ? <span class="string">"是"</span> : <span class="string">"否"</span>);</span><br><span class="line">        model.setIsGroupSkuCnName(product.getIsGroupSkuCnName());</span><br><span class="line">        model.setIsReturnCreditCnName(product.getIsReturnCreditCnName());</span><br><span class="line">        model.setIfNonMonopolyCnName(product.getIfNonMonopolyCnName());</span><br><span class="line">        model.setIfBatchNoCnName(product.getIfBatchNoCnName());</span><br><span class="line">        model.setUpdateDate(product.getUpdateDate());</span><br><span class="line">        model.setUpdatePerson(product.getUpdatePerson());</span><br><span class="line">        models.add(model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> models;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;VemProductSkuResultMap&gt; <span class="title">listVemProductSkuResultMapByPage</span><span class="params">(List&lt;String&gt; spuIds, String brandCode,String productSkuName, String nameAlias, <span class="keyword">boolean</span> isMaterialProduct, String machineType, Integer pageNum, Integer pageSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pageNum != <span class="keyword">null</span> &amp;&amp; pageSize != <span class="keyword">null</span>) &#123;</span><br><span class="line">        PageHelper.startPage(pageNum,pageSize);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;VemProductSkuResultMap&gt; vemProductSkuList = manualVemProductSkuMapper.selectVemProductSkuResultMapBySkuNameAndSpuIds(<span class="keyword">null</span>, productSkuName, nameAlias, spuIds, brandCode,isMaterialProduct,machineType);</span><br><span class="line">    <span class="keyword">return</span> vemProductSkuList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> vem_machine <span class="keyword">ADD</span> WAREHOUSE_ADDRESS <span class="built_in">CHAR</span>(<span class="number">1</span>) <span class="keyword">AFTER</span> <span class="keyword">STATUS</span>;</span><br></pre></td></tr></table></div></figure><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 导出商品品项列表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> productName</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/exportProductSkuExcel"</span>, method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportProductExcel</span><span class="params">(@RequestParam(required = <span class="keyword">false</span>)</span> String brandCode,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String spuId,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String productName,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String nameAlias,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> Integer tagId,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> String machineType,</span></span><br><span class="line"><span class="function">                               @<span class="title">RequestParam</span><span class="params">(required = <span class="keyword">false</span>)</span> Boolean isMaterialProduct,</span></span><br><span class="line"><span class="function">                               HttpServletResponse response) </span>&#123;</span><br><span class="line">    PageResultVO result = getProductSkuByPage(brandCode, spuId, productName, nameAlias, tagId, machineType, <span class="keyword">null</span>, <span class="keyword">null</span>, isMaterialProduct);</span><br><span class="line">    List&lt;VemProductSkuResultMap&gt; productList = (List&lt;VemProductSkuResultMap&gt;) result.getData();</span><br><span class="line"></span><br><span class="line">    PoiExcelExport poiExcelExport = <span class="keyword">new</span> PoiExcelExport(response, <span class="string">"商品品项"</span>, <span class="string">"商品品项"</span>);</span><br><span class="line">    <span class="comment">// 列名</span></span><br><span class="line">    String[] columnNames = &#123;<span class="string">"商品编码"</span>, <span class="string">"商品Id"</span>, <span class="string">"商品名称"</span>, <span class="string">"商品别名"</span>, <span class="string">"外部商品编码"</span>,</span><br><span class="line">            <span class="string">"市场指导价(元)"</span>, <span class="string">"类目"</span>, <span class="string">"品牌"</span>, <span class="string">"建议售价(元)"</span>, <span class="string">"计量单位"</span>,</span><br><span class="line">            <span class="string">"规格"</span>, <span class="string">"厚度(mm)"</span>, <span class="string">"重量(g)"</span>, <span class="string">"图片"</span>, <span class="string">"保质期(天)"</span>,</span><br><span class="line">            <span class="string">"售卖机型"</span>, <span class="string">"标签"</span>, <span class="string">"描述"</span>, <span class="string">"是否原材料"</span>, <span class="string">"是否组合商品"</span>,</span><br><span class="line">            <span class="string">"是否返信用"</span>, <span class="string">"是否非专卖"</span>, <span class="string">"批次来源"</span>, <span class="string">"修改时间"</span>, <span class="string">"修改人"</span>&#125;;</span><br><span class="line">    <span class="comment">// map中的key</span></span><br><span class="line">    String[] keys = &#123; <span class="string">"skuCode"</span>, <span class="string">"id"</span>, <span class="string">"name"</span>, <span class="string">"nameAlias"</span>, <span class="string">"externalSkuId"</span>,</span><br><span class="line">            <span class="string">"marketPrice"</span>, <span class="string">"productSpuLevelName"</span>, <span class="string">"productBrand"</span>, <span class="string">"guidePrice"</span>, <span class="string">"measurementUnit"</span>,</span><br><span class="line">            <span class="string">"specification"</span>, <span class="string">"thickness"</span>, <span class="string">"weight"</span>, <span class="string">"imageUrl"</span>, <span class="string">"guaranteePeriod"</span>,</span><br><span class="line">            <span class="string">"machineTypeNames"</span>, <span class="string">"tags"</span>, <span class="string">"description"</span>, <span class="string">"isOrigin"</span>, <span class="string">"isGroupSkuCnName"</span>,</span><br><span class="line">            <span class="string">"isReturnCreditCnName"</span>, <span class="string">"ifNonMonopolyCnName"</span>, <span class="string">"ifBatchNoCnName"</span>, <span class="string">"updateDate"</span>, <span class="string">"updatePerson"</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] titleSize = &#123; <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;ProductExcelModel&gt; models = constructProductExcelModel(productList);</span><br><span class="line">    poiExcelExport.writeExcelBaseMethod(<span class="string">"商品品项"</span>, keys, columnNames, titleSize, models);</span><br><span class="line">    poiExcelExport.writeExcelMultiSheet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ProductExcelModel&gt; <span class="title">constructProductExcelModel</span><span class="params">(List&lt;VemProductSkuResultMap&gt; productSkuResultMaps)</span> </span>&#123;</span><br><span class="line">    List&lt;ProductExcelModel&gt; models = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    SkuBrandFacade skuBrandFacade = SpringContextUtil.getBean(<span class="string">"skuBrandFacade"</span>);</span><br><span class="line">    Map&lt;String, String&gt; brandMap = skuBrandFacade.findSkuBrands();</span><br><span class="line">    DictService dictService= SpringContextUtil.getBean(<span class="string">"dictServiceImpl"</span>);</span><br><span class="line">    List&lt;VemDict&gt; dictList=dictService.listVemDictByDictGroupId(DictConsts.MACHINE_TYPE);</span><br><span class="line">    <span class="keyword">for</span> (VemProductSkuResultMap product : productSkuResultMaps) &#123;</span><br><span class="line">        ProductExcelModel model = <span class="keyword">new</span> ProductExcelModel();</span><br><span class="line">        model.setSkuCode(product.getSkuCode());</span><br><span class="line">        model.setId(product.getId());</span><br><span class="line">        model.setName(product.getName());</span><br><span class="line">        model.setNameAlias(product.getNameAlias());</span><br><span class="line">        model.setExternalSkuId(product.getExternalSkuId());</span><br><span class="line">        model.setMarketPrice(product.getMarketPrice());</span><br><span class="line">        model.setProductSpuLevelName(product.getProductSpuLevelName());</span><br><span class="line">        String cn = DictConsts.UNMATCH_VALUE;</span><br><span class="line">        String skuBrand = brandMap.get(product.getBrandCode());</span><br><span class="line">        <span class="keyword">if</span>(StringUtil.isNotBlank(skuBrand)) &#123;</span><br><span class="line">            cn = skuBrand;</span><br><span class="line">        &#125;</span><br><span class="line">        model.setProductBrand(cn);</span><br><span class="line">        model.setGuidePrice(product.getGuidePrice());</span><br><span class="line">        model.setMeasurementUnit(product.getMeasurementUnit());</span><br><span class="line">        model.setSpecification(product.getSpecification());</span><br><span class="line">        model.setThickness(product.getThickness());</span><br><span class="line">        model.setWeight(product.getWeight());</span><br><span class="line">        model.setImageUrl(product.getImageUrl());</span><br><span class="line">        model.setGuaranteePeriod(product.getGuaranteePeriod());</span><br><span class="line">        List&lt;VemProductSkuMachineType&gt; skuMachineTypes = product.getMachineTypeList();</span><br><span class="line">        StringBuilder typeNames = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(skuMachineTypes))&#123;</span><br><span class="line">            <span class="keyword">if</span>(CollectionUtils.isNotEmpty(dictList))&#123;</span><br><span class="line">                <span class="keyword">for</span>(VemDict dict : dictList)&#123;</span><br><span class="line">                    String value = String.valueOf(dict.getDictCode());</span><br><span class="line">                    <span class="keyword">for</span>(VemProductSkuMachineType type : skuMachineTypes)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(value.equals(type.getMachineType()))&#123;</span><br><span class="line">                            typeNames.append(<span class="string">","</span>).append(dict.getDictName());</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(typeNames.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            model.setMachineTypeNames(typeNames.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            model.setMachineTypeNames(DictConsts.UNMATCH_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;ProductTagVO&gt; productTagList = product.getProductTagVOList();</span><br><span class="line">        StringBuilder tags = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(CollectionUtils.isNotEmpty(productTagList))&#123;</span><br><span class="line">            <span class="keyword">for</span> (ProductTagVO tag : productTagList) &#123;</span><br><span class="line">                tags.append(<span class="string">" "</span>).append(tag.getTagName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tags.length() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            model.setTags(tags.substring(<span class="number">1</span>));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            model.setTags(<span class="string">""</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        model.setDescription(product.getDescription());</span><br><span class="line">        model.setIsOrigin((<span class="string">"2"</span>.equals(product.getProductType())) ? <span class="string">"是"</span> : <span class="string">"否"</span>);</span><br><span class="line">        model.setIsGroupSkuCnName(product.getIsGroupSkuCnName());</span><br><span class="line">        model.setIsReturnCreditCnName(product.getIsReturnCreditCnName());</span><br><span class="line">        model.setIfNonMonopolyCnName(product.getIfNonMonopolyCnName());</span><br><span class="line">        model.setIfBatchNoCnName(product.getIfBatchNoCnName());</span><br><span class="line">        model.setUpdateDate(product.getUpdateDate());</span><br><span class="line">        model.setUpdatePerson(product.getUpdatePerson());</span><br><span class="line">        models.add(model);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> models;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h5 id="提交信息"><a class="markdownIt-Anchor" href="Excel生成工具类#提交信息"></a> 提交信息<a href="Excel生成工具类#提交信息"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【Fix】ID1107326 商品信息导出功能】 https://www.tapd.cn/52268405/prong/stories/view/1152268405001107326   1.导出文件并下载初步完成</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一次性excel导出&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;Excel生成工具类#一次性excel导出&quot;&gt;&lt;/a&gt; 一次性excel导出&lt;a href=&quot;Excel生成工具类#一次性excel导出&quot;&gt;&lt;/a&gt;&lt;/h3&gt;
&lt;figu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Maven/基础&amp;POM</title>
    <link href="ilucia.github.io/Maven/%E5%9F%BA%E7%A1%80&amp;POM/"/>
    <id>ilucia.github.io/Maven/%E5%9F%BA%E7%A1%80&amp;POM/</id>
    <published>2022-04-27T15:24:01.559Z</published>
    <updated>2022-04-27T15:24:01.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础"><a class="markdownIt-Anchor" href="Maven/基础&POM#基础"></a> 基础<a href="Maven/基础&POM#基础"></a></h2><h3 id="功能"><a class="markdownIt-Anchor" href="Maven/基础&POM#功能"></a> 功能<a href="Maven/基础&POM#功能"></a></h3><ul><li><p>构建</p></li><li><p>文档生成</p></li><li><p>报告</p></li><li><p>依赖</p></li><li><p>SCMs</p></li><li><p>发布</p></li><li><p>分发</p></li><li><p>邮件列表</p></li></ul><h3 id="约定配置"><a class="markdownIt-Anchor" href="Maven/基础&POM#约定配置"></a> 约定配置<a href="Maven/基础&POM#约定配置"></a></h3><ul><li>提倡使用一个共同的标准目录结构</li><li>使用约定优于配置的原则</li></ul><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">目录</th><th style="text-align:left">目的</th></tr></thead><tbody><tr><td style="text-align:left">${basedir}</td><td style="text-align:left">存放pom.xml和所有的子目录</td></tr><tr><td style="text-align:left">${basedir}/src/main/java</td><td style="text-align:left">项目的java源代码</td></tr><tr><td style="text-align:left">${basedir}/src/main/resources</td><td style="text-align:left">项目的资源，比如说property文件，springmvc.xml</td></tr><tr><td style="text-align:left">${basedir}/src/test/java</td><td style="text-align:left">项目的测试类，比如说Junit代码</td></tr><tr><td style="text-align:left">${basedir}/src/test/resources</td><td style="text-align:left">测试用的资源</td></tr><tr><td style="text-align:left">${basedir}/src/main/webapp/WEB-INF</td><td style="text-align:left">web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面</td></tr><tr><td style="text-align:left">${basedir}/target</td><td style="text-align:left">打包输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/classes</td><td style="text-align:left">编译输出目录</td></tr><tr><td style="text-align:left">${basedir}/target/test-classes</td><td style="text-align:left">测试编译输出目录</td></tr><tr><td style="text-align:left">Test.java</td><td style="text-align:left">Maven只会自动运行符合该命名规则的测试类</td></tr><tr><td style="text-align:left">~/.m2/repository</td><td style="text-align:left">Maven默认的本地仓库目录位置</td></tr></tbody></table></div></div><h3 id="特点"><a class="markdownIt-Anchor" href="Maven/基础&POM#特点"></a> 特点<a href="Maven/基础&POM#特点"></a></h3><ul><li><p><strong>基于模型的构建</strong></p><ul><li>将任意数量的项目构建到预定义的输出类型中，如JAR,WAR</li></ul></li><li><p><strong>项目信息的一致性站点</strong></p><ul><li>能够生成一个网站或PDF，包括要添加的任何文档，并添加到关于项目开发状态的标准报告中</li></ul></li><li><p><strong>发布管理和发布单独的输出</strong></p><ul><li>可直接和Git集成，管理项目发布</li><li>可将代码发布到分发位置供其他项目使用</li><li>能发布单独的输出，包括JAR,包含其他依赖和文档的归档，或源代码</li></ul></li><li><p><strong>向后兼容</strong></p></li><li><p><strong>并行构建</strong></p></li><li><p><strong>错误报告</strong></p><ul><li>提供了wiki界面的链接，可以查看错误的完整描述</li></ul></li></ul><h2 id="maven-pom"><a class="markdownIt-Anchor" href="Maven/基础&POM#maven-pom"></a> Maven POM<a href="Maven/基础&POM#maven-pom"></a></h2><ul><li>POM是maven工程的基本工作单元</li><li>是一个XML文件<ul><li>包含项目基本信息</li><li>用于描述项目如何创建，声明依赖等</li></ul></li><li>执行任务/目标时，Maven会在当前目录中查找POM，读取并获取所需配置信息，然后执行目标</li></ul><h3 id="pom中指定的配置"><a class="markdownIt-Anchor" href="Maven/基础&POM#pom中指定的配置"></a> POM中指定的配置<a href="Maven/基础&POM#pom中指定的配置"></a></h3><ul><li><p>项目依赖</p></li><li><p>插件</p></li><li><p>执行目标</p></li><li><p>项目构建 profile</p></li><li><p>项目版本</p></li><li><p>项目开发者列表</p></li><li><p>相关邮件列表信息</p></li></ul><h3 id="项目组"><a class="markdownIt-Anchor" href="Maven/基础&POM#项目组"></a> 项目组<a href="Maven/基础&POM#项目组"></a></h3><ul><li>项目的唯一ID</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span> = <span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span> = <span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span> = <span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 模型版本 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.project-group<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></div></figure><ul><li>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version</li></ul><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">节点</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">project</td><td style="text-align:left">工程的根标签。</td></tr><tr><td style="text-align:left">modelVersion</td><td style="text-align:left">模型版本需要设置为 4.0。</td></tr><tr><td style="text-align:left">groupId</td><td style="text-align:left">这是工程组的标识。它在一个组织或者项目中通常是唯一的。例如，一个银行组织 com.companyname.project-group 拥有所有的和银行相关的项目。</td></tr><tr><td style="text-align:left">artifactId</td><td style="text-align:left">这是工程的标识。它通常是工程的名称。例如，消费者银行。groupId 和 artifactId 一起定义了 artifact 在仓库中的位置。</td></tr><tr><td style="text-align:left">version</td><td style="text-align:left">这是工程的版本号。在 artifact 的仓库中，它用来区分不同的版本。例如：<br><code>com.company.bank:consumer-banking:1.0 com.company.bank:consumer-banking:1.1</code></td></tr></tbody></table></div></div><h3 id="父pomsuper-pom"><a class="markdownIt-Anchor" href="Maven/基础&POM#父pomsuper-pom"></a> 父POM(Super POM)<a href="Maven/基础&POM#父pomsuper-pom"></a></h3><ul><li>Maven 默认的 POM</li><li>所有的 POM 都继承自一个父 POM<ul><li>无论是否显式定义了这个父 POM</li></ul></li><li>包含了一些可以被继承的默认设置<ul><li>当 Maven 发现需要下载 POM 中的 依赖时，它会到 Super POM 中配置的默认仓库 <a href="http://repo1.maven.org/maven2" target="_blank" rel="noopener">http://repo1.maven.org/maven2</a> 去下载</li></ul></li><li>Maven 使用 effective pom（Super pom 加上工程自己的配置）来执行相关的目标<ul><li>帮助开发者在 pom.xml 中做尽可能少的配置</li><li>这些配置可以被重写</li></ul></li></ul><h4 id="查看super-pom默认配置"><a class="markdownIt-Anchor" href="Maven/基础&POM#查看super-pom默认配置"></a> 查看Super POM默认配置<a href="Maven/基础&POM#查看super-pom默认配置"></a></h4><ul><li>mvn help:effective-pom</li><li>Effective POM 的结果<ul><li>经过继承、插值之后，使配置生效</li></ul></li></ul><h3 id="pom-标签"><a class="markdownIt-Anchor" href="Maven/基础&POM#pom-标签"></a> POM 标签<a href="Maven/基础&POM#pom-标签"></a></h3><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 </span></span><br><span class="line"><span class="comment">        version。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的构件标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的全球唯一标识符 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被继承的父项目的版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 </span></span><br><span class="line"><span class="comment">            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>asia.banseon<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 </span></span><br><span class="line"><span class="comment">        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的名称, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目主页的URL, Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 </span></span><br><span class="line"><span class="comment">        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>A maven project to study maven.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--问题管理系统（例如jira）的名字， --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span>&gt;</span>jira<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的问题管理系统的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://jira.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目持续集成信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--持续集成系统的名字，例如continuum --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">system</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">notifiers</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">notifier</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--传送通知的途径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生错误时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnError</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建失败时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnFailure</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建成功时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnSuccess</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--发生警告时是否通知 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">sendOnWarning</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--不赞成使用。通知发送到哪里 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">address</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--扩展配置项 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">notifier</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">notifiers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">inceptionYear</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目相关邮件列表信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mailingList</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--邮件的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">post</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">post</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">subscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">subscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">unsubscribe</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">unsubscribe</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--你可以浏览邮件信息的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">archive</span>&gt;</span>http:/hi.baidu.com/banseon/demo/dev/<span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mailingList</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目开发者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--某个项目开发者的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--SCM里项目开发者的唯一标识符 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>HELLO WORLD<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的全名 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的email --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span>&gt;</span>banseon@126.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者的主页的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Project Manager<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">role</span>&gt;</span>Architect<span class="tag">&lt;/<span class="name">role</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">roles</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所属组织的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>http://hi.baidu.com/banseon<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者属性，如即时消息如何处理等 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dept</span>&gt;</span>No<span class="tag">&lt;/<span class="name">dept</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span>&gt;</span>-5<span class="tag">&lt;/<span class="name">timezone</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目的其他贡献者列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contributors</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">contributor</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">email</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organization</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">organizationUrl</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">roles</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timezone</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">contributor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--license用于法律上的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache 2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--官方的license正文页面的URL --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon/LICENSE-2.0.txt<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distribution</span>&gt;</span>repo<span class="tag">&lt;/<span class="name">distribution</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--关于license的补充信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">comments</span>&gt;</span>A business-friendly OSS license<span class="tag">&lt;/<span class="name">comments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">connection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk</span><br><span class="line">        <span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tag</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://svn.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织的全名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--组织主页的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.baidu.com/banseon<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--构建项目需要的信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scriptSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testSourceDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的应用程序class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--被编译过的测试class文件存放的目录。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testOutputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用来自该项目的一系列构建扩展 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extensions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--描述使用到的构建扩展。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">extension</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的groupId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的artifactId --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--构建扩展的版本 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">extensions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 </span></span><br><span class="line"><span class="comment">                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含的模式列表，例如**/*.xml. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除的模式列表，例如**/*.xml --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构建产生的所有文件存放的目录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--使用的插件列表 。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--plugin元素包含描述插件所需要的信息。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的group ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--被使用的插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--execution元素包含了插件执行需要的信息 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置的执行目标 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--配置是否被传播到子POM --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--项目引入插件所需要的额外依赖 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            ......</span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--作为DOM对象的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的插件列表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--profile默认是否激活的标志 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统的名字 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Windows XP<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统所属家族(如 'windows') --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">family</span>&gt;</span>Windows<span class="tag">&lt;/<span class="name">family</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统体系结构 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">arch</span>&gt;</span>x86<span class="tag">&lt;/<span class="name">arch</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的操作系统版本 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.2600<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的名称 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span>&gt;</span>mavenVersion<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--激活profile的属性的值 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exists</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">exists</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--如果指定的文件不存在，则激活profile。 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">missing</span>&gt;</span>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">missing</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构建项目所需要的信息。参见build元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">defaultGoal</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">testResources</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">testResource</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">targetPath</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">filtering</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">includes</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">excludes</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">testResource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">finalName</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">filters</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                    ......</span><br><span class="line">                                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">extensions</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">phase</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                                ......</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">name</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">url</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                    ......</span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencyManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        ......</span><br><span class="line">                    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见distributionManagement元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见properties元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现依赖和扩展的远程仓库列表。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程仓库的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如何处理远程仓库里发布版本的下载 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 </span></span><br><span class="line"><span class="comment">                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">enabled</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">updatePolicy</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">checksumPolicy</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon-repository-proxy<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.1.169:9999/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 </span></span><br><span class="line"><span class="comment">                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span>&gt;</span>default<span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            ......</span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-artifact<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， </span></span><br><span class="line"><span class="comment">                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 </span></span><br><span class="line"><span class="comment">                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span><span class="tag">&lt;/<span class="name">classifier</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath </span></span><br><span class="line"><span class="comment">                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 </span></span><br><span class="line"><span class="comment">                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span><span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reports</span>&gt;</span><span class="tag">&lt;/<span class="name">reports</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">reporting</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludeDefaults</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">outputDirectory</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用的报表插件和他们的配置。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--plugin元素包含描述报表插件需要的信息 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的group ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件在仓库里的artifact ID --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--被使用的报表插件的版本（或版本范围） --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--任何配置是否被传播到子项目 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--报表插件的配置 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">reportSets</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--产生报表集合时，被使用的报表的配置 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--配置是否被继承到子POMs --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">inherited</span> /&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!--这个集合里使用到哪些报表 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">reports</span> /&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">reportSet</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">reportSets</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact </span></span><br><span class="line"><span class="comment">        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--参见dependencies/dependency元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                ......</span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>banseon maven2<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>file://$&#123;basedir&#125;/target/deploy<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uniqueVersion</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-maven2<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Banseon-maven2 Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">layout</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">snapshotRepository</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--部署项目的网站需要的信息 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>banseon-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>business api website<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web</span><br><span class="line">            <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">downloadUrl</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relocation</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的group ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的artifact ID --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--构件新的版本号 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">message</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">relocation</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 </span></span><br><span class="line"><span class="comment">            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">status</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;Maven/基础&amp;POM#基础&quot;&gt;&lt;/a&gt; 基础&lt;a href=&quot;Maven/基础&amp;POM#基础&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id=&quot;功能&quot;&gt;&lt;a class=&quot;markdownIt-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Maven/生命周期</title>
    <link href="ilucia.github.io/Maven/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>ilucia.github.io/Maven/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-04-27T15:24:01.559Z</published>
    <updated>2022-04-27T15:24:01.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="maven-生命周期"><a class="markdownIt-Anchor" href="Maven/生命周期#maven-生命周期"></a> Maven 生命周期<a href="Maven/生命周期#maven-生命周期"></a></h2><ul><li>项目构建和发布的过程</li><li>Maven有三个标准的生命周期<ul><li><strong>clean：项目清理的处理</strong></li><li><strong>default(build)：项目部署的处理</strong></li><li><strong>site：项目站点文档创建的处理</strong></li></ul></li><li>在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行<ul><li>如果执行 mvn clean 将运行pre-clean clean两个生命周期</li></ul></li></ul><h4 id="构建生命周期defaultbuild"><a class="markdownIt-Anchor" href="Maven/生命周期#构建生命周期defaultbuild"></a> 构建生命周期(default/build)<a href="Maven/生命周期#构建生命周期defaultbuild"></a></h4><p><img src="/Users/ng/Documents/maven/pictures/maven%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="maven生命周期" class="article-img"></p><ul><li>下面的阶段将顺序执行以完成default生命周期</li></ul><div class="article-bounded"><div class="article-table"><table><thead><tr><th style="text-align:left">生命周期阶段</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">validate（校验）</td><td style="text-align:left">校验项目是否正确并且所有必要的信息可以完成项目的构建过程。</td></tr><tr><td style="text-align:left">initialize（初始化）</td><td style="text-align:left">初始化构建状态，比如设置属性值。</td></tr><tr><td style="text-align:left">generate-sources（生成源代码）</td><td style="text-align:left">生成包含在编译阶段中的任何源代码。</td></tr><tr><td style="text-align:left">process-sources（处理源代码）</td><td style="text-align:left">处理源代码，比如说，过滤任意值。</td></tr><tr><td style="text-align:left">generate-resources（生成资源文件）</td><td style="text-align:left">生成将会包含在项目包中的资源文件。</td></tr><tr><td style="text-align:left">process-resources （处理资源文件）</td><td style="text-align:left">复制和处理资源到目标目录，为打包阶段最好准备。</td></tr><tr><td style="text-align:left">compile（编译）</td><td style="text-align:left">编译项目的源代码。</td></tr><tr><td style="text-align:left">process-classes（处理类文件）</td><td style="text-align:left">处理编译生成的文件，比如说对Java class文件做字节码改善优化。</td></tr><tr><td style="text-align:left">generate-test-sources（生成测试源代码）</td><td style="text-align:left">生成包含在编译阶段中的任何测试源代码。</td></tr><tr><td style="text-align:left">process-test-sources（处理测试源代码）</td><td style="text-align:left">处理测试源代码，比如说，过滤任意值。</td></tr><tr><td style="text-align:left">generate-test-resources（生成测试资源文件）</td><td style="text-align:left">为测试创建资源文件。</td></tr><tr><td style="text-align:left">process-test-resources（处理测试资源文件）</td><td style="text-align:left">复制和处理测试资源到目标目录。</td></tr><tr><td style="text-align:left">test-compile（编译测试源码）</td><td style="text-align:left">编译测试源代码到测试目标目录.</td></tr><tr><td style="text-align:left">process-test-classes（处理测试类文件）</td><td style="text-align:left">处理测试源码编译生成的文件。</td></tr><tr><td style="text-align:left">test（测试）</td><td style="text-align:left">使用合适的单元测试框架运行测试（Juint是其中之一）。</td></tr><tr><td style="text-align:left">prepare-package（准备打包）</td><td style="text-align:left">在实际打包之前，执行任何的必要的操作为打包做准备。</td></tr><tr><td style="text-align:left">package（打包）</td><td style="text-align:left">将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。</td></tr><tr><td style="text-align:left">pre-integration-test（集成测试前）</td><td style="text-align:left">在执行集成测试前进行必要的动作。比如说，搭建需要的环境。</td></tr><tr><td style="text-align:left">integration-test（集成测试）</td><td style="text-align:left">处理和部署项目到可以运行集成测试环境中。</td></tr><tr><td style="text-align:left">post-integration-test（集成测试后）</td><td style="text-align:left">在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。</td></tr><tr><td style="text-align:left">verify （验证）</td><td style="text-align:left">运行任意的检查来验证项目包有效且达到质量标准。</td></tr><tr><td style="text-align:left">install（安装）</td><td style="text-align:left">安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。</td></tr><tr><td style="text-align:left">deploy（部署）</td><td style="text-align:left">将最终的项目包复制到远程仓库中与其他开发者和项目共享。</td></tr></tbody></table></div></div><h4 id="构建阶段"><a class="markdownIt-Anchor" href="Maven/生命周期#构建阶段"></a> 构建阶段<a href="Maven/生命周期#构建阶段"></a></h4><ul><li><strong>由插件目标构成</strong><ul><li>一个插件目标代表一个特定的任务（比构建阶段更为精细）</li><li>这些目标可能被绑定到多个阶段或者无绑定<ul><li>不同的 maven 目标将根据打包的类型（JAR / WAR / EAR），被绑定到不同的 Maven 生命周期阶段</li><li>不绑定到任何构建阶段的目标可以在构建生命周期之外通过直接调用执行</li></ul></li><li>这些目标的执行顺序取决于调用目标和构建阶段的顺序</li></ul></li></ul><h5 id="例-执行顺序"><a class="markdownIt-Anchor" href="Maven/生命周期#例-执行顺序"></a> 例 执行顺序<a href="Maven/生命周期#例-执行顺序"></a></h5><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean dependency:copy-dependencies package</span><br></pre></td></tr></table></div></figure><ul><li>clean 和 pakage 是构建阶段，dependency:copy-dependencies 是目标</li><li>clean 阶段将会被首先执行，然后 dependency:copy-dependencies 目标会被执行，最终 package 阶段被执行</li></ul><h4 id="build-生命周期信息显示"><a class="markdownIt-Anchor" href="Maven/生命周期#build-生命周期信息显示"></a> Build 生命周期信息显示<a href="Maven/生命周期#build-生命周期信息显示"></a></h4><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.validate<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>validate<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span>&gt;</span>validate phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.compile<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span>&gt;</span>compile phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span>&gt;</span>test phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.package<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">echo</span>&gt;</span>package phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.deploy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">phase</span>&gt;</span>deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">echo</span>&gt;</span>deploy phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="命令行调用"><a class="markdownIt-Anchor" href="Maven/生命周期#命令行调用"></a> 命令行调用<a href="Maven/生命周期#命令行调用"></a></h4><h5 id="mvn-install"><a class="markdownIt-Anchor" href="Maven/生命周期#mvn-install"></a> mvn install<a href="Maven/生命周期#mvn-install"></a></h5><ul><li>使用 mvn install 命令去构建/安装工程到本地仓库</li><li>在执行install阶段之前，按顺序执行了default生命周期的阶段<ul><li>只需调用最后一个阶段</li></ul></li></ul><h5 id="mvn-clean-deploy"><a class="markdownIt-Anchor" href="Maven/生命周期#mvn-clean-deploy"></a> mvn clean deploy<a href="Maven/生命周期#mvn-clean-deploy"></a></h5><ul><li>纯净地构建和部署项目到共享仓库中</li><li>也可以用于多模块的情况下，即包含多个子项目的项目，Maven 会在每一个子项目执行 clean 命令，然后再执行 deploy 命令</li></ul><h3 id="clean-生命周期"><a class="markdownIt-Anchor" href="Maven/生命周期#clean-生命周期"></a> Clean 生命周期<a href="Maven/生命周期#clean-生命周期"></a></h3><ul><li>mvn post-clean 命令时，Maven 调用 clean 生命周期</li><li>包含阶段<ul><li>pre-clean：执行一些需要在clean之前完成的工作</li><li>clean：移除所有上一次构建生成的文件</li><li>post-clean：执行一些需要在clean之后立刻完成的工作</li></ul></li></ul><h4 id="修改各阶段操作行为"><a class="markdownIt-Anchor" href="Maven/生命周期#修改各阶段操作行为"></a> 修改各阶段操作行为<a href="Maven/生命周期#修改各阶段操作行为"></a></h4><ul><li>通过这clean生命周期的任何阶段定义目标</li><li>将 maven-antrun-plugin:run 目标添加到三个阶段中<ul><li>这clean生命周期的各个阶段显示文本信息</li></ul></li><li>执行 mvn post-clean</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.pre-clean<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>pre-clean<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">echo</span>&gt;</span>pre-clean phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.clean<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>clean<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">echo</span>&gt;</span>clean phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.post-clean<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>post-clean<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">echo</span>&gt;</span>post-clean phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></div></figure><h4 id="扩展-显示pre-clean和clean-post-clean不执行操作"><a class="markdownIt-Anchor" href="Maven/生命周期#扩展-显示pre-clean和clean-post-clean不执行操作"></a> 扩展 显示pre-clean和clean post-clean不执行操作<a href="Maven/生命周期#扩展-显示pre-clean和clean-post-clean不执行操作"></a></h4><h3 id="site-生命周期"><a class="markdownIt-Anchor" href="Maven/生命周期#site-生命周期"></a> Site 生命周期<a href="Maven/生命周期#site-生命周期"></a></h3><ul><li>Maven Site 插件一般用来创建新的报告文档、部署站点等</li><li>包含阶段<ul><li>pre-site：执行一些需要在生成站点文档之前完成的工作</li><li>site：生成项目的站点文档</li><li>post-site： 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备</li><li>site-deploy：将生成的站点文档部署到特定的服务器上</li></ul></li><li>site阶段和site-deploy阶段，用以生成和发布Maven站点</li><li>将 maven-antrun-plugin:run 目标添加到 Site 生命周期的所有阶段中<ul><li>执行命令 mvn site</li></ul></li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">  http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.companyname.projectgroup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.pre-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>pre-site<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">echo</span>&gt;</span>pre-site phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>site<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">echo</span>&gt;</span>site phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.post-site<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>post-site<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">echo</span>&gt;</span>post-site phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">id</span>&gt;</span>id.site-deploy<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">phase</span>&gt;</span>site-deploy<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tasks</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">echo</span>&gt;</span>site-deploy phase<span class="tag">&lt;/<span class="name">echo</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;maven-生命周期&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;Maven/生命周期#maven-生命周期&quot;&gt;&lt;/a&gt; Maven 生命周期&lt;a href=&quot;Maven/生命周期#maven-生命周期&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;

      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Python进程池、线程池和进程间通信实践参考</title>
    <link href="ilucia.github.io/Template/"/>
    <id>ilucia.github.io/Template/</id>
    <published>2021-08-21T00:00:00.000Z</published>
    <updated>2022-04-27T15:24:01.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="业务需求"><a class="markdownIt-Anchor" href="Template#业务需求"></a> 业务需求<a href="Template#业务需求"></a></h2><p>业务中有一个计算量比较大的、可以并行执行的操作，为了提升资源利用率，故考虑多进程分配。</p><p>性能：多线程&lt;线程池&lt;多进程&lt;进程池</p><blockquote><p>在Windows中创建一个进程耗费的时间以秒计算，故要避免频繁的进程创建销毁</p></blockquote><h3 id="业务流程"><a class="markdownIt-Anchor" href="Template#业务流程"></a> 业务流程<a href="Template#业务流程"></a></h3><ul><li>一个数据产生源，串行产生数据，速度快</li><li>数据源产生的数据需要比较长的时间进行计算才能得到结果</li><li>所有结果要汇总起来进行过滤和处理最终发放下游服务器</li></ul><h3 id="结构设计"><a class="markdownIt-Anchor" href="Template#结构设计"></a> 结构设计<a href="Template#结构设计"></a></h3><ul><li>每个核心分配一个处理进程、附加两个低资源占用低工作进程负责产生数据和发送数据</li><li>使用阻塞式的多进程间队列<ul><li>当任务队列满时数据产生进程阻塞暂时不产生数据（处理不及时）</li><li>当结果队列满时数据处理队列阻塞不产生数据（网络问题或故障）<ul><li>网络请求使用多线程发送，避免过多资源占用低同时保证请求异步不阻塞</li></ul></li></ul></li><li>抽离业务代码的进程池和多线程设计代码如下</li></ul><figure class="highlight"><div><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求地址</span></span><br><span class="line">CONNECTION_URL = <span class="string">'url:'</span></span><br><span class="line"><span class="comment"># CPU核心数</span></span><br><span class="line">CPU_COUNT = os.cpu_count()</span><br><span class="line"><span class="comment"># 工作进程数</span></span><br><span class="line">PROC_COUNT = CPU_COUNT + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送更新数据请求</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(msg: dict)</span>:</span></span><br><span class="line">    r = requests.post(CONNECTION_URL, json=msg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(i, frameQueue, resQueue)</span>:</span> </span><br><span class="line">    print(<span class="string">f"[proc <span class="subst">&#123;i&#125;</span>] pid <span class="subst">&#123;os.getpid()&#125;</span>"</span>)</span><br><span class="line">    <span class="comment"># fetch frame and push to work queqe</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment">#.do some work</span></span><br><span class="line">        frame =.work()</span><br><span class="line">      frameQueue.put(frame)</span><br><span class="line">    <span class="comment"># fetch result from resQueue and post it to server by multthreading</span></span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            res = resQueue.get()</span><br><span class="line">            <span class="comment"># do some work</span></span><br><span class="line">            data = work2(res)</span><br><span class="line">            <span class="comment"># 多线程发送请求</span></span><br><span class="line">            threading.Thread(target=upload, args=(data,)).start()</span><br><span class="line"></span><br><span class="line">   <span class="comment"># data processer process, cost many resources and require multprocessing to speed up</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            frame = frameQueue.get()</span><br><span class="line">            res = work3(frame)</span><br><span class="line">            resQueue.put(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"Process :<span class="subst">&#123;PROC_COUNT&#125;</span>"</span>)</span><br><span class="line">    <span class="comment"># 进程池创建</span></span><br><span class="line">    pool = multiprocessing.Pool(PROC_COUNT)</span><br><span class="line">    <span class="comment"># 任务队列</span></span><br><span class="line">    frameQueue = multiprocessing.Manager().Queue(PROC_COUNT)</span><br><span class="line">    <span class="comment"># 结果队列</span></span><br><span class="line">    resQueue = multiprocessing.Manager().Queue(PROC_COUNT)</span><br><span class="line">    <span class="comment"># 给进程池分配函数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(PROC_COUNT):</span><br><span class="line">        pool.apply_async(</span><br><span class="line">            process, (i, frameQueue, resQueue))</span><br><span class="line">    <span class="comment"># 关闭进程池不再接受新进程</span></span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment"># 阻塞主进程</span></span><br><span class="line">    pool.join()</span><br><span class="line">    print(<span class="string">"finish"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    client()</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;业务需求&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;Template#业务需求&quot;&gt;&lt;/a&gt; 业务需求&lt;a href=&quot;Template#业务需求&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;业务中有一个计算量比较大的、可以并行执行的操作，为了提升资源
      
    
    </summary>
    
    
    
      <category term="Python" scheme="ilucia.github.io/tags/Python/"/>
    
      <category term="multprocessing" scheme="ilucia.github.io/tags/multprocessing/"/>
    
      <category term="multthreading" scheme="ilucia.github.io/tags/multthreading/"/>
    
  </entry>
  
</feed>
